nohup: 忽略输入
[2022-12-28 23:44:35.580] [info] Boost Search Engine start
[2022-12-28 23:44:35.580] [info] GetInstace() start
[2022-12-28 23:44:35.580] [info] GetInstance success
[2022-12-28 23:44:35.580] [info] GetInstance() ok
[2022-12-28 23:44:35.580] [info] BuildIndex() start
[2022-12-28 23:44:35.580] [info] BuildIndex() called with parameters =>data/raw_html/raw.txt
[2022-12-28 23:44:35.580] [info] open data/raw_html/raw.txt file success
2022-12-28 23:45:32 cppjieba/include/cppjieba/PreFilter.hpp:21 ERROR decode failed. 
2022-12-28 23:45:54 cppjieba/include/cppjieba/PreFilter.hpp:21 ERROR decode failed. 
[2022-12-28 23:45:54.826] [info] BuildIndex() ok
[2022-12-28 23:45:54.826] [info] Boost Search Engine build ok
[2022-12-28 23:45:54.827] [info] 服务器启动成功....
[2022-12-28 23:46:38.719] [info] 用户输入的关键字 file
[2022-12-28 23:46:38.719] [info] Search() called with parameters => file
[2022-12-28 23:46:38.719] [info] JieBaUtil::cut start
[2022-12-28 23:46:38.719] [info] JieBaUtil::cut ret
[2022-12-28 23:46:38.719] [info] GetInvertedlist() start
[2022-12-28 23:46:38.719] [info] GetInvertedlist() ret
[2022-12-28 23:46:38.719] [info] GetInvertedlist() file has list
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('conversion_8hpp_source.html','');});/* @license-end */       conversion.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_CONVERTER_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_CONVERTER_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <locale>         12 &#160;        13 &#160; #ifdef BOOST_MSVC         14 &#160; #  pragma warning(push)         15 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         16 &#160; #endif         17 &#160;        18 &#160; namespace  boost {        19 &#160;     namespace  locale {        20 &#160;        27 &#160;        28 &#160;         32  &#160;         class   converter_base  {        33 &#160;         public :         37  &#160;             typedef   enum  {         38  &#160;                 normalization ,           39  &#160;                 upper_case ,              40  &#160;                 lower_case ,              41  &#160;                 case_folding ,            42  &#160;                 title_case               43 &#160;            }  conversion_type ;        44 &#160;        };        45 &#160;        46 &#160;         template < typename  CharType>         47  &#160;         class   converter ;        48 &#160;        49 &#160;         #ifdef BOOST_LOCALE_DOXYGEN         50 &#160;         template < typename  Char>        57 &#160;         class  BOOST_LOCALE_DECL  converter :  public   converter_base ,  public  std::locale::facet {        58 &#160;         public :         60  &#160;             static  std::locale::id  id ;        61 &#160;         63  &#160;             converter ( size_t  refs = 0) : std::locale::facet(refs)        64 &#160;            {        65 &#160;            }        70 &#160;             virtual  std::basic_string<Char> convert(conversion_type how,Char  const  *begin,Char  const  *end, int  flags = 0)  const  = 0;        71 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)         72 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }        73 &#160; #endif         74 &#160;        };        75 &#160;         #else         76 &#160;        77 &#160;         template <>        78 &#160;         class  BOOST_LOCALE_DECL converter<char> :  public  converter_base,  public  std::locale::facet {        79 &#160;         public :        80 &#160;             static  std::locale::id id;        81 &#160;        82 &#160;            converter( size_t  refs = 0) : std::locale::facet(refs)        83 &#160;            {        84 &#160;            }        85 &#160;            ~converter();        86 &#160;             virtual  std::string convert(conversion_type how, char   const  *begin, char   const  *end, int  flags = 0)  const  = 0;        87 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)         88 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }        89 &#160; #endif         90 &#160;        };        91 &#160;        92 &#160;         template <>        93 &#160;         class  BOOST_LOCALE_DECL converter<wchar_t> :  public  converter_base,  public  std::locale::facet {        94 &#160;         public :        95 &#160;             static  std::locale::id id;        96 &#160;            converter( size_t  refs = 0) : std::locale::facet(refs)        97 &#160;            {        98 &#160;            }        99 &#160;            ~converter();       100 &#160;              virtual  std::wstring convert(conversion_type how, wchar_t   const  *begin, wchar_t   const  *end, int  flags = 0)  const  = 0;       101 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        102 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }       103 &#160; #endif        104 &#160;        };       105 &#160;       106 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        107 &#160;         template <>       108 &#160;         class  BOOST_LOCALE_DECL converter<char16_t> :  public  converter_base,  public  std::locale::facet {       109 &#160;         public :       110 &#160;             static  std::locale::id id;       111 &#160;            converter( size_t  refs = 0) : std::locale::facet(refs)       112 &#160;            {       113 &#160;            }       114 &#160;            ~converter();       115 &#160;             virtual  std::u16string convert(conversion_type how,char16_t  const  *begin,char16_t  const  *end, int  flags = 0)  const  = 0;       116 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        117 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }       118 &#160; #endif        119 &#160;        };       120 &#160;         #endif        121 &#160;       122 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        123 &#160;         template <>       124 &#160;         class  BOOST_LOCALE_DECL converter<char32_t> :  public  converter_base,  public  std::locale::facet {       125 &#160;         public :       126 &#160;             static  std::locale::id id;       127 &#160;            converter( size_t  refs = 0) : std::locale::facet(refs)       128 &#160;            {       129 &#160;            }       130 &#160;            ~converter();       131 &#160;             virtual  std::u32string convert(conversion_type how,char32_t  const  *begin,char32_t  const  *end, int  flags = 0)  const  = 0;       132 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        133 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }       134 &#160; #endif        135 &#160;        };       136 &#160;         #endif        137 &#160;       138 &#160;         #endif        139 &#160;       143 &#160;        144  &#160;         typedef   enum  {        145  &#160;             norm_nfd ,           146  &#160;             norm_nfc ,           147  &#160;             norm_nfkd ,          148  &#160;             norm_nfkc ,          149  &#160;             norm_default  =  norm_nfc ,        150 &#160;        }  norm_type ;       151 &#160;       161 &#160;         template < typename  CharType>        162  &#160;        std::basic_string<CharType>  normalize (std::basic_string<CharType>  const  &str, norm_type  n= norm_default ,std::locale  const  &loc=std::locale())       163 &#160;        {       164 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::normalization ,str.data(),str.data() + str.size(),n);       165 &#160;        }       166 &#160;       176 &#160;         template < typename  CharType>        177  &#160;        std::basic_string<CharType>  normalize (CharType  const  *str, norm_type  n= norm_default ,std::locale  const  &loc=std::locale())       178 &#160;        {       179 &#160;            CharType  const  *end=str;       180 &#160;             while (*end)       181 &#160;                end++;       182 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::normalization ,str,end,n);       183 &#160;        }       184 &#160;       194 &#160;         template < typename  CharType>        195  &#160;        std::basic_string<CharType>  normalize (  CharType  const  *begin,       196 &#160;                                                CharType  const  *end,       197 &#160;                                                 norm_type  n= norm_default ,       198 &#160;                                                std::locale  const  &loc=std::locale())       199 &#160;        {       200 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::normalization ,begin,end,n);       201 &#160;        }       202 &#160;       204 &#160;       210 &#160;       211 &#160;         template < typename  CharType>        212  &#160;        std::basic_string<CharType>  to_upper (std::basic_string<CharType>  const  &str,std::locale  const  &loc=std::locale())       213 &#160;        {       214 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::upper_case ,str.data(),str.data()+str.size());       215 &#160;        }       216 &#160;       222 &#160;         template < typename  CharType>        223  &#160;        std::basic_string<CharType>  to_upper (CharType  const  *str,std::locale  const  &loc=std::locale())       224 &#160;        {       225 &#160;            CharType  const  *end=str;       226 &#160;             while (*end)       227 &#160;                end++;       228 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::upper_case ,str,end);       229 &#160;        }       230 &#160;       236 &#160;         template < typename  CharType>        237  &#160;        std::basic_string<CharType>  to_upper (CharType  const  *begin,CharType  const  *end,std::locale  const  &loc=std::locale())       238 &#160;        {       239 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::upper_case ,begin,end);       240 &#160;        }       241 &#160;       243 &#160;       249 &#160;       250 &#160;         template < typename  CharType>        251  &#160;        std::basic_string<CharType>  to_lower (std::basic_string<CharType>  const  &str,std::locale  const  &loc=std::locale())       252 &#160;        {       253 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::lower_case ,str.data(),str.data()+str.size());       254 &#160;        }       255 &#160;       261 &#160;         template < typename  CharType>        262  &#160;        std::basic_string<CharType>  to_lower (CharType  const  *str,std::locale  const  &loc=std::locale())       263 &#160;        {       264 &#160;            CharType  const  *end=str;       265 &#160;             while (*end)       266 &#160;                end++;       267 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::lower_case ,str,end);       268 &#160;        }       269 &#160;       275 &#160;         template < typename  CharType>        276  &#160;        std::basic_string<CharType>  to_lower (CharType  const  *begin,CharType  const  *end,std::locale  const  &loc=std::locale())       277 &#160;        {       278 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::lower_case ,begin,end);       279 &#160;        }       281 &#160;       287 &#160;       288 &#160;         template < typename  CharType>        289  &#160;        std::basic_string<CharType>  to_title (std::basic_string<CharType>  const  &str,std::locale  const  &loc=std::locale())       290 &#160;        {       291 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::title_case ,str.data(),str.data()+str.size());       292 &#160;        }       293 &#160;       299 &#160;         template < typename  CharType>        300  &#160;        std::basic_string<CharType>  to_title (CharType  const  *str,std::locale  const  &loc=std::locale())       301 &#160;        {       302 &#160;            CharType  const  *end=str;       303 &#160;             while (*end)       304 &#160;                end++;       305 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::title_case ,str,end);       306 &#160;        }       307 &#160;       313 &#160;         template < typename  CharType>        314  &#160;        std::basic_string<CharType>  to_title (CharType  const  *begin,CharType  const  *end,std::locale  const  &loc=std::locale())       315 &#160;        {       316 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::title_case ,begin,end);       317 &#160;        }       318 &#160;       320 &#160;       326 &#160;       327 &#160;         template < typename  CharType>        328  &#160;        std::basic_string<CharType>  fold_case (std::basic_string<CharType>  const  &str,std::locale  const  &loc=std::locale())       329 &#160;        {       330 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::case_folding ,str.data(),str.data()+str.size());       331 &#160;        }       332 &#160;       338 &#160;         template < typename  CharType>        339  &#160;        std::basic_string<CharType>  fold_case (CharType  const  *str,std::locale  const  &loc=std::locale())       340 &#160;        {       341 &#160;            CharType  const  *end=str;       342 &#160;             while (*end)       343 &#160;                end++;       344 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::case_folding ,str,end);       345 &#160;        }       346 &#160;       352 &#160;         template < typename  CharType>        353  &#160;        std::basic_string<CharType>  fold_case (CharType  const  *begin,CharType  const  *end,std::locale  const  &loc=std::locale())       354 &#160;        {       355 &#160;             return  std::use_facet<converter<CharType> >(loc).convert( converter_base::case_folding ,begin,end);       356 &#160;        }       357 &#160;       361 &#160;    }  // locale        362 &#160;       363 &#160;}  // boost        364 &#160;       365 &#160; #ifdef BOOST_MSVC        366 &#160; #pragma warning(pop)        367 &#160; #endif        368 &#160;       369 &#160;       370 &#160; #endif        371 &#160;       381 &#160;       382 &#160;    boost::locale::norm_nfd   Canonical decomposition.   Definition:  conversion.hpp:145     boost::locale::fold_case   std::basic_string< CharType > fold_case(std::basic_string< CharType > const &str, std::locale const &loc=std::locale())   Definition:  conversion.hpp:328     boost::locale::converter_base::normalization   Apply Unicode normalization on the text.   Definition:  conversion.hpp:38     boost::locale::converter   The facet that implements text manipulation.   Definition:  conversion.hpp:47     boost::locale::converter_base::lower_case   Convert text to lower case.   Definition:  conversion.hpp:40     boost::locale::to_title   std::basic_string< CharType > to_title(std::basic_string< CharType > const &str, std::locale const &loc=std::locale())   Definition:  conversion.hpp:289     boost::locale::converter_base::upper_case   Convert text to upper case.   Definition:  conversion.hpp:39     boost::locale::to_upper   std::basic_string< CharType > to_upper(std::basic_string< CharType > const &str, std::locale const &loc=std::locale())   Definition:  conversion.hpp:212     boost::locale::norm_nfkd   Compatibility decomposition.   Definition:  conversion.hpp:147     boost::locale::converter_base   This class provides base flags for text manipulation. It is used as base for converter facet.   Definition:  conversion.hpp:32     boost::locale::converter_base::title_case   Convert text to title case.   Definition:  conversion.hpp:42     boost::locale::norm_type   norm_type   Definition:  conversion.hpp:144     boost::locale::norm_nfkc   Compatibility decomposition followed by canonical composition.   Definition:  conversion.hpp:148     boost::locale::converter_base::conversion_type   conversion_type   Definition:  conversion.hpp:37     boost::locale::to_lower   std::basic_string< CharType > to_lower(std::basic_string< CharType > const &str, std::locale const &loc=std::locale())   Definition:  conversion.hpp:251     boost::locale::converter_base::case_folding   Fold case in the text.   Definition:  conversion.hpp:41     boost::locale::normalize   std::basic_string< CharType > normalize(std::basic_string< CharType > const &str, norm_type n=norm_default, std::locale const &loc=std::locale())   Definition:  conversion.hpp:162     boost::locale::converter::id   static std::locale::id id  Locale identification.   Definition:  conversion.hpp:60     boost::locale::norm_nfc   Canonical decomposition followed by canonical composition.   Definition:  conversion.hpp:146     boost::locale::converter::converter   converter(size_t refs=0)  Standard constructor.   Definition:  conversion.hpp:63     boost::locale::norm_default   Default normalization - canonical decomposition followed by canonical composition.   Definition:  conversion.hpp:149             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide    detail             is_string_container.hpp                1 &#160; //          2 &#160; // Copyright (c) 2020 Alexander Grund          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_DETAIL_IS_STRING_CONTAINER_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_DETAIL_IS_STRING_CONTAINER_HPP_INCLUDED          9 &#160;        10 &#160; #include <cstddef>         11 &#160; #include <type_traits>         12 &#160;        13 &#160; namespace  boost {        14 &#160; namespace  nowide {        15 &#160;     namespace  detail {        16 &#160;         template < class ...>        17 &#160;         struct  make_void        18 &#160;        {        19 &#160;             typedef   void  type;        20 &#160;        };        21 &#160;        22 &#160;         template < class ... Ts>        23 &#160;         using  void_t =  typename  make_void<Ts...>::type;        24 &#160;        25 &#160;         template < typename  T>        26 &#160;         struct  is_char_type : std::false_type        27 &#160;        {};        28 &#160;         template <>        29 &#160;         struct  is_char_type<char> : std::true_type        30 &#160;        {};        31 &#160;         template <>        32 &#160;         struct  is_char_type<wchar_t> : std::true_type        33 &#160;        {};        34 &#160;         template <>        35 &#160;         struct  is_char_type<char16_t> : std::true_type        36 &#160;        {};        37 &#160;         template <>        38 &#160;         struct  is_char_type<char32_t> : std::true_type        39 &#160;        {};        40 &#160; #ifdef __cpp_char8_t         41 &#160;         template <>        42 &#160;         struct  is_char_type<char8_t> : std::true_type        43 &#160;        {};        44 &#160; #endif         45 &#160;        46 &#160;         template < typename  T>        47 &#160;         struct  is_c_string : std::false_type        48 &#160;        {};        49 &#160;         template < typename  T>        50 &#160;         struct  is_c_string<const T*> : is_char_type<T>        51 &#160;        {};        52 &#160;        53 &#160;         template < typename  T>        54 &#160;         using  const_data_result = decltype(std::declval<const T>().data());        56 &#160;         template < typename  T>        57 &#160;         using  get_data_width =        58 &#160;          std::integral_constant<std::size_t,  sizeof ( typename  std::remove_pointer<const_data_result<T>>::type)>;        59 &#160;         template < typename  T>        60 &#160;         using  size_result = decltype(std::declval<T>().size());        62 &#160;         template < typename  T>        63 &#160;         using  has_narrow_data = std::integral_constant<bool, (get_data_width<T>::value == 1)>;        64 &#160;        68 &#160;         template < typename  T,  bool  isNarrow,  typename  =  void >        69 &#160;         struct  is_string_container : std::false_type        70 &#160;        {};        71 &#160;         // clang-format off         72 &#160;         template < typename  T,  bool  isNarrow>        73 &#160;         struct  is_string_container<T, isNarrow, void_t<decltype(T::npos), size_result<T>, const_data_result<T>>>        74 &#160;            : std::integral_constant<bool,        75 &#160;                                     std::is_integral<decltype(T::npos)>::value        76 &#160;                                       && std::is_integral<size_result<T>>::value        77 &#160;                                       && is_c_string<const_data_result<T>>::value        78 &#160;                                       && isNarrow == has_narrow_data<T>::value>        79 &#160;        {};        80 &#160;         // clang-format on         81 &#160;         template < typename  T>        82 &#160;         using  requires_narrow_string_container =  typename  std::enable_if<is_string_container<T, true>::value>::type;        83 &#160;         template < typename  T>        84 &#160;         using  requires_wide_string_container =  typename  std::enable_if<is_string_container<T, false>::value>::type;        85 &#160;        86 &#160;         template < typename  T>        87 &#160;         using  requires_narrow_char =  typename  std::enable_if< sizeof (T) == 1 && is_char_type<T>::value>::type;        88 &#160;         template < typename  T>        89 &#160;         using  requires_wide_char =  typename  std::enable_if<( sizeof (T) > 1) && is_char_type<T>::value>::type;        90 &#160;        91 &#160;    }  // namespace detail         92 &#160;}  // namespace nowide         93 &#160;}  // namespace boost         94 &#160;        95 &#160; #endif          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('util_8hpp_source.html','');});/* @license-end */       util.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_UTIL_HPP          8 &#160; #define BOOST_LOCALE_UTIL_HPP          9 &#160;        10 &#160; #include <boost/locale/generator.hpp>         11 &#160; #include <boost/locale/utf.hpp>         12 &#160; #include <boost/assert.hpp>         13 &#160; #include <boost/cstdint.hpp>         14 &#160; #include <locale>         15 &#160; #ifndef BOOST_NO_CXX11_SMART_PTR         16 &#160; #include <memory>         17 &#160; #endif         18 &#160; #include <typeinfo>         19 &#160;        20 &#160; namespace  boost {        21 &#160; namespace  locale {         26  &#160; namespace  util {        27 &#160;        41 &#160;    BOOST_LOCALE_DECL        42 &#160;    std::string  get_system_locale ( bool  use_utf8_on_windows =  false );        43 &#160;        61 &#160;    BOOST_LOCALE_DECL        62 &#160;    std::locale  create_info (std::locale  const  &in,std::string  const  &name);        63 &#160;        64 &#160;         79  &#160;     class  BOOST_LOCALE_DECL  base_converter  {        80 &#160;     public :        81 &#160;         87  &#160;         static   const  uint32_t illegal= utf::illegal ;        88 &#160;         93  &#160;         static   const  uint32_t incomplete= utf::incomplete ;        94 &#160;        95 &#160;         virtual  ~ base_converter ();        100  &#160;         virtual   int   max_len ()  const        101 &#160;          {       102 &#160;             return  1;       103 &#160;        }        113  &#160;         virtual   bool   is_thread_safe ()  const        114 &#160;          {       115 &#160;             return   false ;       116 &#160;        }        120  &#160;         virtual   base_converter  * clone ()  const        121 &#160;          {       122 &#160;            BOOST_ASSERT( typeid (* this )== typeid ( base_converter ));       123 &#160;             return   new   base_converter ();       124 &#160;        }       125 &#160;        141  &#160;         virtual  uint32_t  to_unicode ( char   const  *&begin, char   const  *end)       142 &#160;        {       143 &#160;             if (begin == end)       144 &#160;                 return  incomplete;       145 &#160;             unsigned   char  cp = *begin;       146 &#160;             if (cp <= 0x7F) {       147 &#160;                begin++;       148 &#160;                 return  cp;       149 &#160;            }       150 &#160;             return  illegal;       151 &#160;        }       163 &#160;        164  &#160;         virtual  uint32_t  from_unicode (uint32_t u, char  *begin, char   const  *end)       165 &#160;        {       166 &#160;             if (begin==end)       167 &#160;                 return  incomplete;       168 &#160;             if (u >= 0x80)       169 &#160;                 return  illegal;       170 &#160;            *begin = static_cast<char>(u);       171 &#160;             return  1;       172 &#160;        }       173 &#160;    };       174 &#160;       175 &#160;     #if BOOST_LOCALE_USE_AUTO_PTR        176 &#160;    BOOST_LOCALE_DECL std::auto_ptr<base_converter> create_utf8_converter();       188 &#160;    BOOST_LOCALE_DECL std::auto_ptr<base_converter> create_simple_converter(std::string  const  &encoding);       189 &#160;       190 &#160;       202 &#160;    BOOST_LOCALE_DECL       203 &#160;    std::locale  create_codecvt (std::locale  const  &in,std::auto_ptr<base_converter> cvt, character_facet_type  type);       204 &#160;     #endif        205 &#160;       206 &#160;     #ifndef BOOST_NO_CXX11_SMART_PTR        207 &#160;    BOOST_LOCALE_DECL std::unique_ptr<base_converter>  create_utf8_converter_unique_ptr ();       219 &#160;    BOOST_LOCALE_DECL std::unique_ptr<base_converter>  create_simple_converter_unique_ptr (std::string  const  &encoding);       220 &#160;       232 &#160;    BOOST_LOCALE_DECL       233 &#160;    std::locale  create_codecvt (std::locale  const  &in,std::unique_ptr<base_converter> cvt, character_facet_type  type);       234 &#160;     #endif        235 &#160;       240 &#160;    BOOST_LOCALE_DECL base_converter * create_utf8_converter_new_ptr ();       248 &#160;    BOOST_LOCALE_DECL base_converter * create_simple_converter_new_ptr (std::string  const  &encoding);       249 &#160;       263 &#160;    BOOST_LOCALE_DECL       264 &#160;    std::locale  create_codecvt_from_pointer (std::locale  const  &in,base_converter *cvt, character_facet_type  type);       265 &#160;       270 &#160;    BOOST_LOCALE_DECL       271 &#160;    std::locale  create_utf8_codecvt (std::locale  const  &in, character_facet_type  type);       272 &#160;       279 &#160;    BOOST_LOCALE_DECL       280 &#160;    std::locale  create_simple_codecvt (std::locale  const  &in,std::string  const  &encoding, character_facet_type  type);       281 &#160;}  // util        282 &#160;}  // locale        283 &#160;}  // boost        284 &#160;       285 &#160; #endif     boost::locale::util::base_converter::clone   virtual base_converter * clone() const   Definition:  util.hpp:120     boost::locale::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:44     boost::locale::util::create_codecvt_from_pointer   std::locale create_codecvt_from_pointer(std::locale const &in, base_converter *cvt, character_facet_type type)     boost::locale::util::base_converter::to_unicode   virtual uint32_t to_unicode(char const *&begin, char const *end)   Definition:  util.hpp:141     boost::locale::util::create_codecvt   std::locale create_codecvt(std::locale const &in, std::unique_ptr< base_converter > cvt, character_facet_type type)     boost::locale::util::create_info   std::locale create_info(std::locale const &in, std::string const &name)  Installs information facet to locale in based on locale name name.     boost::locale::util::create_utf8_converter_unique_ptr   std::unique_ptr< base_converter > create_utf8_converter_unique_ptr()     boost::locale::util::create_simple_converter_new_ptr   base_converter * create_simple_converter_new_ptr(std::string const &encoding)     boost::locale::character_facet_type   uint32_t character_facet_type  type that specifies the character type that locales can be generated for   Definition:  generator.hpp:41     boost::locale::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:39     boost::locale::util::base_converter::max_len   virtual int max_len() const   Definition:  util.hpp:100     boost::locale::util::create_simple_converter_unique_ptr   std::unique_ptr< base_converter > create_simple_converter_unique_ptr(std::string const &encoding)     boost::locale::util::create_utf8_converter_new_ptr   base_converter * create_utf8_converter_new_ptr()     boost::locale::util::base_converter   This class represent a simple stateless converter from UCS-4 and to UCS-4 for each single code point.   Definition:  util.hpp:79     boost::locale::util::get_system_locale   std::string get_system_locale(bool use_utf8_on_windows=false)  Return default system locale name in POSIX format.     boost::locale::util::create_simple_codecvt   std::locale create_simple_codecvt(std::locale const &in, std::string const &encoding, character_facet_type type)     boost::locale::util::base_converter::from_unicode   virtual uint32_t from_unicode(uint32_t u, char *begin, char const *end)   Definition:  util.hpp:164     boost::locale::util::create_utf8_codecvt   std::locale create_utf8_codecvt(std::locale const &in, character_facet_type type)     boost::locale::util::base_converter::is_thread_safe   virtual bool is_thread_safe() const   Definition:  util.hpp:113             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('localization__backend_8hpp_source.html','');});/* @license-end */       localization_backend.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_LOCALIZATION_BACKEND_HPP          8 &#160; #define BOOST_LOCALE_LOCALIZATION_BACKEND_HPP          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/locale/generator.hpp>         12 &#160; #include <boost/locale/hold_ptr.hpp>         13 &#160; #include <locale>         14 &#160; #include <memory>         15 &#160; #include <string>         16 &#160; #include <vector>         17 &#160;        18 &#160; #ifdef BOOST_MSVC         19 &#160; #  pragma warning(push)         20 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         21 &#160; #endif         22 &#160;        23 &#160; namespace  boost {        24 &#160;     namespace  locale {        25 &#160;        44 &#160;         45  &#160;         class   localization_backend  {        46 &#160;             localization_backend ( localization_backend   const  &);        47 &#160;             void  operator=( localization_backend   const  &);        48 &#160;         public :        49 &#160;        50 &#160;             localization_backend () {}        51 &#160;        52 &#160;             virtual  ~ localization_backend () {}        53 &#160;        57 &#160;             virtual   localization_backend  * clone ()  const  = 0;        58 &#160;        62 &#160;             virtual   void   set_option (std::string  const  &name,std::string  const  &value) = 0;        63 &#160;        67 &#160;             virtual   void   clear_options () = 0;        68 &#160;        72 &#160;             virtual  std::locale  install (std::locale  const  &base, locale_category_type  category, character_facet_type  type =  nochar_facet ) = 0;        73 &#160;        74 &#160;        };  // localization_backend         75 &#160;        76 &#160;        81 &#160;         82  &#160;         class  BOOST_LOCALE_DECL  localization_backend_manager  {        83 &#160;         public :        87 &#160;             localization_backend_manager ();        91 &#160;             localization_backend_manager ( localization_backend_manager   const  &);        95 &#160;             localization_backend_manager   const  &operator=( localization_backend_manager   const  &);        96 &#160;       100 &#160;            ~ localization_backend_manager ();       101 &#160;       102 &#160;             #if BOOST_LOCALE_USE_AUTO_PTR        103 &#160;            std::auto_ptr<localization_backend> get()  const ;       107 &#160;       113 &#160;             void  add_backend(std::string  const  &name,std::auto_ptr<localization_backend> backend);       114 &#160;             #endif        115 &#160;       119 &#160;             localization_backend  *create()  const ;       126 &#160;             void  adopt_backend(std::string  const  &name, localization_backend  *backend);       127 &#160;             #ifndef BOOST_NO_CXX11_SMART_PTR        128 &#160;            std::unique_ptr<localization_backend> get_unique_ptr()  const ;       132 &#160;       138 &#160;             void  add_backend(std::string  const  &name,std::unique_ptr<localization_backend> backend);       139 &#160;             #endif        140 &#160;       144 &#160;             void  remove_all_backends();       145 &#160;       149 &#160;            std::vector<std::string> get_all_backends()  const ;       150 &#160;       155 &#160;             void  select(std::string  const  &backend_name, locale_category_type  category =  all_categories );       156 &#160;       162 &#160;             static   localization_backend_manager  global( localization_backend_manager   const  &);       168 &#160;             static   localization_backend_manager  global();       169 &#160;         private :       170 &#160;             class  impl;       171 &#160;             hold_ptr<impl>  pimpl_;       172 &#160;        };       173 &#160;       174 &#160;    }  // locale        175 &#160;}  // boost        176 &#160;       177 &#160;       178 &#160; #ifdef BOOST_MSVC        179 &#160; #pragma warning(pop)        180 &#160; #endif        181 &#160;       182 &#160; #endif        183 &#160;    boost::locale::localization_backend_manager   Localization backend manager is a class that holds various backend and allows creation of their combi...   Definition:  localization_backend.hpp:82     boost::locale::localization_backend::clear_options   virtual void clear_options()=0     boost::locale::localization_backend::install   virtual std::locale install(std::locale const &base, locale_category_type category, character_facet_type type=nochar_facet)=0     boost::locale::nochar_facet   static const uint32_t nochar_facet  Unspecified character category for character independent facets.   Definition:  generator.hpp:31     boost::locale::character_facet_type   uint32_t character_facet_type  type that specifies the character type that locales can be generated for   Definition:  generator.hpp:41     boost::locale::localization_backend::clone   virtual localization_backend * clone() const =0     boost::locale::localization_backend   this class represents a localization backend that can be used for localizing your application.   Definition:  localization_backend.hpp:45     boost::locale::hold_ptr< impl >      boost::locale::locale_category_type   uint32_t locale_category_type  a type used for more fine grained generation of facets   Definition:  generator.hpp:63     boost::locale::all_categories   static const uint32_t all_categories  Generate all of them.   Definition:  generator.hpp:61     boost::locale::localization_backend::set_option   virtual void set_option(std::string const &name, std::string const &value)=0             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('info_8hpp_source.html','');});/* @license-end */       info.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_INFO_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_INFO_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <locale>         12 &#160; #include <string>         13 &#160;        14 &#160; #ifdef BOOST_MSVC         15 &#160; #  pragma warning(push)         16 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         17 &#160; #endif         18 &#160;        19 &#160; namespace  boost {        20 &#160;     namespace  locale {        21 &#160;         27  &#160;         class  BOOST_LOCALE_DECL  info  :  public  std::locale::facet        28 &#160;        {        29 &#160;         public :        30 &#160;            ~ info ();        31 &#160;         32  &#160;             static  std::locale::id  id ;         33 &#160;         37  &#160;             enum   string_propery  {         38  &#160;                 language_property ,           39  &#160;                 country_property ,            40  &#160;                 variant_property ,            41  &#160;                 encoding_property ,            42  &#160;                name_property               43 &#160;            };        44 &#160;         48  &#160;             enum   integer_property  {         49  &#160;                utf8_property               50 &#160;            };        51 &#160;        52 &#160;         56  &#160;             info ( size_t  refs = 0) : std::locale::facet(refs)        57 &#160;            {        58 &#160;            }         62  &#160;            std::string  language ()  const         63 &#160;              {        64 &#160;                 return  get_string_property(language_property);        65 &#160;            }         69  &#160;            std::string  country ()  const         70 &#160;              {        71 &#160;                 return  get_string_property(country_property);        72 &#160;            }         76  &#160;            std::string  variant ()  const         77 &#160;              {        78 &#160;                 return  get_string_property(variant_property);        79 &#160;            }         83  &#160;            std::string  encoding ()  const         84 &#160;              {        85 &#160;                 return  get_string_property(encoding_property);        86 &#160;            }        87 &#160;         91  &#160;            std::string  name ()  const         92 &#160;              {        93 &#160;                 return  get_string_property(name_property);        94 &#160;            }        95 &#160;         99  &#160;             bool   utf8 ()  const        100 &#160;              {       101 &#160;                 return  get_integer_property(utf8_property) != 0;       102 &#160;            }       103 &#160;       104 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        105 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }       106 &#160; #endif        107 &#160;         protected :       111 &#160;             virtual  std::string get_string_property(string_propery v)  const  = 0;       115 &#160;             virtual   int  get_integer_property(integer_property v)  const  = 0;       116 &#160;        };       117 &#160;       118 &#160;    }       119 &#160;}       120 &#160;       121 &#160; #ifdef BOOST_MSVC        122 &#160; #pragma warning(pop)        123 &#160; #endif        124 &#160;       125 &#160; #endif        126 &#160;    boost::locale::info::country   std::string country() const   Definition:  info.hpp:69     boost::locale::info::country_property   ISO 3166 country id.   Definition:  info.hpp:39     boost::locale::info::language   std::string language() const   Definition:  info.hpp:62     boost::locale::info::language_property   ISO 639 language id.   Definition:  info.hpp:38     boost::locale::info   a facet that holds general information about locale   Definition:  info.hpp:27     boost::locale::info::variant_property   Variant for locale.   Definition:  info.hpp:40     boost::locale::info::info   info(size_t refs=0)   Definition:  info.hpp:56     boost::locale::info::utf8   bool utf8() const   Definition:  info.hpp:99     boost::locale::info::integer_property   integer_property   Definition:  info.hpp:48     boost::locale::info::encoding   std::string encoding() const   Definition:  info.hpp:83     boost::locale::info::variant   std::string variant() const   Definition:  info.hpp:76     boost::locale::info::string_propery   string_propery   Definition:  info.hpp:37     boost::locale::info::id   static std::locale::id id  This member uniquely defines this facet, required by STL.   Definition:  info.hpp:32     boost::locale::info::name   std::string name() const   Definition:  info.hpp:91     boost::locale::info::encoding_property   encoding name   Definition:  info.hpp:41             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('time__zone_8hpp_source.html','');});/* @license-end */       time_zone.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_TIME_ZONE_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_TIME_ZONE_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <string>         12 &#160;        13 &#160; #ifdef BOOST_MSVC         14 &#160; #  pragma warning(push)         15 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         16 &#160; #endif         17 &#160;        18 &#160; namespace  boost {        19 &#160;     namespace  locale {        24 &#160;         29  &#160;         namespace   time_zone  {        33 &#160;            BOOST_LOCALE_DECL std::string  global ();        37 &#160;            BOOST_LOCALE_DECL std::string  global (std::string  const  &new_tz);        38 &#160;        }        39 &#160;        41 &#160;        42 &#160;    }  // locale         43 &#160;}  // boost         44 &#160;        45 &#160; #ifdef BOOST_MSVC         46 &#160; #pragma warning(pop)         47 &#160; #endif         48 &#160;        49 &#160;        50 &#160; #endif         51 &#160;    boost::locale::time_zone::global   std::string global()     boost::locale::as::time_zone   unspecified_type time_zone(char const *id)   Definition:  formatting.hpp:634             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('types_8hpp_source.html','');});/* @license-end */       types.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_TYPES_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_TYPES_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/assert.hpp>         12 &#160; #include <boost/cstdint.hpp>         13 &#160;        14 &#160; #ifdef BOOST_MSVC         15 &#160; #  pragma warning(push)         16 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         17 &#160; #endif         18 &#160;        19 &#160; namespace  boost {        20 &#160;        21 &#160;     namespace  locale {        22 &#160;        26 &#160;         namespace  boundary {        34 &#160;         38  &#160;             enum   boundary_type  {         39  &#160;                 character ,           40  &#160;                 word ,                41  &#160;                 sentence ,            42  &#160;                 line                 43 &#160;            };        44 &#160;         50  &#160;             typedef  uint32_t  rule_type ;        51 &#160;        56 &#160;             static   const   rule_type          57  &#160;                 word_none        =  0x0000F,            58  &#160;                 word_number      =  0x000F0,            59  &#160;                 word_letter      =  0x00F00,            60  &#160;                 word_kana        =  0x0F000,            61  &#160;                 word_ideo        =  0xF0000,            62  &#160;                 word_any         =  0xFFFF0,            63  &#160;                 word_letters     =  0xFFF00,            64  &#160;                 word_kana_ideo   =  0xFF000,            65  &#160;                 word_mask        =  0xFFFFF;           66 &#160;        72 &#160;             static   const   rule_type          73  &#160;                 line_soft        =  0x0F,            74  &#160;                 line_hard        =  0xF0,            75  &#160;                 line_any         =  0xFF,            76  &#160;                 line_mask        =  0xFF;           77 &#160;        79 &#160;        85 &#160;             static   const   rule_type          86  &#160;                 sentence_term    =  0x0F,            87 &#160;                 sentence_sep     =  0xF0,            89 &#160;                 sentence_any     =  0xFF,             91  &#160;                 sentence_mask    =  0xFF;            92 &#160;        94 &#160;       101 &#160;             static   const   rule_type         102  &#160;                 character_any    =  0xF,             103  &#160;                 character_mask   =  0xF;            104 &#160;       106 &#160;        110  &#160;             inline   rule_type   boundary_rule ( boundary_type  t)       111 &#160;            {       112 &#160;                 switch (t) {       113 &#160;                 case   character :  return   character_mask ;       114 &#160;                 case   word :       return   word_mask ;       115 &#160;                 case   sentence :   return   sentence_mask ;       116 &#160;                 case   line :       return   line_mask ;       117 &#160;                 default :         return  0;       118 &#160;                }       119 &#160;            }       120 &#160;       124 &#160;       125 &#160;        }  // boundary        126 &#160;    }  // locale        127 &#160;}  // boost        128 &#160;       129 &#160;       130 &#160; #ifdef BOOST_MSVC        131 &#160; #pragma warning(pop)        132 &#160; #endif        133 &#160;       134 &#160; #endif     boost::locale::boundary::boundary_type   boundary_type   Definition:  types.hpp:38     boost::locale::boundary::character_any   static const rule_type character_any  Not in use, just for consistency.   Definition:  types.hpp:102     boost::locale::boundary::line   Analyse the text for positions suitable for line breaks.   Definition:  types.hpp:42     boost::locale::boundary::sentence_sep   static const rule_type sentence_sep  The sentence does not contain terminator like &quot;.&quot;, &quot;!&quot; but ended with hard separator like CR,...   Definition:  types.hpp:88     boost::locale::boundary::word_letter   static const rule_type word_letter  Word that contains letters, excluding kana and ideographic characters.   Definition:  types.hpp:59     boost::locale::boundary::word_any   static const rule_type word_any  Any word including numbers, 0 is special flag, equivalent to 15.   Definition:  types.hpp:62     boost::locale::boundary::line_any   static const rule_type line_any  Soft or Hard line break.   Definition:  types.hpp:75     boost::locale::boundary::rule_type   uint32_t rule_type  Flags used with word boundary analysis – the type of the word, line or sentence boundary found.   Definition:  types.hpp:50     boost::locale::boundary::line_hard   static const rule_type line_hard  Hard line break: like break is required (as per CR/LF)   Definition:  types.hpp:74     boost::locale::boundary::sentence_term   static const rule_type sentence_term  The sentence was terminated with a sentence terminator like &quot;.&quot;, &quot;!&quot; possible followed by hard separa...   Definition:  types.hpp:86     boost::locale::boundary::line_mask   static const rule_type line_mask  Select all types of line breaks.   Definition:  types.hpp:76     boost::locale::boundary::word_ideo   static const rule_type word_ideo  Word that contains ideographic characters.   Definition:  types.hpp:61     boost::locale::boundary::word_letters   static const rule_type word_letters  Any word, excluding numbers but including letters, kana and ideograms.   Definition:  types.hpp:63     boost::locale::boundary::boundary_rule   rule_type boundary_rule(boundary_type t)   Definition:  types.hpp:110     boost::locale::boundary::sentence_mask   static const rule_type sentence_mask  Select all sentence breaking points.   Definition:  types.hpp:91     boost::locale::boundary::character   Analyse the text for character boundaries.   Definition:  types.hpp:39     boost::locale::boundary::word_number   static const rule_type word_number  Word that appear to be a number.   Definition:  types.hpp:58     boost::locale::boundary::line_soft   static const rule_type line_soft  Soft line break: optional but not required.   Definition:  types.hpp:73     boost::locale::boundary::word_kana   static const rule_type word_kana  Word that contains kana characters.   Definition:  types.hpp:60     boost::locale::boundary::sentence   Analyse the text for Find sentence boundaries.   Definition:  types.hpp:41     boost::locale::boundary::word_none   static const rule_type word_none  Not a word, like white space or punctuation mark.   Definition:  types.hpp:57     boost::locale::boundary::character_mask   static const rule_type character_mask  Select all character breaking points.   Definition:  types.hpp:103     boost::locale::boundary::word   Analyse the text for word boundaries.   Definition:  types.hpp:40     boost::locale::boundary::word_mask   static const rule_type word_mask  Full word mask - select all possible variants.   Definition:  types.hpp:65     boost::locale::boundary::word_kana_ideo   static const rule_type word_kana_ideo  Word that includes kana or ideographic characters.   Definition:  types.hpp:64     boost::locale::boundary::sentence_any   static const rule_type sentence_any  Either first or second sentence break type;.   Definition:  types.hpp:90             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             utf8_codecvt.hpp                1 &#160; //          2 &#160; // Copyright (c) 2015 Artyom Beilis (Tonkikh)          3 &#160; // Copyright (c) 2020 Alexander Grund          4 &#160; //          5 &#160; // Distributed under the Boost Software License, Version 1.0.          6 &#160; // https://www.boost.org/LICENSE_1_0.txt          7 &#160;         8 &#160; #ifndef BOOST_NOWIDE_UTF8_CODECVT_HPP_INCLUDED          9 &#160; #define BOOST_NOWIDE_UTF8_CODECVT_HPP_INCLUDED         10 &#160;        11 &#160; #include < boost/nowide/replacement.hpp >         12 &#160; #include <boost/nowide/utf/utf.hpp>         13 &#160; #include <cassert>         14 &#160; #include <cstdint>         15 &#160; #include <locale>         16 &#160;        17 &#160; namespace  boost {        18 &#160; namespace  nowide {        19 &#160;        20 &#160;    static_assert( sizeof (std::mbstate_t) >= 2,  &quot;mbstate_t is to small to store an UTF-16 codepoint&quot; );        21 &#160;     namespace  detail {        22 &#160;         // Avoid including cstring for std::memcpy         23 &#160;         inline   void  copy_uint16_t( void * dst,  const   void * src)        24 &#160;        {        25 &#160;             unsigned   char * cdst = static_cast<unsigned char*>(dst);        26 &#160;             const   unsigned   char * csrc = static_cast<const unsigned char*>(src);        27 &#160;            cdst[0] = csrc[0];        28 &#160;            cdst[1] = csrc[1];        29 &#160;        }        30 &#160;         inline  std::uint16_t read_state( const  std::mbstate_t& src)        31 &#160;        {        32 &#160;            std::uint16_t dst;        33 &#160;            copy_uint16_t(&dst, &src);        34 &#160;             return  dst;        35 &#160;        }        36 &#160;         inline   void  write_state(std::mbstate_t& dst,  const  std::uint16_t src)        37 &#160;        {        38 &#160;            copy_uint16_t(&dst, &src);        39 &#160;        }        40 &#160;    }  // namespace detail         41 &#160;        48 &#160;     template < typename  CharType,  int  CharSize = sizeof(CharType)>         49  &#160;     class   utf8_codecvt ;        50 &#160;        51 &#160;    BOOST_NOWIDE_SUPPRESS_UTF_CODECVT_DEPRECATION_BEGIN        53 &#160;     template < typename  CharType>         54  &#160;     class  BOOST_SYMBOL_VISIBLE  utf8_codecvt <CharType, 2> :  public  std::codecvt<CharType, char, std::mbstate_t>        55 &#160;    {        56 &#160;     public :        57 &#160;        static_assert( sizeof (CharType) >= 2,  &quot;CharType must be able to store UTF16 code point&quot; );        58 &#160;        59 &#160;         utf8_codecvt ( size_t  refs = 0) : std::codecvt<CharType, char, std::mbstate_t>(refs)        60 &#160;        {}        61 &#160;        BOOST_NOWIDE_SUPPRESS_UTF_CODECVT_DEPRECATION_END        62 &#160;        63 &#160;     protected :        64 &#160;         using  uchar = CharType;        65 &#160;        66 &#160;        std::codecvt_base::result do_unshift(std::mbstate_t& s,  char * from,  char *  /*to*/ ,  char *& next)  const override         67 &#160;          {        68 &#160;             if (detail::read_state(s) != 0)        69 &#160;                 return  std::codecvt_base::error;        70 &#160;            next = from;        71 &#160;             return  std::codecvt_base::ok;        72 &#160;        }        73 &#160;         int  do_encoding()  const  noexcept  override         74 &#160;        {        75 &#160;             return  0;        76 &#160;        }        77 &#160;         int  do_max_length()  const  noexcept  override         78 &#160;        {        79 &#160;             return  4;        80 &#160;        }        81 &#160;         bool  do_always_noconv()  const  noexcept  override         82 &#160;        {        83 &#160;             return   false ;        84 &#160;        }        85 &#160;        86 &#160;         // LCOV_EXCL_START         87 &#160;         int  do_length(std::mbstate_t& std_state,  const   char * from,  const   char * from_end,  size_t  max)  const override         88 &#160;          {        89 &#160;             // LCOV_EXCL_STOP         90 &#160;             using  utf16_traits =  utf::utf_traits<uchar, 2> ;        91 &#160;            std::uint16_t state = detail::read_state(std_state);        92 &#160;             const   char * save_from = from;        93 &#160;             if (state && max > 0)        94 &#160;            {        95 &#160;                max--;        96 &#160;                state = 0;        97 &#160;            }        98 &#160;             while (max > 0 && from < from_end)        99 &#160;            {       100 &#160;                 const   char * prev_from = from;       101 &#160;                std::uint32_t ch =  utf::utf_traits<char>::decode (from, from_end);       102 &#160;                 if (ch ==  utf::illegal )       103 &#160;                {       104 &#160;                    ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       105 &#160;                }  else   if (ch ==  utf::incomplete )       106 &#160;                {       107 &#160;                    from = prev_from;       108 &#160;                     break ;       109 &#160;                }       110 &#160;                 // If we can&#39;t write the char, we have to save the low surrogate in state        111 &#160;                 if (BOOST_LIKELY(static_cast<size_t>(utf16_traits::width(ch)) <= max))       112 &#160;                {       113 &#160;                    max -= utf16_traits::width(ch);       114 &#160;                }  else        115 &#160;                {       116 &#160;                    static_assert(utf16_traits::max_width == 2,  &quot;Required for below&quot; );       117 &#160;                    std::uint16_t tmpOut[2]{};       118 &#160;                    utf16_traits::encode(ch, tmpOut);       119 &#160;                    state = tmpOut[1];       120 &#160;                     break ;       121 &#160;                }       122 &#160;            }       123 &#160;            detail::write_state(std_state, state);       124 &#160;             return  static_cast<int>(from - save_from);       125 &#160;        }       126 &#160;       127 &#160;        std::codecvt_base::result do_in(std::mbstate_t& std_state,  // LCOV_EXCL_LINE        128 &#160;                                         const   char * from,       129 &#160;                                         const   char * from_end,       130 &#160;                                         const   char *& from_next,       131 &#160;                                        uchar* to,       132 &#160;                                        uchar* to_end,       133 &#160;                                        uchar*& to_next)  const override        134 &#160;          {       135 &#160;            std::codecvt_base::result r = std::codecvt_base::ok;       136 &#160;             using  utf16_traits =  utf::utf_traits<uchar, 2> ;       137 &#160;       138 &#160;             // mbstate_t is POD type and should be initialized to 0 (i.e. state = stateT())        139 &#160;             // according to standard.        140 &#160;             // We use it to store a low surrogate if it was not yet written, else state is 0        141 &#160;            std::uint16_t state = detail::read_state(std_state);       142 &#160;             // Write low surrogate if present        143 &#160;             if (state && to < to_end)       144 &#160;            {       145 &#160;                *to++ = static_cast<CharType>(state);       146 &#160;                state = 0;       147 &#160;            }       148 &#160;             while (to < to_end && from < from_end)       149 &#160;            {       150 &#160;                 const   char * from_saved = from;       151 &#160;       152 &#160;                uint32_t ch =  utf::utf_traits<char>::decode (from, from_end);       153 &#160;       154 &#160;                 if (ch ==  utf::illegal )       155 &#160;                {       156 &#160;                    ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       157 &#160;                }  else   if (ch ==  utf::incomplete )       158 &#160;                {       159 &#160;                    from = from_saved;       160 &#160;                    r = std::codecvt_base::partial;       161 &#160;                     break ;       162 &#160;                }       163 &#160;                 // If the encoded char fits, write directly, else safe the low surrogate in state        164 &#160;                 if (BOOST_LIKELY(utf16_traits::width(ch) <= to_end - to))       165 &#160;                {       166 &#160;                    to = utf16_traits::encode(ch, to);       167 &#160;                }  else        168 &#160;                {       169 &#160;                    static_assert(utf16_traits::max_width == 2,  &quot;Required for below&quot; );       170 &#160;                    std::uint16_t tmpOut[2]{};       171 &#160;                    utf16_traits::encode(ch, tmpOut);       172 &#160;                    *to++ = static_cast<CharType>(tmpOut[0]);       173 &#160;                    state = tmpOut[1];       174 &#160;                     break ;       175 &#160;                }       176 &#160;            }       177 &#160;            from_next = from;       178 &#160;            to_next = to;       179 &#160;             if (r == std::codecvt_base::ok && (from != from_end || state != 0))       180 &#160;                r = std::codecvt_base::partial;       181 &#160;            detail::write_state(std_state, state);       182 &#160;             return  r;       183 &#160;        }       184 &#160;       185 &#160;        std::codecvt_base::result do_out(std::mbstate_t& std_state,       186 &#160;                                          const  uchar* from,       187 &#160;                                          const  uchar* from_end,       188 &#160;                                          const  uchar*& from_next,       189 &#160;                                          char * to,       190 &#160;                                          char * to_end,       191 &#160;                                          char *& to_next)  const override        192 &#160;          {       193 &#160;            std::codecvt_base::result r = std::codecvt_base::ok;       194 &#160;             using  utf16_traits =  utf::utf_traits<uchar, 2> ;       195 &#160;             // mbstate_t is POD type and should be initialized to 0        196 &#160;             // (i.e. state = stateT()) according to standard.        197 &#160;             // We use it to store the first observed surrogate pair, or 0 if there is none yet        198 &#160;            std::uint16_t state = detail::read_state(std_state);       199 &#160;             for (; to < to_end && from < from_end; ++from)       200 &#160;            {       201 &#160;                std::uint32_t ch = 0;       202 &#160;                 if (state != 0)       203 &#160;                {       204 &#160;                     // We have a high surrogate, so now there should be a low surrogate        205 &#160;                    std::uint16_t w1 = state;       206 &#160;                    std::uint16_t w2 = *from;       207 &#160;                     if (BOOST_LIKELY(utf16_traits::is_trail(w2)))       208 &#160;                    {       209 &#160;                        ch = utf16_traits::combine_surrogate(w1, w2);       210 &#160;                    }  else        211 &#160;                    {       212 &#160;                        ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       213 &#160;                    }       214 &#160;                }  else        215 &#160;                {       216 &#160;                    std::uint16_t w1 = *from;       217 &#160;                     if (BOOST_LIKELY(utf16_traits::is_single_codepoint(w1)))       218 &#160;                    {       219 &#160;                        ch = w1;       220 &#160;                    }  else   if (BOOST_LIKELY(utf16_traits::is_first_surrogate(w1)))       221 &#160;                    {       222 &#160;                         // Store into state and continue at next character        223 &#160;                        state = w1;       224 &#160;                         continue ;       225 &#160;                    }  else        226 &#160;                    {       227 &#160;                         // Neither a single codepoint nor a high surrogate so must be low surrogate.        228 &#160;                         // This is an error -> Replace character        229 &#160;                        ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       230 &#160;                    }       231 &#160;                }       232 &#160;                assert( utf::is_valid_codepoint (ch));  // Any valid UTF16 sequence is a valid codepoint        233 &#160;                 int  len =  utf::utf_traits<char>::width (ch);       234 &#160;                 if (to_end - to < len)       235 &#160;                {       236 &#160;                    r = std::codecvt_base::partial;       237 &#160;                     break ;       238 &#160;                }       239 &#160;                to =  utf::utf_traits<char>::encode (ch, to);       240 &#160;                state = 0;       241 &#160;            }       242 &#160;            from_next = from;       243 &#160;            to_next = to;       244 &#160;             if (r == std::codecvt_base::ok && (from != from_end || state != 0))       245 &#160;                r = std::codecvt_base::partial;       246 &#160;            detail::write_state(std_state, state);       247 &#160;             return  r;       248 &#160;        }       249 &#160;    };       250 &#160;       251 &#160;    BOOST_NOWIDE_SUPPRESS_UTF_CODECVT_DEPRECATION_BEGIN       253 &#160;     template < typename  CharType>        254  &#160;     class  BOOST_SYMBOL_VISIBLE  utf8_codecvt <CharType, 4> :  public  std::codecvt<CharType, char, std::mbstate_t>       255 &#160;    {       256 &#160;     public :       257 &#160;         utf8_codecvt ( size_t  refs = 0) : std::codecvt<CharType, char, std::mbstate_t>(refs)       258 &#160;        {}       259 &#160;        BOOST_NOWIDE_SUPPRESS_UTF_CODECVT_DEPRECATION_END       260 &#160;       261 &#160;     protected :       262 &#160;         using  uchar = CharType;       263 &#160;       264 &#160;        std::codecvt_base::result       265 &#160;        do_unshift(std::mbstate_t&  /*s*/ ,  char * from,  char *  /*to*/ ,  char *& next)  const override        266 &#160;          {       267 &#160;            next = from;       268 &#160;             return  std::codecvt_base::noconv;       269 &#160;        }       270 &#160;         int  do_encoding()  const  noexcept  override        271 &#160;        {       272 &#160;             return  0;       273 &#160;        }       274 &#160;         int  do_max_length()  const  noexcept  override        275 &#160;        {       276 &#160;             return  4;       277 &#160;        }       278 &#160;         bool  do_always_noconv()  const  noexcept  override        279 &#160;        {       280 &#160;             return   false ;       281 &#160;        }       282 &#160;       283 &#160;         int  do_length(std::mbstate_t&  /*state*/ ,  const   char * from,  const   char * from_end,  size_t  max)  const override        284 &#160;          {       285 &#160;             const   char * start_from = from;       286 &#160;       287 &#160;             while (max > 0 && from < from_end)       288 &#160;            {       289 &#160;                 const   char * save_from = from;       290 &#160;                std::uint32_t ch =  utf::utf_traits<char>::decode (from, from_end);       291 &#160;                 if (ch ==  utf::incomplete )       292 &#160;                {       293 &#160;                    from = save_from;       294 &#160;                     break ;       295 &#160;                }  else   if (ch ==  utf::illegal )       296 &#160;                {       297 &#160;                    ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       298 &#160;                }       299 &#160;                max--;       300 &#160;            }       301 &#160;             return  static_cast<int>(from - start_from);       302 &#160;        }       303 &#160;       304 &#160;        std::codecvt_base::result do_in(std::mbstate_t&  /*state*/ ,       305 &#160;                                         const   char * from,       306 &#160;                                         const   char * from_end,       307 &#160;                                         const   char *& from_next,       308 &#160;                                        uchar* to,       309 &#160;                                        uchar* to_end,       310 &#160;                                        uchar*& to_next)  const override        311 &#160;          {       312 &#160;            std::codecvt_base::result r = std::codecvt_base::ok;       313 &#160;       314 &#160;             while (to < to_end && from < from_end)       315 &#160;            {       316 &#160;                 const   char * from_saved = from;       317 &#160;       318 &#160;                uint32_t ch =  utf::utf_traits<char>::decode (from, from_end);       319 &#160;       320 &#160;                 if (ch ==  utf::illegal )       321 &#160;                {       322 &#160;                    ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       323 &#160;                }  else   if (ch ==  utf::incomplete )       324 &#160;                {       325 &#160;                    r = std::codecvt_base::partial;       326 &#160;                    from = from_saved;       327 &#160;                     break ;       328 &#160;                }       329 &#160;                *to++ = ch;       330 &#160;            }       331 &#160;            from_next = from;       332 &#160;            to_next = to;       333 &#160;             if (r == std::codecvt_base::ok && from != from_end)       334 &#160;                r = std::codecvt_base::partial;       335 &#160;             return  r;       336 &#160;        }       337 &#160;       338 &#160;        std::codecvt_base::result do_out(std::mbstate_t&  /*std_state*/ ,       339 &#160;                                          const  uchar* from,       340 &#160;                                          const  uchar* from_end,       341 &#160;                                          const  uchar*& from_next,       342 &#160;                                          char * to,       343 &#160;                                          char * to_end,       344 &#160;                                          char *& to_next)  const override        345 &#160;          {       346 &#160;            std::codecvt_base::result r = std::codecvt_base::ok;       347 &#160;             while (to < to_end && from < from_end)       348 &#160;            {       349 &#160;                std::uint32_t ch = 0;       350 &#160;                ch = *from;       351 &#160;                 if (! utf::is_valid_codepoint (ch))       352 &#160;                {       353 &#160;                    ch =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;       354 &#160;                }       355 &#160;                 int  len =  utf::utf_traits<char>::width (ch);       356 &#160;                 if (to_end - to < len)       357 &#160;                {       358 &#160;                    r = std::codecvt_base::partial;       359 &#160;                     break ;       360 &#160;                }       361 &#160;                to =  utf::utf_traits<char>::encode (ch, to);       362 &#160;                from++;       363 &#160;            }       364 &#160;            from_next = from;       365 &#160;            to_next = to;       366 &#160;             if (r == std::codecvt_base::ok && from != from_end)       367 &#160;                r = std::codecvt_base::partial;       368 &#160;             return  r;       369 &#160;        }       370 &#160;    };       371 &#160;       372 &#160;}  // namespace nowide        373 &#160;}  // namespace boost        374 &#160;       375 &#160; #endif     boost::nowide::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:56     boost::nowide::utf::utf_traits::encode   static Iterator encode(code_point value, Iterator out)     boost::nowide::utf8_codecvt    Definition:  utf8_codecvt.hpp:49     boost::nowide::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:32     BOOST_NOWIDE_REPLACEMENT_CHARACTER   #define BOOST_NOWIDE_REPLACEMENT_CHARACTER   Definition:  replacement.hpp:15     replacement.hpp      boost::nowide::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:37     boost::nowide::utf::utf_traits::width   static int width(code_point value)     boost::nowide::utf::is_valid_codepoint   bool is_valid_codepoint(code_point v)  the function checks if v is a valid code point   Definition:  utf.hpp:42     boost::nowide::utf::utf_traits::decode   static code_point decode(Iterator &p, Iterator e)          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             iostream.hpp                1 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          2 &#160; // Copyright (c) 2020-2021 Alexander Grund          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_IOSTREAM_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_IOSTREAM_HPP_INCLUDED          9 &#160;        10 &#160; #include < boost/nowide/config.hpp >         11 &#160; #ifdef BOOST_WINDOWS         12 &#160; #include <istream>         13 &#160; #include <memory>         14 &#160; #include <ostream>         15 &#160;        16 &#160; #include <boost/config/abi_prefix.hpp>   // must be the last #include         17 &#160; #else         18 &#160; #include <iostream>         19 &#160; #endif         20 &#160;        21 &#160; #ifdef BOOST_MSVC         22 &#160; #pragma warning(push)         23 &#160; #pragma warning(disable : 4251)         24 &#160; #endif         25 &#160;        26 &#160; namespace  boost {        27 &#160; namespace  nowide {        28 &#160; #if !defined(BOOST_WINDOWS) && !defined(BOOST_NOWIDE_DOXYGEN)         29 &#160;     using  std::cout;        30 &#160;     using  std::cerr;        31 &#160;     using  std::cin;        32 &#160;     using  std::clog;        33 &#160; #else         34 &#160;        36 &#160;     namespace  detail {        37 &#160;         class  console_output_buffer;        38 &#160;         class  console_input_buffer;        39 &#160;        40 &#160;         class  BOOST_NOWIDE_DECL winconsole_ostream :  public  std::ostream        41 &#160;        {        42 &#160;         public :        43 &#160;            winconsole_ostream( bool  isBuffered, winconsole_ostream* tieStream);        44 &#160;            ~winconsole_ostream();        45 &#160;        46 &#160;         private :        47 &#160;            std::unique_ptr<console_output_buffer> d;        48 &#160;             // Ensure the std streams are initialized and alive during the lifetime of this instance         49 &#160;            std::ios_base::Init init_;        50 &#160;        };        51 &#160;        52 &#160;         class  BOOST_NOWIDE_DECL winconsole_istream :  public  std::istream        53 &#160;        {        54 &#160;         public :        55 &#160;             explicit  winconsole_istream(winconsole_ostream* tieStream);        56 &#160;            ~winconsole_istream();        57 &#160;        58 &#160;         private :        59 &#160;            std::unique_ptr<console_input_buffer> d;        60 &#160;             // Ensure the std streams are initialized and alive during the lifetime of this instance         61 &#160;            std::ios_base::Init init_;        62 &#160;        };        63 &#160;    }  // namespace detail         64 &#160;        66 &#160;        72 &#160;     extern  BOOST_NOWIDE_DECL detail::winconsole_istream  cin ;        78 &#160;     extern  BOOST_NOWIDE_DECL detail::winconsole_ostream  cout ;        84 &#160;     extern  BOOST_NOWIDE_DECL detail::winconsole_ostream  cerr ;        90 &#160;     extern  BOOST_NOWIDE_DECL detail::winconsole_ostream  clog ;        91 &#160;        92 &#160; #endif         93 &#160;        94 &#160;}  // namespace nowide         95 &#160;}  // namespace boost         96 &#160;        97 &#160; #ifdef BOOST_MSVC         98 &#160; #pragma warning(pop)         99 &#160; #endif        100 &#160;       101 &#160; #ifdef BOOST_WINDOWS        102 &#160; #include <boost/config/abi_suffix.hpp>   // pops abi_prefix.hpp pragmas        103 &#160; #endif        104 &#160;       105 &#160; #endif     boost::nowide::cin   detail::winconsole_istream cin  Same as std::cin, but uses UTF-8.     boost::nowide::cout   detail::winconsole_ostream cout  Same as std::cout, but uses UTF-8.     config.hpp      boost::nowide::cerr   detail::winconsole_ostream cerr  Same as std::cerr, but uses UTF-8.     boost::nowide::clog   detail::winconsole_ostream clog  Same as std::clog, but uses UTF-8.          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide    utf             convert.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; // Copyright (c) 2020 Alexander Grund          4 &#160; //          5 &#160; // Distributed under the Boost Software License, Version 1.0.          6 &#160; // https://www.boost.org/LICENSE_1_0.txt          7 &#160;         8 &#160; #ifndef BOOST_NOWIDE_UTF_CONVERT_HPP_INCLUDED          9 &#160; #define BOOST_NOWIDE_UTF_CONVERT_HPP_INCLUDED         10 &#160;        11 &#160; #include <boost/nowide/detail/is_string_container.hpp>         12 &#160; #include < boost/nowide/replacement.hpp >         13 &#160; #include <boost/nowide/utf/utf.hpp>         14 &#160; #include <iterator>         15 &#160; #include <string>         16 &#160;        17 &#160; namespace  boost {        18 &#160; namespace  nowide {         19  &#160;     namespace   utf  {        20 &#160;        24 &#160;         template < typename  Char>         25  &#160;         size_t   strlen ( const  Char* s)        26 &#160;        {        27 &#160;             const  Char* end = s;        28 &#160;             while (*end)        29 &#160;                end++;        30 &#160;             return  end - s;        31 &#160;        }        32 &#160;        40 &#160;         template < typename  CharOut,  typename  CharIn>        41 &#160;        CharOut*         42  &#160;         convert_buffer (CharOut* buffer,  size_t  buffer_size,  const  CharIn* source_begin,  const  CharIn* source_end)        43 &#160;        {        44 &#160;            CharOut* rv = buffer;        45 &#160;             if (buffer_size == 0)        46 &#160;                 return   nullptr ;        47 &#160;            buffer_size--;        48 &#160;             while (source_begin != source_end)        49 &#160;            {        50 &#160;                 code_point  c =  utf_traits<CharIn>::decode (source_begin, source_end);        51 &#160;                 if (c ==  illegal  || c ==  incomplete )        52 &#160;                {        53 &#160;                    c =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;        54 &#160;                }        55 &#160;                 size_t  width =  utf_traits<CharOut>::width (c);        56 &#160;                 if (buffer_size < width)        57 &#160;                {        58 &#160;                    rv =  nullptr ;        59 &#160;                     break ;        60 &#160;                }        61 &#160;                buffer =  utf_traits<CharOut>::encode (c, buffer);        62 &#160;                buffer_size -= width;        63 &#160;            }        64 &#160;            *buffer++ = 0;        65 &#160;             return  rv;        66 &#160;        }        67 &#160;        73 &#160;         template < typename  CharOut,  typename  CharIn>         74  &#160;        std::basic_string<CharOut>  convert_string ( const  CharIn* begin,  const  CharIn* end)        75 &#160;        {        76 &#160;            std::basic_string<CharOut> result;        77 &#160;            result.reserve(end - begin);        78 &#160;             using  inserter_type = std::back_insert_iterator<std::basic_string<CharOut>>;        79 &#160;            inserter_type inserter(result);        80 &#160;             code_point  c;        81 &#160;             while (begin != end)        82 &#160;            {        83 &#160;                c =  utf_traits<CharIn>::decode (begin, end);        84 &#160;                 if (c ==  illegal  || c ==  incomplete )        85 &#160;                {        86 &#160;                    c =  BOOST_NOWIDE_REPLACEMENT_CHARACTER ;        87 &#160;                }        88 &#160;                 utf_traits<CharOut>::encode (c, inserter);        89 &#160;            }        90 &#160;             return  result;        91 &#160;        }        92 &#160;        93 &#160;    }  // namespace utf         94 &#160;}  // namespace nowide         95 &#160;}  // namespace boost         96 &#160;        97 &#160; #endif     boost::nowide::utf::convert_string   std::basic_string< CharOut > convert_string(const CharIn *begin, const CharIn *end)   Definition:  convert.hpp:74     boost::nowide::utf   Namespace that holds basic operations on UTF encoded sequences.   Definition:  convert.hpp:19     boost::nowide::utf::utf_traits::encode   static Iterator encode(code_point value, Iterator out)     boost::nowide::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:32     boost::nowide::utf::code_point   uint32_t code_point  The integral type that can hold a Unicode code point.   Definition:  utf.hpp:27     boost::nowide::utf::strlen   size_t strlen(const Char *s)   Definition:  convert.hpp:25     BOOST_NOWIDE_REPLACEMENT_CHARACTER   #define BOOST_NOWIDE_REPLACEMENT_CHARACTER   Definition:  replacement.hpp:15     replacement.hpp      boost::nowide::utf::convert_buffer   CharOut * convert_buffer(CharOut *buffer, size_t buffer_size, const CharIn *source_begin, const CharIn *source_end)   Definition:  convert.hpp:42     boost::nowide::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:37     boost::nowide::utf::utf_traits::width   static int width(code_point value)     boost::nowide::utf::utf_traits::decode   static code_point decode(Iterator &p, Iterator e)          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             cstdlib.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_CSTDLIB_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_CSTDLIB_HPP_INCLUDED          9 &#160;        10 &#160; #include < boost/nowide/config.hpp >         11 &#160; #if !defined(BOOST_WINDOWS)         12 &#160; #include <cstdlib>         13 &#160; #endif         14 &#160;        15 &#160; namespace  boost {        16 &#160; namespace  nowide {        17 &#160; #if !defined(BOOST_WINDOWS) && !defined(BOOST_NOWIDE_DOXYGEN)         18 &#160;     using  std::getenv;        19 &#160;     using  std::system;        20 &#160; #else         21 &#160;    BOOST_NOWIDE_DECL  char *  getenv ( const   char * key);        27 &#160;        31 &#160;    BOOST_NOWIDE_DECL  int   system ( const   char * cmd);        32 &#160;        33 &#160; #endif         34 &#160;    BOOST_NOWIDE_DECL  int   setenv ( const   char * key,  const   char * value,  int  overwrite);        44 &#160;        51 &#160;    BOOST_NOWIDE_DECL  int   unsetenv ( const   char * key);        52 &#160;        61 &#160;    BOOST_NOWIDE_DECL  int   putenv ( char *  string );        62 &#160;        63 &#160;}  // namespace nowide         64 &#160;}  // namespace boost         65 &#160;        66 &#160; #endif     boost::nowide::setenv   int setenv(const char *key, const char *value, int overwrite)  Set environment variable key to value.   Definition:  cstdlib.cpp:28     boost::nowide::putenv   int putenv(char *string)  Adds or changes an environment variable, string must be in format KEY=VALUE.   Definition:  cstdlib.cpp:38     config.hpp      boost::nowide::getenv   char * getenv(const char *key)  UTF-8 aware getenv. Returns 0 if the variable is not set.     boost::nowide::system   int system(const char *cmd)     boost::nowide::unsetenv   int unsetenv(const char *key)  Remove environment variable key.   Definition:  cstdlib.cpp:33          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('format_8hpp_source.html','');});/* @license-end */       format.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_FORMAT_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_FORMAT_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/locale/formatting.hpp>         12 &#160; #include <boost/locale/hold_ptr.hpp>         13 &#160; #include <boost/locale/message.hpp>         14 &#160; #include <sstream>         15 &#160; #include <vector>         16 &#160;        17 &#160; #ifdef BOOST_MSVC         18 &#160; #  pragma warning(push)         19 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         20 &#160; #endif         21 &#160;        22 &#160; namespace  boost {        23 &#160;     namespace  locale {        24 &#160;        32 &#160;        34 &#160;         namespace  details {        35 &#160;        36 &#160;             template < typename  CharType>        37 &#160;             struct  formattible {        38 &#160;                 typedef  std::basic_ostream<CharType> stream_type;        39 &#160;                 typedef  void (*writer_type)(stream_type &output, void   const  *ptr);        40 &#160;        41 &#160;                formattible() :        42 &#160;                    pointer_(0),        43 &#160;                    writer_(&formattible::void_write)        44 &#160;                {        45 &#160;                }        46 &#160;        47 &#160;                formattible(formattible  const  &other) :        48 &#160;                    pointer_(other.pointer_),        49 &#160;                    writer_(other.writer_)        50 &#160;                {        51 &#160;                }        52 &#160;        53 &#160;                formattible  const  &operator=(formattible  const  &other)        54 &#160;                {        55 &#160;                     if ( this  != &other) {        56 &#160;                        pointer_=other.pointer_;        57 &#160;                        writer_=other.writer_;        58 &#160;                    }        59 &#160;                     return  * this ;        60 &#160;                }        61 &#160;        62 &#160;                 template < typename  Type>        63 &#160;                formattible(Type  const  &value)        64 &#160;                {        65 &#160;                    pointer_ = static_cast<void const *>(&value);        66 &#160;                    writer_ = &write<Type>;        67 &#160;                }        68 &#160;        69 &#160;                 template < typename  Type>        70 &#160;                formattible  const  &operator=(Type  const  &other)        71 &#160;                {        72 &#160;                    * this  = formattible(other);        73 &#160;                     return  * this ;        74 &#160;                }        75 &#160;        76 &#160;                 friend  stream_type & operator<< (stream_type &out,formattible  const  &fmt)        77 &#160;                {        78 &#160;                    fmt.writer_(out,fmt.pointer_);        79 &#160;                     return  out;        80 &#160;                }        81 &#160;        82 &#160;             private :        83 &#160;                 static   void  void_write(stream_type &output, void   const  *  /*ptr*/ )        84 &#160;                {        85 &#160;                    CharType empty_string[1]={0};        86 &#160;                    output << empty_string;        87 &#160;                }        88 &#160;        89 &#160;                 template < typename  Type>        90 &#160;                 static   void  write(stream_type &output, void   const  *ptr)        91 &#160;                {        92 &#160;                    output << *static_cast<Type const *>(ptr);        93 &#160;                }        94 &#160;        95 &#160;                 void   const  *pointer_;        96 &#160;                writer_type writer_;        97 &#160;            };  // formattible         98 &#160;        99 &#160;             class  BOOST_LOCALE_DECL format_parser  {       100 &#160;             public :       101 &#160;                format_parser(std::ios_base &ios, void  *, void  (*imbuer)( void  *,std::locale  const  &));       102 &#160;                ~format_parser();       103 &#160;       104 &#160;                 unsigned  get_position();       105 &#160;       106 &#160;                 void  set_one_flag(std::string  const  &key,std::string  const  &value);       107 &#160;       108 &#160;                 template < typename  CharType>       109 &#160;                 void  set_flag_with_str(std::string  const  &key,std::basic_string<CharType>  const  &value)       110 &#160;                {       111 &#160;                     if (key== &quot;ftime&quot;  || key== &quot;strftime&quot; ) {       112 &#160;                         as::strftime (ios_);       113 &#160;                         ios_info::get (ios_). date_time_pattern (value);       114 &#160;                    }       115 &#160;                }       116 &#160;                 void  restore();       117 &#160;             private :       118 &#160;                 void  imbue(std::locale  const  &);       119 &#160;                format_parser(format_parser  const  &);       120 &#160;                 void  operator=(format_parser  const  &);       121 &#160;       122 &#160;                std::ios_base &ios_;       123 &#160;                 struct  data;       124 &#160;                hold_ptr<data> d;       125 &#160;            };       126 &#160;       127 &#160;        }       128 &#160;       130 &#160;       203 &#160;         template < typename  CharType>        204  &#160;         class   basic_format  {       205 &#160;         public :        206  &#160;             typedef  CharType  char_type ;         207  &#160;             typedef   basic_message<char_type>   message_type ;        208 &#160;             typedef  details::formattible<CharType> formattible_type;       211 &#160;        212  &#160;             typedef  std::basic_string<CharType>  string_type ;         213  &#160;             typedef  std::basic_ostream<CharType>  stream_type ;        214 &#160;       215 &#160;        219  &#160;             basic_format ( string_type  format_string) :       220 &#160;                format_(format_string),       221 &#160;                translate_(false),       222 &#160;                parameters_count_(0)       223 &#160;            {       224 &#160;            }        229  &#160;             basic_format ( message_type   const  &trans) :       230 &#160;                message_(trans),       231 &#160;                translate_(true),       232 &#160;                parameters_count_(0)       233 &#160;            {       234 &#160;            }       235 &#160;       240 &#160;             template < typename  Formattible>        241  &#160;             basic_format  & operator %  (Formattible  const  & object )       242 &#160;            {       243 &#160;                add(formattible_type( object ));       244 &#160;                 return  * this ;       245 &#160;            }       246 &#160;        250  &#160;             string_type   str (std::locale  const  &loc = std::locale())  const        251 &#160;              {       252 &#160;                std::basic_ostringstream<CharType> buffer;       253 &#160;                buffer.imbue(loc);       254 &#160;                 write (buffer);       255 &#160;                 return  buffer.str();       256 &#160;            }       257 &#160;        261  &#160;             void   write ( stream_type  &out)  const        262 &#160;              {       263 &#160;                 string_type   format ;       264 &#160;                 if (translate_)       265 &#160;                     format  = message_. str (out.getloc(), ios_info::get (out). domain_id ());       266 &#160;                 else        267 &#160;                     format  = format_;       268 &#160;       269 &#160;                format_output(out, format );       270 &#160;       271 &#160;            }       272 &#160;       273 &#160;       274 &#160;         private :       275 &#160;       276 &#160;             class  format_guard {       277 &#160;             public :       278 &#160;                format_guard(details::format_parser &fmt) :       279 &#160;                    fmt_(&fmt),       280 &#160;                    restored_(false)       281 &#160;                {       282 &#160;                }       283 &#160;                 void  restore()       284 &#160;                {       285 &#160;                     if (restored_)       286 &#160;                         return ;       287 &#160;                    fmt_->restore();       288 &#160;                    restored_ =  true ;       289 &#160;                }       290 &#160;                ~format_guard()       291 &#160;                {       292 &#160;                     try  {       293 &#160;                        restore();       294 &#160;                    }       295 &#160;                     catch (...) {       296 &#160;                    }       297 &#160;                }       298 &#160;             private :       299 &#160;                details::format_parser *fmt_;       300 &#160;                 bool  restored_;       301 &#160;            };       302 &#160;       303 &#160;             void  format_output( stream_type  &out, string_type   const  &sformat)  const        304 &#160;              {       305 &#160;                 char_type  obrk= &#39;{&#39; ;       306 &#160;                 char_type  cbrk= &#39;}&#39; ;       307 &#160;                 char_type  eq= &#39;=&#39; ;       308 &#160;                 char_type  comma= &#39;,&#39; ;       309 &#160;                 char_type  quote= &#39;\&#39;&#39; ;       310 &#160;       311 &#160;                 size_t  pos = 0;       312 &#160;                 size_t  size=sformat.size();       313 &#160;                CharType  const  * format =sformat.c_str();       314 &#160;                 while ( format [pos]!=0) {       315 &#160;                     if ( format [pos] != obrk) {       316 &#160;                         if ( format [pos]==cbrk &&  format [pos+1]==cbrk) {       317 &#160;                            out << cbrk;       318 &#160;                            pos+=2;       319 &#160;                        }       320 &#160;                         else  {       321 &#160;                            out <<  format [pos];       322 &#160;                            pos++;       323 &#160;                        }       324 &#160;                         continue ;       325 &#160;                    }       326 &#160;       327 &#160;                     if (pos+1 < size &&  format [pos+1]==obrk) {       328 &#160;                        out << obrk;       329 &#160;                        pos+=2;       330 &#160;                         continue ;       331 &#160;                    }       332 &#160;                    pos++;       333 &#160;       334 &#160;                    details::format_parser fmt(out,static_cast<void *>(&out),&basic_format::imbue_locale);       335 &#160;       336 &#160;                    format_guard guard(fmt);       337 &#160;       338 &#160;                     while (pos < size) {       339 &#160;                        std::string key;       340 &#160;                        std::string svalue;       341 &#160;                         string_type  value;       342 &#160;                         bool  use_svalue =  true ;       343 &#160;                         for (; format [pos];pos++) {       344 &#160;                             char_type  c= format [pos];       345 &#160;                             if (c==comma || c==eq || c==cbrk)       346 &#160;                                 break ;       347 &#160;                             else  {       348 &#160;                                key+=static_cast<char>(c);       349 &#160;                            }       350 &#160;                        }       351 &#160;       352 &#160;                         if ( format [pos]==eq) {       353 &#160;                            pos++;       354 &#160;                             if ( format [pos]==quote) {       355 &#160;                                pos++;       356 &#160;                                use_svalue =  false ;       357 &#160;                                 while ( format [pos]) {       358 &#160;                                     if ( format [pos]==quote) {       359 &#160;                                         if ( format [pos+1]==quote) {       360 &#160;                                            value+=quote;       361 &#160;                                            pos+=2;       362 &#160;                                        }       363 &#160;                                         else  {       364 &#160;                                            pos++;       365 &#160;                                             break ;       366 &#160;                                        }       367 &#160;                                    }       368 &#160;                                     else  {       369 &#160;                                        value+= format [pos];       370 &#160;                                        pos++;       371 &#160;                                    }       372 &#160;                                }       373 &#160;                            }       374 &#160;                             else  {       375 &#160;                                 char_type  c;       376 &#160;                                 while ((c= format [pos])!=0 && c!=comma && c!=cbrk) {       377 &#160;                                    svalue+=static_cast<char>(c);       378 &#160;                                    pos++;       379 &#160;                                }       380 &#160;                            }       381 &#160;                        }       382 &#160;       383 &#160;                         if (use_svalue) {       384 &#160;                            fmt.set_one_flag(key,svalue);       385 &#160;                        }       386 &#160;                         else        387 &#160;                            fmt.set_flag_with_str(key,value);       388 &#160;       389 &#160;                         if ( format [pos]==comma) {       390 &#160;                            pos++;       391 &#160;                             continue ;       392 &#160;                        }       393 &#160;                         else   if ( format [pos]==cbrk)  {       394 &#160;                             unsigned  position = fmt.get_position();       395 &#160;                            out << get(position);       396 &#160;                            guard.restore();       397 &#160;                            pos++;       398 &#160;                             break ;       399 &#160;                        }       400 &#160;                         else  {       401 &#160;                            guard.restore();       402 &#160;                             break ;       403 &#160;                        }       404 &#160;                    }       405 &#160;                }       406 &#160;            }       407 &#160;       408 &#160;       409 &#160;             //        410 &#160;             // Non-copyable        411 &#160;             //        412 &#160;             basic_format ( basic_format   const  &other);       413 &#160;             void  operator=( basic_format   const  &other);       414 &#160;       415 &#160;             void  add(formattible_type  const  &param)       416 &#160;            {       417 &#160;                 if (parameters_count_ >= base_params_)       418 &#160;                    ext_params_.push_back(param);       419 &#160;                 else        420 &#160;                    parameters_[parameters_count_] = param;       421 &#160;                parameters_count_++;       422 &#160;            }       423 &#160;       424 &#160;            formattible_type get( unsigned   id )  const        425 &#160;              {       426 &#160;                 if ( id  >= parameters_count_)       427 &#160;                     return  formattible_type();       428 &#160;                 else   if ( id  >= base_params_)       429 &#160;                     return  ext_params_[ id  - base_params_];       430 &#160;                 else        431 &#160;                     return  parameters_[id];       432 &#160;            }       433 &#160;       434 &#160;             static   void  imbue_locale( void  *ptr,std::locale  const  &l)       435 &#160;            {       436 &#160;                reinterpret_cast<stream_type *>(ptr)->imbue(l);       437 &#160;            }       438 &#160;       439 &#160;       440 &#160;       441 &#160;             static   unsigned   const  base_params_ = 8;       442 &#160;       443 &#160;             message_type  message_;       444 &#160;             string_type  format_;       445 &#160;             bool  translate_;       446 &#160;       447 &#160;       448 &#160;            formattible_type parameters_[base_params_];       449 &#160;             unsigned  parameters_count_;       450 &#160;            std::vector<formattible_type> ext_params_;       451 &#160;        };       452 &#160;       458 &#160;         template < typename  CharType>        459  &#160;        std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out, basic_format<CharType>   const  &fmt)       460 &#160;        {       461 &#160;            fmt. write (out);       462 &#160;             return  out;       463 &#160;        }       464 &#160;       465 &#160;        469  &#160;         typedef   basic_format<char>   format ;       470 &#160;        474  &#160;         typedef   basic_format<wchar_t>   wformat ;       475 &#160;       476 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        477 &#160;         typedef   basic_format<char16_t>   u16format ;       481 &#160;         #endif        482 &#160;       483 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        484 &#160;         typedef   basic_format<char32_t>   u32format ;       488 &#160;         #endif        489 &#160;       493 &#160;       494 &#160;    }       495 &#160;}       496 &#160;       497 &#160; #ifdef BOOST_MSVC        498 &#160; #pragma warning(pop)        499 &#160; #endif        500 &#160;       501 &#160; #endif        502 &#160;       513 &#160;       514 &#160;    boost::locale::u32format   basic_format< char32_t > u32format   Definition:  format.hpp:487     boost::locale::basic_format   a printf like class that allows type-safe and locale aware message formatting   Definition:  format.hpp:204     boost::locale::basic_format::string_type   std::basic_string< CharType > string_type  string type for this type of character   Definition:  format.hpp:212     boost::locale::as::strftime   std::ios_base & strftime(std::ios_base &ios)   Definition:  formatting.hpp:347     boost::locale::basic_format::basic_format   basic_format(message_type const &trans)   Definition:  format.hpp:229     boost::locale::basic_message< char_type >      boost::locale::basic_message::str   string_type str() const   Definition:  message.hpp:352     boost::locale::basic_format::basic_format   basic_format(string_type format_string)   Definition:  format.hpp:219     boost::locale::ios_info::get   static ios_info & get(std::ios_base &ios)     boost::locale::basic_format::stream_type   std::basic_ostream< CharType > stream_type  output stream type for this type of character   Definition:  format.hpp:213     boost::locale::ios_info::domain_id   void domain_id(int)     boost::locale::basic_format::str   string_type str(std::locale const &loc=std::locale()) const   Definition:  format.hpp:250     boost::locale::basic_format::write   void write(stream_type &out) const   Definition:  format.hpp:261     boost::locale::operator<<   std::basic_ostream< CharType > & operator<<(std::basic_ostream< CharType > &out, date_time const &t)   Definition:  date_time.hpp:871     boost::locale::basic_format::char_type   CharType char_type  Underlying character type.   Definition:  format.hpp:206     boost::locale::wformat   basic_format< wchar_t > wformat   Definition:  format.hpp:474     boost::locale::basic_format::operator %   basic_format & operator %(Formattible const &object)   Definition:  format.hpp:241     boost::locale::u16format   basic_format< char16_t > u16format   Definition:  format.hpp:480     boost::locale::format   basic_format< char > format   Definition:  format.hpp:469     boost::locale::basic_format::message_type   basic_message< char_type > message_type   Definition:  format.hpp:207     boost::locale::ios_info::date_time_pattern   void date_time_pattern(std::basic_string< CharType > const &str)   Definition:  formatting.hpp:155             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide    detail             convert.hpp                1 &#160; //          2 &#160; // Copyright (c) 2020 Alexander Grund          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_DETAIL_CONVERT_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_DETAIL_CONVERT_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/nowide/utf/convert.hpp>         11 &#160;        12 &#160; // Legacy compatibility header only. Include <boost/nowide/utf/convert.hpp> instead         13 &#160;        14 &#160; namespace  boost {        15 &#160; namespace  nowide {        16 &#160;     namespace  detail {        17 &#160;         using   boost::nowide::utf::convert_buffer ;        18 &#160;         using   boost::nowide::utf::convert_string ;        19 &#160;         using   boost::nowide::utf::strlen ;        20 &#160;    }  // namespace detail         21 &#160;}  // namespace nowide         22 &#160;}  // namespace boost         23 &#160;        24 &#160; #endif     boost::nowide::utf::convert_string   std::basic_string< CharOut > convert_string(const CharIn *begin, const CharIn *end)   Definition:  convert.hpp:74     boost::nowide::utf::strlen   size_t strlen(const Char *s)   Definition:  convert.hpp:25     boost::nowide::utf::convert_buffer   CharOut * convert_buffer(CharOut *buffer, size_t buffer_size, const CharIn *source_begin, const CharIn *source_end)   Definition:  convert.hpp:42          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide    utf             utf.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; // Copyright (c) 2020 Alexander Grund          4 &#160; //          5 &#160; // Distributed under the Boost Software License, Version 1.0.          6 &#160; // https://www.boost.org/LICENSE_1_0.txt          7 &#160;         8 &#160; #ifndef BOOST_NOWIDE_UTF_HPP_INCLUDED          9 &#160; #define BOOST_NOWIDE_UTF_HPP_INCLUDED         10 &#160;        11 &#160; #include < boost/nowide/config.hpp >         12 &#160; #include <cstdint>         13 &#160;        14 &#160; namespace  boost {        15 &#160; namespace  nowide {        22 &#160;     namespace   utf  {        23 &#160;         27  &#160;         using   code_point  = uint32_t;        28 &#160;         32  &#160;         static   const   code_point   illegal  = 0xFFFFFFFFu;        33 &#160;         37  &#160;         static   const   code_point   incomplete  = 0xFFFFFFFEu;        38 &#160;         42  &#160;         inline   bool   is_valid_codepoint ( code_point  v)        43 &#160;        {        44 &#160;             if (v > 0x10FFFF)        45 &#160;                 return   false ;        46 &#160;             if (0xD800 <= v && v <= 0xDFFF)  // surrogates         47 &#160;                 return   false ;        48 &#160;             return   true ;        49 &#160;        }        50 &#160;        51 &#160; #ifdef BOOST_NOWIDE_DOXYGEN         52 &#160;         template < typename  CharType,  int  size = sizeof(CharType)>         56  &#160;         struct   utf_traits         57 &#160;        {         61  &#160;             using   char_type  = CharType;        76 &#160;             template < typename  Iterator>        77 &#160;             static   code_point   decode (Iterator& p, Iterator e);        78 &#160;         86  &#160;             static   const   int   max_width ;        93 &#160;             static   int   width ( code_point  value);        94 &#160;       100 &#160;             static   int   trail_length ( char_type  c);       104 &#160;             static   bool   is_trail ( char_type  c);       108 &#160;             static   bool   is_lead ( char_type  c);       109 &#160;       120 &#160;             template < typename  Iterator>       121 &#160;             static  Iterator  encode ( code_point  value, Iterator out);       127 &#160;             template < typename  Iterator>       128 &#160;             static   code_point   decode_valid (Iterator& p);       129 &#160;        };       130 &#160;       131 &#160; #else        132 &#160;       133 &#160;         template < typename  CharType,  int  size = sizeof(CharType)>       134 &#160;         struct   utf_traits ;       135 &#160;       136 &#160;         template < typename  CharType>       137 &#160;         struct   utf_traits <CharType, 1>       138 &#160;        {       139 &#160;             using   char_type  = CharType;       140 &#160;       141 &#160;             static   int   trail_length ( char_type  ci)       142 &#160;            {       143 &#160;                 unsigned   char  c = ci;       144 &#160;                 if (c < 128)       145 &#160;                     return  0;       146 &#160;                 if (BOOST_UNLIKELY(c < 194))       147 &#160;                     return  -1;       148 &#160;                 if (c < 224)       149 &#160;                     return  1;       150 &#160;                 if (c < 240)       151 &#160;                     return  2;       152 &#160;                 if (BOOST_LIKELY(c <= 244))       153 &#160;                     return  3;       154 &#160;                 return  -1;       155 &#160;            }       156 &#160;       157 &#160;             static   const   int   max_width  = 4;       158 &#160;       159 &#160;             static   int   width ( code_point  value)       160 &#160;            {       161 &#160;                 if (value <= 0x7F)       162 &#160;                {       163 &#160;                     return  1;       164 &#160;                }  else   if (value <= 0x7FF)       165 &#160;                {       166 &#160;                     return  2;       167 &#160;                }  else   if (BOOST_LIKELY(value <= 0xFFFF))       168 &#160;                {       169 &#160;                     return  3;       170 &#160;                }  else        171 &#160;                {       172 &#160;                     return  4;       173 &#160;                }       174 &#160;            }       175 &#160;       176 &#160;             static   bool   is_trail ( char_type  ci)       177 &#160;            {       178 &#160;                 unsigned   char  c = ci;       179 &#160;                 return  (c & 0xC0) == 0x80;       180 &#160;            }       181 &#160;       182 &#160;             static   bool   is_lead ( char_type  ci)       183 &#160;            {       184 &#160;                 return  ! is_trail (ci);       185 &#160;            }       186 &#160;       187 &#160;             template < typename  Iterator>       188 &#160;             static   code_point   decode (Iterator& p, Iterator e)       189 &#160;            {       190 &#160;                 if (BOOST_UNLIKELY(p == e))       191 &#160;                     return   incomplete ;       192 &#160;       193 &#160;                 unsigned   char  lead = *p++;       194 &#160;       195 &#160;                 // First byte is fully validated here        196 &#160;                 int  trail_size =  trail_length (lead);       197 &#160;       198 &#160;                 if (BOOST_UNLIKELY(trail_size < 0))       199 &#160;                     return   illegal ;       200 &#160;       201 &#160;                 // OK as only ASCII may be of size = 0        202 &#160;                 // also optimize for ASCII text        203 &#160;                 if (trail_size == 0)       204 &#160;                     return  lead;       205 &#160;       206 &#160;                 code_point  c = lead & ((1 << (6 - trail_size)) - 1);       207 &#160;       208 &#160;                 // Read the rest        209 &#160;                 unsigned   char  tmp;       210 &#160;                 switch (trail_size)       211 &#160;                {       212 &#160;                 case  3:       213 &#160;                     if (BOOST_UNLIKELY(p == e))       214 &#160;                         return   incomplete ;       215 &#160;                    tmp = *p++;       216 &#160;                     if (! is_trail (tmp))       217 &#160;                         return   illegal ;       218 &#160;                    c = (c << 6) | (tmp & 0x3F);       219 &#160;                    BOOST_NOWIDE_FALLTHROUGH;       220 &#160;                 case  2:       221 &#160;                     if (BOOST_UNLIKELY(p == e))       222 &#160;                         return   incomplete ;       223 &#160;                    tmp = *p++;       224 &#160;                     if (! is_trail (tmp))       225 &#160;                         return   illegal ;       226 &#160;                    c = (c << 6) | (tmp & 0x3F);       227 &#160;                    BOOST_NOWIDE_FALLTHROUGH;       228 &#160;                 case  1:       229 &#160;                     if (BOOST_UNLIKELY(p == e))       230 &#160;                         return   incomplete ;       231 &#160;                    tmp = *p++;       232 &#160;                     if (! is_trail (tmp))       233 &#160;                         return   illegal ;       234 &#160;                    c = (c << 6) | (tmp & 0x3F);       235 &#160;                }       236 &#160;       237 &#160;                 // Check code point validity:        238 &#160;                 // - no surrogates and valid range        239 &#160;                 // - most compact representation        240 &#160;                 if (BOOST_UNLIKELY(! is_valid_codepoint (c)) || BOOST_UNLIKELY( width (c) != trail_size + 1))       241 &#160;                {       242 &#160;                    p -= trail_size;       243 &#160;                     return   illegal ;       244 &#160;                }       245 &#160;       246 &#160;                 return  c;       247 &#160;            }       248 &#160;       249 &#160;             template < typename  Iterator>       250 &#160;             static   code_point   decode_valid (Iterator& p)       251 &#160;            {       252 &#160;                 unsigned   char  lead = *p++;       253 &#160;                 if (lead < 192)       254 &#160;                     return  lead;       255 &#160;       256 &#160;                 int  trail_size;       257 &#160;       258 &#160;                 if (lead < 224)       259 &#160;                    trail_size = 1;       260 &#160;                 else   if (BOOST_LIKELY(lead < 240))  // non-BMP rare        261 &#160;                    trail_size = 2;       262 &#160;                 else        263 &#160;                    trail_size = 3;       264 &#160;       265 &#160;                 code_point  c = lead & ((1 << (6 - trail_size)) - 1);       266 &#160;       267 &#160;                 switch (trail_size)       268 &#160;                {       269 &#160;                 case  3: c = (c << 6) | (static_cast<unsigned char>(*p++) & 0x3F); BOOST_NOWIDE_FALLTHROUGH;       270 &#160;                 case  2: c = (c << 6) | (static_cast<unsigned char>(*p++) & 0x3F); BOOST_NOWIDE_FALLTHROUGH;       271 &#160;                 case  1: c = (c << 6) | (static_cast<unsigned char>(*p++) & 0x3F);       272 &#160;                }       273 &#160;       274 &#160;                 return  c;       275 &#160;            }       276 &#160;       277 &#160;             template < typename  Iterator>       278 &#160;             static  Iterator  encode ( code_point  value, Iterator out)       279 &#160;            {       280 &#160;                 if (value <= 0x7F)       281 &#160;                {       282 &#160;                    *out++ = static_cast<char_type>(value);       283 &#160;                }  else   if (value <= 0x7FF)       284 &#160;                {       285 &#160;                    *out++ = static_cast<char_type>((value >> 6) | 0xC0);       286 &#160;                    *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       287 &#160;                }  else   if (BOOST_LIKELY(value <= 0xFFFF))       288 &#160;                {       289 &#160;                    *out++ = static_cast<char_type>((value >> 12) | 0xE0);       290 &#160;                    *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);       291 &#160;                    *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       292 &#160;                }  else        293 &#160;                {       294 &#160;                    *out++ = static_cast<char_type>((value >> 18) | 0xF0);       295 &#160;                    *out++ = static_cast<char_type>(((value >> 12) & 0x3F) | 0x80);       296 &#160;                    *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);       297 &#160;                    *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       298 &#160;                }       299 &#160;                 return  out;       300 &#160;            }       301 &#160;        };  // utf8        302 &#160;       303 &#160;         template < typename  CharType>       304 &#160;         struct  utf_traits<CharType, 2>       305 &#160;        {       306 &#160;             using   char_type  = CharType;       307 &#160;       308 &#160;             // See RFC 2781        309 &#160;             static   bool  is_single_codepoint(uint16_t x)       310 &#160;            {       311 &#160;                 // Ranges [U+0000, 0+D7FF], [U+E000, U+FFFF] are numerically equal in UTF-16        312 &#160;                 return  x <= 0xD7FF || x >= 0xE000;       313 &#160;            }       314 &#160;             static   bool  is_first_surrogate(uint16_t x)       315 &#160;            {       316 &#160;                 // Range [U+D800, 0+DBFF]: High surrogate        317 &#160;                 return  0xD800 <= x && x <= 0xDBFF;       318 &#160;            }       319 &#160;             static   bool  is_second_surrogate(uint16_t x)       320 &#160;            {       321 &#160;                 // Range [U+DC00, 0+DFFF]: Low surrogate        322 &#160;                 return  0xDC00 <= x && x <= 0xDFFF;       323 &#160;            }       324 &#160;             static   code_point  combine_surrogate(uint16_t w1, uint16_t w2)       325 &#160;            {       326 &#160;                 return  (( code_point (w1 & 0x3FF) << 10) | (w2 & 0x3FF)) + 0x10000;       327 &#160;            }       328 &#160;             static   int   trail_length ( char_type  c)       329 &#160;            {       330 &#160;                 if (is_first_surrogate(c))       331 &#160;                     return  1;       332 &#160;                 if (is_second_surrogate(c))       333 &#160;                     return  -1;       334 &#160;                 return  0;       335 &#160;            }       337 &#160;             static   bool   is_trail ( char_type  c)       338 &#160;            {       339 &#160;                 return  is_second_surrogate(c);       340 &#160;            }       342 &#160;             static   bool   is_lead ( char_type  c)       343 &#160;            {       344 &#160;                 return  !is_second_surrogate(c);       345 &#160;            }       346 &#160;       347 &#160;             template < typename  It>       348 &#160;             static   code_point   decode (It& current, It last)       349 &#160;            {       350 &#160;                 if (BOOST_UNLIKELY(current == last))       351 &#160;                     return   incomplete ;       352 &#160;                uint16_t w1 = *current++;       353 &#160;                 if (BOOST_LIKELY(is_single_codepoint(w1)))       354 &#160;                {       355 &#160;                     return  w1;       356 &#160;                }       357 &#160;                 // Now it&#39;s either a high or a low surrogate, the latter is invalid        358 &#160;                 if (w1 >= 0xDC00)       359 &#160;                     return   illegal ;       360 &#160;                 if (current == last)       361 &#160;                     return   incomplete ;       362 &#160;                uint16_t w2 = *current++;       363 &#160;                 if (!is_second_surrogate(w2))       364 &#160;                     return   illegal ;       365 &#160;                 return  combine_surrogate(w1, w2);       366 &#160;            }       367 &#160;             template < typename  It>       368 &#160;             static   code_point   decode_valid (It& current)       369 &#160;            {       370 &#160;                uint16_t w1 = *current++;       371 &#160;                 if (BOOST_LIKELY(is_single_codepoint(w1)))       372 &#160;                {       373 &#160;                     return  w1;       374 &#160;                }       375 &#160;                uint16_t w2 = *current++;       376 &#160;                 return  combine_surrogate(w1, w2);       377 &#160;            }       378 &#160;       379 &#160;             static   const   int   max_width  = 2;       380 &#160;             static   int   width ( code_point  u)  // LCOV_EXCL_LINE        381 &#160;            {       382 &#160;                 return  u >= 0x10000 ? 2 : 1;       383 &#160;            }       384 &#160;             template < typename  It>       385 &#160;             static  It  encode ( code_point  u, It out)       386 &#160;            {       387 &#160;                 if (BOOST_LIKELY(u <= 0xFFFF))       388 &#160;                {       389 &#160;                    *out++ = static_cast<char_type>(u);       390 &#160;                }  else        391 &#160;                {       392 &#160;                    u -= 0x10000;       393 &#160;                    *out++ = static_cast<char_type>(0xD800 | (u >> 10));       394 &#160;                    *out++ = static_cast<char_type>(0xDC00 | (u & 0x3FF));       395 &#160;                }       396 &#160;                 return  out;       397 &#160;            }       398 &#160;        };  // utf16;        399 &#160;       400 &#160;         template < typename  CharType>       401 &#160;         struct  utf_traits<CharType, 4>       402 &#160;        {       403 &#160;             using   char_type  = CharType;       404 &#160;             static   int   trail_length ( char_type  c)       405 &#160;            {       406 &#160;                 if ( is_valid_codepoint (c))       407 &#160;                     return  0;       408 &#160;                 return  -1;       409 &#160;            }       410 &#160;             static   bool   is_trail ( char_type   /*c*/ )       411 &#160;            {       412 &#160;                 return   false ;       413 &#160;            }       414 &#160;             static   bool   is_lead ( char_type   /*c*/ )       415 &#160;            {       416 &#160;                 return   true ;       417 &#160;            }       418 &#160;       419 &#160;             template < typename  It>       420 &#160;             static   code_point   decode_valid (It& current)       421 &#160;            {       422 &#160;                 return  *current++;       423 &#160;            }       424 &#160;       425 &#160;             template < typename  It>       426 &#160;             static   code_point   decode (It& current, It last)       427 &#160;            {       428 &#160;                 if (BOOST_UNLIKELY(current == last))       429 &#160;                     return   incomplete ;       430 &#160;                 code_point  c = *current++;       431 &#160;                 if (BOOST_UNLIKELY(! is_valid_codepoint (c)))       432 &#160;                     return   illegal ;       433 &#160;                 return  c;       434 &#160;            }       435 &#160;             static   const   int   max_width  = 1;       436 &#160;             static   int   width ( code_point   /*u*/ )       437 &#160;            {       438 &#160;                 return  1;       439 &#160;            }       440 &#160;             template < typename  It>       441 &#160;             static  It  encode ( code_point  u, It out)       442 &#160;            {       443 &#160;                *out++ = static_cast<char_type>(u);       444 &#160;                 return  out;       445 &#160;            }       446 &#160;        };  // utf32        447 &#160;       448 &#160; #endif        449 &#160;       450 &#160;    }  // namespace utf        451 &#160;}  // namespace nowide        452 &#160;}  // namespace boost        453 &#160;       454 &#160; #endif     boost::nowide::utf::utf_traits::max_width   static const int max_width   Definition:  utf.hpp:86     boost::nowide::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:56     boost::nowide::utf::utf_traits::is_trail   static bool is_trail(char_type c)     boost::nowide::utf   Namespace that holds basic operations on UTF encoded sequences.   Definition:  convert.hpp:19     boost::nowide::utf::utf_traits::encode   static Iterator encode(code_point value, Iterator out)     config.hpp      boost::nowide::utf::utf_traits::is_lead   static bool is_lead(char_type c)     boost::nowide::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:32     boost::nowide::utf::code_point   uint32_t code_point  The integral type that can hold a Unicode code point.   Definition:  utf.hpp:27     boost::nowide::utf::utf_traits::char_type   CharType char_type   Definition:  utf.hpp:61     boost::nowide::utf::utf_traits::decode_valid   static code_point decode_valid(Iterator &p)     boost::nowide::utf::utf_traits::trail_length   static int trail_length(char_type c)     boost::nowide::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:37     boost::nowide::utf::utf_traits::width   static int width(code_point value)     boost::nowide::utf::is_valid_codepoint   bool is_valid_codepoint(code_point v)  the function checks if v is a valid code point   Definition:  utf.hpp:42     boost::nowide::utf::utf_traits::decode   static code_point decode(Iterator &p, Iterator e)          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             stackstring.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_STACKSTRING_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_STACKSTRING_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/nowide/convert.hpp>         11 &#160; #include <boost/nowide/utf/utf.hpp>         12 &#160; #include <cassert>         13 &#160; #include <cstring>         14 &#160;        15 &#160; namespace  boost {        16 &#160; namespace  nowide {        17 &#160;        30 &#160;     template < typename  CharOut =  wchar_t ,  typename  CharIn =  char ,  size_t  BufferSize = 256>         31  &#160;     class   basic_stackstring         32 &#160;    {        33 &#160;     public :         35  &#160;         static   const   size_t   buffer_size  = BufferSize;         37  &#160;         using   output_char  = CharOut;         39  &#160;         using   input_char  = CharIn;        40 &#160;         42  &#160;         basic_stackstring ()        43 &#160;        {        44 &#160;            buffer_[0] = 0;        45 &#160;        }         48  &#160;         explicit   basic_stackstring ( const   input_char * input)        49 &#160;        {        50 &#160;             convert (input);        51 &#160;        }         54  &#160;         basic_stackstring ( const   input_char * begin,  const   input_char * end)        55 &#160;        {        56 &#160;             convert (begin, end);        57 &#160;        }         59  &#160;         basic_stackstring ( const   basic_stackstring & other)        60 &#160;        {        61 &#160;            * this  = other;        62 &#160;        }         64  &#160;         basic_stackstring &  operator= ( const   basic_stackstring & other)        65 &#160;        {        66 &#160;             if ( this  != &other)        67 &#160;            {        68 &#160;                 clear ();        69 &#160;                 const   size_t  len = other. length ();        70 &#160;                 if (other. uses_stack_memory ())        71 &#160;                    data_ = buffer_;        72 &#160;                 else   if (other.data_)        73 &#160;                    data_ =  new   output_char [len + 1];        74 &#160;                 else         75 &#160;                {        76 &#160;                    data_ =  nullptr ;        77 &#160;                     return  * this ;        78 &#160;                }        79 &#160;                std::memcpy(data_, other.data_,  sizeof ( output_char ) * (len + 1));        80 &#160;            }        81 &#160;             return  * this ;        82 &#160;        }        83 &#160;        84 &#160;        ~ basic_stackstring ()        85 &#160;        {        86 &#160;             clear ();        87 &#160;        }        88 &#160;         91  &#160;         output_char *  convert ( const   input_char * input)        92 &#160;        {        93 &#160;             if (input)        94 &#160;                 return   convert (input, input +  utf::strlen (input));        95 &#160;             clear ();        96 &#160;             return   get ();        97 &#160;        }        100  &#160;         output_char *  convert ( const   input_char * begin,  const   input_char * end)       101 &#160;        {       102 &#160;             clear ();       103 &#160;       104 &#160;             if (begin)       105 &#160;            {       106 &#160;                 const   size_t  input_len = end - begin;       107 &#160;                 // Minimum size required: 1 output char per input char + trailing NULL        108 &#160;                 const   size_t  min_output_size = input_len + 1;       109 &#160;                 // If there is a chance the converted string fits on stack, try it        110 &#160;                 if (min_output_size <=  buffer_size  &&  utf::convert_buffer (buffer_,  buffer_size , begin, end))       111 &#160;                    data_ = buffer_;       112 &#160;                 else        113 &#160;                {       114 &#160;                     // Fallback: Allocate a buffer that is surely large enough on heap        115 &#160;                     // Max size: Every input char is transcoded to the output char with maximum with + trailing NULL        116 &#160;                     const   size_t  max_output_size = input_len *  utf::utf_traits<output_char>::max_width  + 1;       117 &#160;                    data_ =  new   output_char [max_output_size];       118 &#160;                     const   bool  success =  utf::convert_buffer (data_, max_output_size, begin, end) == data_;       119 &#160;                    assert(success);       120 &#160;                    (void)success;       121 &#160;                }       122 &#160;            }       123 &#160;             return   get ();       124 &#160;        }        126  &#160;         output_char *  get ()       127 &#160;        {       128 &#160;             return  data_;       129 &#160;        }        131  &#160;         const   output_char *  get ()  const        132 &#160;          {       133 &#160;             return  data_;       134 &#160;        }        136  &#160;         void   clear ()       137 &#160;        {       138 &#160;             if (! uses_stack_memory ())       139 &#160;                 delete [] data_;       140 &#160;            data_ =  nullptr ;       141 &#160;        }        143  &#160;         friend   void   swap ( basic_stackstring & lhs,  basic_stackstring & rhs)       144 &#160;        {       145 &#160;             if (lhs. uses_stack_memory ())       146 &#160;            {       147 &#160;                 if (rhs. uses_stack_memory ())       148 &#160;                {       149 &#160;                     for ( size_t  i = 0; i <  buffer_size ; i++)       150 &#160;                        std::swap(lhs.buffer_[i], rhs.buffer_[i]);       151 &#160;                }  else        152 &#160;                {       153 &#160;                    lhs.data_ = rhs.data_;       154 &#160;                    rhs.data_ = rhs.buffer_;       155 &#160;                     for ( size_t  i = 0; i <  buffer_size ; i++)       156 &#160;                        rhs.buffer_[i] = lhs.buffer_[i];       157 &#160;                }       158 &#160;            }  else   if (rhs. uses_stack_memory ())       159 &#160;            {       160 &#160;                rhs.data_ = lhs.data_;       161 &#160;                lhs.data_ = lhs.buffer_;       162 &#160;                 for ( size_t  i = 0; i <  buffer_size ; i++)       163 &#160;                    lhs.buffer_[i] = rhs.buffer_[i];       164 &#160;            }  else        165 &#160;                std::swap(lhs.data_, rhs.data_);       166 &#160;        }       167 &#160;       168 &#160;     protected :        170  &#160;         bool   uses_stack_memory ()  const        171 &#160;          {       172 &#160;             return  data_ == buffer_;       173 &#160;        }        176  &#160;         size_t   length ()  const        177 &#160;          {       178 &#160;             if (!data_)       179 &#160;                 return  0;       180 &#160;             size_t  len = 0;       181 &#160;             while (data_[len])       182 &#160;                len++;       183 &#160;             return  len;       184 &#160;        }       185 &#160;       186 &#160;     private :       187 &#160;         output_char  buffer_[ buffer_size ];       188 &#160;         output_char * data_ =  nullptr ;       189 &#160;    };  // basic_stackstring        190 &#160;        194  &#160;     using   wstackstring  =  basic_stackstring<wchar_t, char, 256> ;        198  &#160;     using   stackstring  =  basic_stackstring<char, wchar_t, 256> ;        202  &#160;     using   wshort_stackstring  =  basic_stackstring<wchar_t, char, 16> ;        206  &#160;     using   short_stackstring  =  basic_stackstring<char, wchar_t, 16> ;       207 &#160;       208 &#160;}  // namespace nowide        209 &#160;}  // namespace boost        210 &#160;       211 &#160; #endif     boost::nowide::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:56     boost::nowide::basic_stackstring::output_char   CharOut output_char  Type of the output character (converted to)   Definition:  stackstring.hpp:37     boost::nowide::basic_stackstring::basic_stackstring   basic_stackstring(const input_char *input)   Definition:  stackstring.hpp:48     boost::nowide::basic_stackstring::uses_stack_memory   bool uses_stack_memory() const  True if the stack memory is used.   Definition:  stackstring.hpp:170     boost::nowide::basic_stackstring::basic_stackstring   basic_stackstring(const basic_stackstring &other)  Copy construct from other.   Definition:  stackstring.hpp:59     boost::nowide::basic_stackstring< char, wchar_t, 256 >::input_char   wchar_t input_char  Type of the input character (converted from)   Definition:  stackstring.hpp:39     boost::nowide::basic_stackstring::operator=   basic_stackstring & operator=(const basic_stackstring &other)  Copy assign from other.   Definition:  stackstring.hpp:64     boost::nowide::basic_stackstring::buffer_size   static const size_t buffer_size  Size of the stack buffer.   Definition:  stackstring.hpp:35     boost::nowide::basic_stackstring::clear   void clear()  Reset the internal buffer to NULL.   Definition:  stackstring.hpp:136     boost::nowide::basic_stackstring::basic_stackstring   basic_stackstring(const input_char *begin, const input_char *end)   Definition:  stackstring.hpp:54     boost::nowide::utf::strlen   size_t strlen(const Char *s)   Definition:  convert.hpp:25     boost::nowide::basic_stackstring::convert   output_char * convert(const input_char *begin, const input_char *end)   Definition:  stackstring.hpp:100     boost::nowide::basic_stackstring::get   const output_char * get() const  Return the converted, NULL-terminated string or NULL if no string was converted.   Definition:  stackstring.hpp:131     boost::nowide::basic_stackstring::length   size_t length() const   Definition:  stackstring.hpp:176     boost::nowide::utf::convert_buffer   CharOut * convert_buffer(CharOut *buffer, size_t buffer_size, const CharIn *source_begin, const CharIn *source_end)   Definition:  convert.hpp:42     boost::nowide::basic_stackstring::convert   output_char * convert(const input_char *input)   Definition:  stackstring.hpp:91     boost::nowide::basic_stackstring   A class that allows to create a temporary wide or narrow UTF strings from wide or narrow UTF source.   Definition:  stackstring.hpp:31     boost::nowide::basic_stackstring::basic_stackstring   basic_stackstring()  Creates a NULL stackstring.   Definition:  stackstring.hpp:42     boost::nowide::basic_stackstring::get   output_char * get()  Return the converted, NULL-terminated string or NULL if no string was converted.   Definition:  stackstring.hpp:126     boost::nowide::basic_stackstring::swap   friend void swap(basic_stackstring &lhs, basic_stackstring &rhs)  Swap lhs with rhs.   Definition:  stackstring.hpp:143          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             windows.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; // Copyright (c) 2022 Alexander Grund          4 &#160; //          5 &#160; // Distributed under the Boost Software License, Version 1.0.          6 &#160; // https://www.boost.org/LICENSE_1_0.txt          7 &#160;         8 &#160; #ifndef BOOST_NOWIDE_WINDOWS_HPP_INCLUDED          9 &#160; #define BOOST_NOWIDE_WINDOWS_HPP_INCLUDED         10 &#160;        11 &#160; #ifdef BOOST_USE_WINDOWS_H         12 &#160; #include <windows.h>         13 &#160; // (Usually) included by windows.h         14 &#160; #include <shellapi.h>         15 &#160; #else         16 &#160;        17 &#160; // When BOOST_USE_WINDOWS_H is not defined we declare the function prototypes to avoid including windows.h         18 &#160;        19 &#160; extern   &quot;C&quot;  {        20 &#160;        21 &#160; // From windows.h         22 &#160;        23 &#160;__declspec(dllimport)  wchar_t * __stdcall GetEnvironmentStringsW( void );        24 &#160;__declspec(dllimport)  int  __stdcall FreeEnvironmentStringsW( wchar_t *);        25 &#160;__declspec(dllimport)  wchar_t * __stdcall GetCommandLineW( void );        26 &#160;__declspec(dllimport)  unsigned   long  __stdcall GetLastError();        27 &#160;__declspec(dllimport)  void * __stdcall LocalFree( void *);        28 &#160;__declspec(dllimport)  int  __stdcall SetEnvironmentVariableW( const   wchar_t *,  const   wchar_t *);        29 &#160;__declspec(dllimport)  unsigned   long  __stdcall GetEnvironmentVariableW( const   wchar_t *,  wchar_t *,  unsigned   long );        30 &#160;        31 &#160; // From shellapi.h         32 &#160;        33 &#160;__declspec(dllimport)  wchar_t ** __stdcall CommandLineToArgvW( const   wchar_t *,  int *);        34 &#160;}        35 &#160;        36 &#160; #endif         37 &#160;        38 &#160; #endif          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         src             console_buffer.hpp                1 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          2 &#160; // Copyright (c) 2020 - 2021 Alexander Grund          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_DETAIL_CONSOLE_BUFFER_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_DETAIL_CONSOLE_BUFFER_HPP_INCLUDED          9 &#160;        10 &#160; #include < boost/nowide/config.hpp >         11 &#160; #include <boost/nowide/utf/utf.hpp>         12 &#160; #include <streambuf>         13 &#160; #include <vector>         14 &#160;        15 &#160; #include <boost/config/abi_prefix.hpp>   // must be the last #include         16 &#160;        17 &#160; // Internal header, not meant to be used outside of the implementation         18 &#160; namespace  boost {        19 &#160; namespace  nowide {        20 &#160;     namespace  detail {        21 &#160;        23 &#160;         class  BOOST_NOWIDE_DECL console_output_buffer_base :  public  std::streambuf        24 &#160;        {        25 &#160;         protected :        26 &#160;             int  sync()  override ;        27 &#160;             int  overflow( int  c)  override ;        28 &#160;        29 &#160;         private :        30 &#160;             using  decoder =  utf::utf_traits<char> ;        31 &#160;             using  encoder =  utf::utf_traits<wchar_t> ;        32 &#160;        33 &#160;             int  write( const   char * p,  int  n);        34 &#160;             virtual   bool         35 &#160;            do_write( const   wchar_t * buffer, std::size_t num_chars_to_write, std::size_t& num_chars_written) = 0;        36 &#160;        37 &#160;             static  constexpr  int  buffer_size = 1024;        38 &#160;             static  constexpr  int  wbuffer_size = buffer_size * encoder::max_width;        39 &#160;             char  buffer_[buffer_size];        40 &#160;             wchar_t  wbuffer_[wbuffer_size];        41 &#160;        };        42 &#160;        43 &#160; #ifdef BOOST_MSVC         44 &#160; #pragma warning(push)         45 &#160; #pragma warning(disable : 4251)         46 &#160; #endif         47 &#160;        48 &#160;         class  BOOST_NOWIDE_DECL console_input_buffer_base :  public  std::streambuf        49 &#160;        {        50 &#160;         protected :        51 &#160;             int  sync()  override ;        52 &#160;             int  pbackfail( int  c)  override ;        53 &#160;             int  underflow()  override ;        54 &#160;        55 &#160;         private :        56 &#160;             using  decoder =  utf::utf_traits<wchar_t> ;        57 &#160;             using  encoder =  utf::utf_traits<char> ;        58 &#160;        59 &#160;             size_t  read();        60 &#160;             virtual   bool  do_read( wchar_t * buffer, std::size_t num_chars_to_read, std::size_t& num_chars_read) = 0;        61 &#160;        62 &#160;             static  constexpr  size_t  wbuffer_size = 1024;        63 &#160;             static  constexpr  size_t  buffer_size = wbuffer_size * encoder::max_width;        64 &#160;             char  buffer_[buffer_size];        65 &#160;             wchar_t  wbuffer_[wbuffer_size];        66 &#160;             size_t  wsize_ = 0;        67 &#160;            std::vector<char> pback_buffer_;        68 &#160;             bool  was_newline_ =  true ;        69 &#160;        };        70 &#160;        71 &#160; #ifdef BOOST_MSVC         72 &#160; #pragma warning(pop)         73 &#160; #endif         74 &#160;        76 &#160;        77 &#160;    }  // namespace detail         78 &#160;}  // namespace nowide         79 &#160;}  // namespace boost         80 &#160;        81 &#160; #include <boost/config/abi_suffix.hpp>   // pops abi_prefix.hpp pragmas         82 &#160;        83 &#160; #endif     boost::nowide::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:56     config.hpp           Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             args.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_ARGS_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_ARGS_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/config.hpp>         11 &#160; #ifdef BOOST_WINDOWS         12 &#160; #include <boost/nowide/stackstring.hpp>         13 &#160; #include <boost/nowide/windows.hpp>         14 &#160; #include <stdexcept>         15 &#160; #include <vector>         16 &#160; #endif         17 &#160;        18 &#160; namespace  boost {         19  &#160; namespace  nowide {        20 &#160; #if !defined(BOOST_WINDOWS) && !defined(BOOST_NOWIDE_DOXYGEN)         21 &#160;     class   args         22 &#160;    {        23 &#160;     public :        24 &#160;         args ( int &,  char **&)        25 &#160;        {}        26 &#160;         args ( int &,  char **&,  char **&)        27 &#160;        {}        28 &#160;    };        29 &#160;        30 &#160; #else         31 &#160;         56  &#160;     class   args         57 &#160;    {        58 &#160;     public :         62  &#160;         args ( int & argc,  char **& argv) :        63 &#160;            old_argc_(argc), old_argv_(argv), old_env_(0), old_argc_ptr_(&argc), old_argv_ptr_(&argv), old_env_ptr_(0)        64 &#160;        {        65 &#160;            fix_args(argc, argv);        66 &#160;        }         70  &#160;         args ( int & argc,  char **& argv,  char **& env) :        71 &#160;            old_argc_(argc), old_argv_(argv), old_env_(env), old_argc_ptr_(&argc), old_argv_ptr_(&argv),        72 &#160;            old_env_ptr_(&env)        73 &#160;        {        74 &#160;            fix_args(argc, argv);        75 &#160;            fix_env(env);        76 &#160;        }         80  &#160;         ~args ()        81 &#160;        {        82 &#160;             if (old_argc_ptr_)        83 &#160;                *old_argc_ptr_ = old_argc_;        84 &#160;             if (old_argv_ptr_)        85 &#160;                *old_argv_ptr_ = old_argv_;        86 &#160;             if (old_env_ptr_)        87 &#160;                *old_env_ptr_ = old_env_;        88 &#160;        }        89 &#160;        90 &#160;     private :        91 &#160;         class  wargv_ptr        92 &#160;        {        93 &#160;             wchar_t ** p;        94 &#160;             int  argc;        95 &#160;        96 &#160;         public :        97 &#160;            wargv_ptr()        98 &#160;            {        99 &#160;                p = CommandLineToArgvW(GetCommandLineW(), &argc);       100 &#160;            }       101 &#160;            ~wargv_ptr()       102 &#160;            {       103 &#160;                 if (p)       104 &#160;                    LocalFree(p);       105 &#160;            }       106 &#160;            wargv_ptr( const  wargv_ptr&) =  delete ;       107 &#160;            wargv_ptr& operator=( const  wargv_ptr&) =  delete ;       108 &#160;       109 &#160;             int  size()  const        110 &#160;              {       111 &#160;                 return  argc;       112 &#160;            }       113 &#160;             operator  bool()  const        114 &#160;              {       115 &#160;                 return  p !=  nullptr ;       116 &#160;            }       117 &#160;             const   wchar_t * operator[]( size_t  i)  const        118 &#160;              {       119 &#160;                 return  p[i];       120 &#160;            }       121 &#160;        };       122 &#160;         class  wenv_ptr       123 &#160;        {       124 &#160;             wchar_t * p;       125 &#160;       126 &#160;         public :       127 &#160;            wenv_ptr() : p(GetEnvironmentStringsW())       128 &#160;            {}       129 &#160;            ~wenv_ptr()       130 &#160;            {       131 &#160;                 if (p)       132 &#160;                    FreeEnvironmentStringsW(p);       133 &#160;            }       134 &#160;            wenv_ptr( const  wenv_ptr&) =  delete ;       135 &#160;            wenv_ptr& operator=( const  wenv_ptr&) =  delete ;       136 &#160;       137 &#160;             operator   const   wchar_t *()  const        138 &#160;            {       139 &#160;                 return  p;       140 &#160;            }       141 &#160;        };       142 &#160;       143 &#160;         void  fix_args( int & argc,  char **& argv)       144 &#160;        {       145 &#160;             const  wargv_ptr wargv;       146 &#160;             if (!wargv)       147 &#160;                 throw  std::runtime_error( &quot;Could not get command line!&quot; );       148 &#160;            args_.resize(wargv.size() + 1, 0);       149 &#160;            arg_values_.resize(wargv.size());       150 &#160;             for ( int  i = 0; i < wargv.size(); i++)       151 &#160;                args_[i] = arg_values_[i].convert(wargv[i]);       152 &#160;            argc = wargv.size();       153 &#160;            argv = &args_[0];       154 &#160;        }       155 &#160;         void  fix_env( char **& env)       156 &#160;        {       157 &#160;             const  wenv_ptr wstrings;       158 &#160;             if (!wstrings)       159 &#160;                 throw  std::runtime_error( &quot;Could not get environment strings!&quot; );       160 &#160;             const   wchar_t * wstrings_end = 0;       161 &#160;             int  count = 0;       162 &#160;             for (wstrings_end = wstrings; *wstrings_end; wstrings_end += wcslen(wstrings_end) + 1)       163 &#160;                count++;       164 &#160;            env_. convert (wstrings, wstrings_end);       165 &#160;            envp_.resize(count + 1, 0);       166 &#160;             char * p = env_. get ();       167 &#160;             int  pos = 0;       168 &#160;             for ( int  i = 0; i < count; i++)       169 &#160;            {       170 &#160;                 if (*p !=  &#39;=&#39; )       171 &#160;                    envp_[pos++] = p;       172 &#160;                p +=  strlen (p) + 1;       173 &#160;            }       174 &#160;            env = &envp_[0];       175 &#160;        }       176 &#160;       177 &#160;        std::vector<char*> args_;       178 &#160;        std::vector<short_stackstring> arg_values_;       179 &#160;         stackstring  env_;       180 &#160;        std::vector<char*> envp_;       181 &#160;       182 &#160;         int  old_argc_;       183 &#160;         char ** old_argv_;       184 &#160;         char ** old_env_;       185 &#160;       186 &#160;         int * old_argc_ptr_;       187 &#160;         char *** old_argv_ptr_;       188 &#160;         char *** old_env_ptr_;       189 &#160;    };       190 &#160;       191 &#160; #endif        192 &#160;       193 &#160;}  // namespace nowide        194 &#160;}  // namespace boost        195 &#160; #endif     boost::nowide::args::args   args(int &argc, char **&argv, char **&env)   Definition:  args.hpp:70     boost::nowide::args   args is a class that temporarily replaces standard main() function arguments with their equal,...   Definition:  args.hpp:56     boost::nowide::utf::strlen   size_t strlen(const Char *s)   Definition:  convert.hpp:25     boost::nowide::args::args   args(int &argc, char **&argv)   Definition:  args.hpp:62     boost::nowide::basic_stackstring::convert   output_char * convert(const input_char *input)   Definition:  stackstring.hpp:91     boost::nowide::basic_stackstring::get   output_char * get()  Return the converted, NULL-terminated string or NULL if no string was converted.   Definition:  stackstring.hpp:126     boost::nowide::stackstring   basic_stackstring< char, wchar_t, 256 > stackstring   Definition:  stackstring.hpp:198     boost::nowide::args::~args   ~args()   Definition:  args.hpp:80          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide             convert.hpp                1 &#160; //          2 &#160; // Copyright (c) 2012 Artyom Beilis (Tonkikh)          3 &#160; // Copyright (c) 2020 Alexander Grund          4 &#160; //          5 &#160; // Distributed under the Boost Software License, Version 1.0.          6 &#160; // https://www.boost.org/LICENSE_1_0.txt          7 &#160;         8 &#160; #ifndef BOOST_NOWIDE_CONVERT_HPP_INCLUDED          9 &#160; #define BOOST_NOWIDE_CONVERT_HPP_INCLUDED         10 &#160;        11 &#160; #include <boost/nowide/detail/is_string_container.hpp>         12 &#160; #include <boost/nowide/utf/convert.hpp>         13 &#160; #include <string>         14 &#160;        15 &#160; namespace  boost {        16 &#160; namespace  nowide {        17 &#160;         25  &#160;     inline   char *  narrow ( char * output,  size_t  output_size,  const   wchar_t * begin,  const   wchar_t * end)        26 &#160;    {        27 &#160;         return   utf::convert_buffer (output, output_size, begin, end);        28 &#160;    }         36  &#160;     inline   char *  narrow ( char * output,  size_t  output_size,  const   wchar_t * source)        37 &#160;    {        38 &#160;         return   narrow (output, output_size, source, source +  utf::strlen (source));        39 &#160;    }        40 &#160;         48  &#160;     inline   wchar_t *  widen ( wchar_t * output,  size_t  output_size,  const   char * begin,  const   char * end)        49 &#160;    {        50 &#160;         return   utf::convert_buffer (output, output_size, begin, end);        51 &#160;    }         59  &#160;     inline   wchar_t *  widen ( wchar_t * output,  size_t  output_size,  const   char * source)        60 &#160;    {        61 &#160;         return   widen (output, output_size, source, source +  utf::strlen (source));        62 &#160;    }        63 &#160;        71 &#160;     template < typename  T_Char,  typename  = detail::requires_w id e_ char <T_Char>>         72  &#160;     inline  std::string  narrow ( const  T_Char* s,  size_t  count)        73 &#160;    {        74 &#160;         return  utf::convert_string<char>(s, s + count);        75 &#160;    }        82 &#160;     template < typename  T_Char,  typename  = detail::requires_w id e_ char <T_Char>>         83  &#160;     inline  std::string  narrow ( const  T_Char* s)        84 &#160;    {        85 &#160;         return   narrow (s,  utf::strlen (s));        86 &#160;    }        93 &#160;     template < typename  StringOrStringView,  typename  = detail::requires_w id e_ string _container<StringOrStringView>>         94  &#160;     inline  std::string  narrow ( const  StringOrStringView& s)        95 &#160;    {        96 &#160;         return  utf::convert_string<char>(s.data(), s.data() + s.size());        97 &#160;    }        98 &#160;       106 &#160;     template < typename  T_Char,  typename  = detail::requires_narrow_ char <T_Char>>        107  &#160;     inline  std::wstring  widen ( const  T_Char* s,  size_t  count)       108 &#160;    {       109 &#160;         return  utf::convert_string<wchar_t>(s, s + count);       110 &#160;    }       117 &#160;     template < typename  T_Char,  typename  = detail::requires_narrow_ char <T_Char>>        118  &#160;     inline  std::wstring  widen ( const  T_Char* s)       119 &#160;    {       120 &#160;         return   widen (s,  utf::strlen (s));       121 &#160;    }       128 &#160;     template < typename  StringOrStringView,  typename  = detail::requires_narrow_ string _container<StringOrStringView>>        129  &#160;     inline  std::wstring  widen ( const  StringOrStringView& s)       130 &#160;    {       131 &#160;         return  utf::convert_string<wchar_t>(s.data(), s.data() + s.size());       132 &#160;    }       133 &#160;}  // namespace nowide        134 &#160;}  // namespace boost        135 &#160;       136 &#160; #endif     boost::nowide::widen   wchar_t * widen(wchar_t *output, size_t output_size, const char *begin, const char *end)   Definition:  convert.hpp:48     boost::nowide::narrow   char * narrow(char *output, size_t output_size, const wchar_t *begin, const wchar_t *end)   Definition:  convert.hpp:25     boost::nowide::utf::strlen   size_t strlen(const Char *s)   Definition:  convert.hpp:25     boost::nowide::utf::convert_buffer   CharOut * convert_buffer(CharOut *buffer, size_t buffer_size, const CharIn *source_begin, const CharIn *source_end)   Definition:  convert.hpp:42          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                       Boost.Nowide                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         boost    nowide    detail             utf.hpp                1 &#160; //          2 &#160; // Copyright (c) 2020 Alexander Grund          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_NOWIDE_DETAIL_UTF_HPP_INCLUDED          8 &#160; #define BOOST_NOWIDE_DETAIL_UTF_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/nowide/utf/utf.hpp>         11 &#160;        12 &#160; // Legacy compatibility header only. Include <boost/nowide/utf/utf.hpp> instead         13 &#160;        14 &#160; namespace  boost {        15 &#160; namespace  nowide {        16 &#160;     namespace  detail {        17 &#160;         namespace   utf  =  boost::nowide::utf ;        18 &#160;    }  // namespace detail         19 &#160;}  // namespace nowide         20 &#160;}  // namespace boost         21 &#160;        22 &#160; #endif     boost::nowide::utf   Namespace that holds basic operations on UTF encoded sequences.   Definition:  convert.hpp:19          Generated by &#160;    1.8.15    
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR                                         	 	                    	   	        	    	                              /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */         include    boost    gil             promote_integral.hpp                1 &#160; // Boost.GIL (Generic Image Library)          2 &#160; //          3 &#160; // Copyright (c) 2015, Oracle and/or its affiliates.          4 &#160; // Contributed and/or modified by Menelaos Karavelas, on behalf of Oracle          5 &#160; //          6 &#160; // Copyright (c) 2020, Debabrata Mandal <mandaldebabrata123@gmail.com>          7 &#160; //          8 &#160; // Licensed under the Boost Software License version 1.0.          9 &#160; // http://www.boost.org/users/license.html         10 &#160; //         11 &#160; // Source: Boost.Geometry (aka GGL, Generic Geometry Library)         12 &#160; // Modifications: adapted for Boost.GIL         13 &#160; //  - Rename namespace boost::geometry to boost::gil         14 &#160; //  - Rename include guards         15 &#160; //  - Remove support for boost::multiprecision types         16 &#160; //  - Remove support for 128-bit integer types         17 &#160; //  - Replace mpl meta functions with mp11 equivalents         18 &#160; //         19 &#160; #ifndef BOOST_GIL_PROMOTE_INTEGRAL_HPP         20 &#160; #define BOOST_GIL_PROMOTE_INTEGRAL_HPP         21 &#160;        22 &#160; #include <boost/mp11/list.hpp>         23 &#160;        24 &#160; #include <climits>         25 &#160; #include <cstddef>         26 &#160; #include <type_traits>         27 &#160;        28 &#160; namespace   boost  {  namespace  gil        29 &#160;{        30 &#160;        31 &#160; namespace  detail {  namespace  promote_integral        32 &#160;{        33 &#160;        34 &#160; // meta-function that returns the bit size of a type         35 &#160; template         36 &#160;<        37 &#160;     typename  T,        38 &#160;     bool  IsFundamental = std::is_fundamental<T>::value        39 &#160;>        40 &#160; struct  bit_size {};        41 &#160;        42 &#160; // for fundamental types, just return CHAR_BIT * sizeof(T)         43 &#160; template  < typename  T>        44 &#160; struct  bit_size<T, true> : std::integral_constant<std::size_t, (CHAR_BIT * sizeof(T))> {};        45 &#160;        46 &#160; template         47 &#160;<        48 &#160;     typename  T,        49 &#160;     typename  IntegralTypes,        50 &#160;    std::size_t MinSize        51 &#160;>        52 &#160; struct  promote_to_larger        53 &#160;{        54 &#160;     using  current_type = boost::mp11::mp_first<IntegralTypes>;        55 &#160;     using  list_after_front = boost::mp11::mp_rest<IntegralTypes>;        56 &#160;        57 &#160;     using  type =  typename  std::conditional        58 &#160;        <        59 &#160;            (bit_size<current_type>::value >= MinSize),        60 &#160;            current_type,        61 &#160;             typename  promote_to_larger        62 &#160;                <        63 &#160;                    T,        64 &#160;                    list_after_front,        65 &#160;                    MinSize        66 &#160;                >::type        67 &#160;        >::type;        68 &#160;};        69 &#160;        70 &#160; // The following specialization is required to finish the loop over         71 &#160; // all list elements         72 &#160; template  < typename  T, std:: size_t  MinSize>        73 &#160; struct  promote_to_larger<T,  boost ::mp11::mp_list<>, MinSize>        74 &#160;{        75 &#160;     // if promotion fails, keep the number T         76 &#160;     // (and cross fingers that overflow will not occur)         77 &#160;     using  type = T;        78 &#160;};        79 &#160;        80 &#160;}}  // namespace detail::promote_integral         81 &#160;       114 &#160; template        115 &#160;<       116 &#160;     typename  T,       117 &#160;     bool  PromoteUnsignedToUnsigned =  false ,       118 &#160;     bool  UseCheckedInteger =  false ,       119 &#160;     bool  IsIntegral = std::is_integral<T>::value       120 &#160;>        121  &#160; class   promote_integral        122 &#160;{       123 &#160; private :       124 &#160;     static   bool   const  is_unsigned = std::is_unsigned<T>::value;       125 &#160;       126 &#160;     using  bit_size_type = detail::promote_integral::bit_size<T>;       127 &#160;       128 &#160;     // Define the minimum size (in bits) needed for the promoted type        129 &#160;     // If T is the input type and P the promoted type, then the        130 &#160;     // minimum number of bits for P are (below b stands for the number        131 &#160;     // of bits of T):        132 &#160;     // * if T is unsigned and P is unsigned: 2 * b        133 &#160;     // * if T is signed and P is signed: 2 * b - 1        134 &#160;     // * if T is unsigned and P is signed: 2 * b + 1        135 &#160;     using  min_bit_size_type =  typename  std::conditional       136 &#160;        <       137 &#160;            (PromoteUnsignedToUnsigned && is_unsigned),       138 &#160;            std::integral_constant<std::size_t, (2 * bit_size_type::value)>,       139 &#160;             typename  std::conditional       140 &#160;                <       141 &#160;                    is_unsigned,       142 &#160;                    std::integral_constant<std::size_t, (2 * bit_size_type::value + 1)>,       143 &#160;                    std::integral_constant<std::size_t, (2 * bit_size_type::value - 1)>       144 &#160;                >::type       145 &#160;        >::type;       146 &#160;       147 &#160;     // Define the list of signed integral types we are going to use        148 &#160;     // for promotion        149 &#160;     using  signed_integral_types = boost::mp11::mp_list       150 &#160;        <       151 &#160;            short, int,  long        152 &#160; #if defined(BOOST_HAS_LONG_LONG)        153 &#160;            , boost::long_long_type       154 &#160; #endif        155 &#160;        >;       156 &#160;       157 &#160;     // Define the list of unsigned integral types we are going to use        158 &#160;     // for promotion        159 &#160;     using  unsigned_integral_types = boost::mp11::mp_list       160 &#160;        <       161 &#160;             unsigned  short,  unsigned  int,  unsigned  long, std::size_t       162 &#160; #if defined(BOOST_HAS_LONG_LONG)        163 &#160;            , boost::ulong_long_type       164 &#160; #endif        165 &#160;        >;       166 &#160;       167 &#160;     // Define the list of integral types that will be used for        168 &#160;     // promotion (depending in whether we was to promote unsigned to        169 &#160;     // unsigned or not)        170 &#160;     using  integral_types =  typename  std::conditional       171 &#160;        <       172 &#160;            (is_unsigned && PromoteUnsignedToUnsigned),       173 &#160;            unsigned_integral_types,       174 &#160;            signed_integral_types       175 &#160;        >::type;       176 &#160;       177 &#160; public :       178 &#160;     using  type =  typename  detail::promote_integral::promote_to_larger       179 &#160;        <       180 &#160;            T,       181 &#160;            integral_types,       182 &#160;            min_bit_size_type::value       183 &#160;        >::type;       184 &#160;};       185 &#160;       186 &#160;       187 &#160; template  < typename  T,  bool  PromoteUn signed ToUn signed ,  bool  UseCheckedInteger>       188 &#160; class   promote_integral        189 &#160;    <       190 &#160;        T, PromoteUnsignedToUnsigned, UseCheckedInteger, false       191 &#160;    >       192 &#160;{       193 &#160; public :       194 &#160;     using  type = T;       195 &#160;};       196 &#160;       197 &#160;}}  // namespace boost::gil        198 &#160;       199 &#160; #endif // BOOST_GIL_PROMOTE_INTEGRAL_HPP     boost   defined(BOOST_NO_CXX17_HDR_MEMORY_RESOURCE)   Definition:  algorithm.hpp:36     boost::gil::promote_integral   Meta-function to define an integral type with size than is (roughly) twice the bit size of T.   Definition:  promote_integral.hpp:121                                             Generated by &#160; doxygen  1.8.15                
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('config_8hpp_source.html','');});/* @license-end */       config.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_CONFIG_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_CONFIG_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/config.hpp>         11 &#160;        12 &#160; #if defined(BOOST_ALL_DYN_LINK) || defined(BOOST_LOCALE_DYN_LINK)         13 &#160; #   ifdef BOOST_LOCALE_SOURCE         14 &#160; #       define BOOST_LOCALE_DECL BOOST_SYMBOL_EXPORT         15 &#160; #   else         16 &#160; #       define BOOST_LOCALE_DECL BOOST_SYMBOL_IMPORT         17 &#160; #   endif  // BOOST_LOCALE_SOURCE         18 &#160; #else         19 &#160; #   define BOOST_LOCALE_DECL         20 &#160; #endif // BOOST_LOCALE_DYN_LINK         21 &#160;        22 &#160; //         23 &#160; // Automatically link to the correct build variant where possible.         24 &#160; //         25 &#160; #if !defined(BOOST_ALL_NO_LIB) && !defined(BOOST_LOCALE_NO_LIB) && !defined(BOOST_LOCALE_SOURCE)         26 &#160; //         27 &#160; // Set the name of our library, this will get undef&#39;ed by auto_link.hpp         28 &#160; // once it&#39;s done with it:         29 &#160; //         30 &#160; #define BOOST_LIB_NAME boost_locale         31 &#160; //         32 &#160; // If we&#39;re importing code from a dll, then tell auto_link.hpp about it:         33 &#160; //         34 &#160; #if defined(BOOST_ALL_DYN_LINK) || defined(BOOST_LOCALE_DYN_LINK)         35 &#160; #  define BOOST_DYN_LINK         36 &#160; #endif         37 &#160; //         38 &#160; // And include the header that does the work:         39 &#160; //         40 &#160; #include <boost/config/auto_link.hpp>         41 &#160; #endif  // auto-linking disabled         42 &#160;        43 &#160; #if defined(BOOST_LOCALE_HIDE_AUTO_PTR) || defined(BOOST_NO_AUTO_PTR)         44 &#160; #define BOOST_LOCALE_USE_AUTO_PTR 0         45 &#160; #else         46 &#160; #define BOOST_LOCALE_USE_AUTO_PTR 1         47 &#160; #endif         48 &#160;        49 &#160; // Check for C++11 features that will be used in Boost 1.81         50 &#160; // If you are using Boost.Locale and REALLY require it to keep         51 &#160; // supporting C++03/C++98 please comment with a detailed description         52 &#160; // of your use case and reasoning why using C++11 is not possible in         53 &#160; // https://github.com/boostorg/locale/issues/90         54 &#160; #if !defined(BOOST_LOCALE_DISABLE_DEPRECATED_03_WARNING) && ( \         55 &#160;      defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) || \         56 &#160;      defined(BOOST_NO_CXX11_DEFAULTED_MOVES) || \         57 &#160;      defined(BOOST_NO_CXX11_HDR_FUNCTIONAL) || \         58 &#160;      defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS) || \         59 &#160;      defined(BOOST_NO_CXX11_NOEXCEPT) || \         60 &#160;      defined(BOOST_NO_CXX11_OVERRIDE) || \         61 &#160;      defined(BOOST_NO_CXX11_RVALUE_REFERENCES) || \         62 &#160;      defined(BOOST_NO_CXX11_SMART_PTR) || \         63 &#160;      defined(BOOST_NO_CXX11_STATIC_ASSERT) \         64 &#160;     )         65 &#160;         #include <boost/config/pragma_message.hpp>         66 &#160;        BOOST_PRAGMA_MESSAGE( &quot;CAUTION: Boost.Locale support for C++03 is deprecated. C++11 will be required from Boost 1.81 onwards.&quot; )        67 &#160;        BOOST_PRAGMA_MESSAGE(&quot;CAUTION: Define BOOST_LOCALE_DISABLE_DEPRECATED_03_WARNING to suppress this  message .&quot;)        68 &#160; #endif         69 &#160;        70 &#160; #ifdef _MSC_VER         71 &#160; // Denote a constant condition, e.g. for if(sizeof(...         72 &#160; #define BOOST_LOCALE_START_CONST_CONDITION __pragma(warning(push)) __pragma(warning(disable : 4127))         73 &#160; #define BOOST_LOCALE_END_CONST_CONDITION __pragma(warning(pop))         74 &#160; #else         75 &#160; #define BOOST_LOCALE_START_CONST_CONDITION         76 &#160; #define BOOST_LOCALE_END_CONST_CONDITION         77 &#160; #endif         78 &#160;        79 &#160; #endif // boost/locale/config.hpp         80 &#160;    boost::locale::message   basic_message< char > message   Definition:  message.hpp:493             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('encoding__utf_8hpp_source.html','');});/* @license-end */       encoding_utf.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_ENCODING_UTF_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_ENCODING_UTF_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/utf.hpp>         11 &#160; #include <boost/locale/encoding_errors.hpp>         12 &#160; #include <iterator>         13 &#160;        14 &#160; #ifdef BOOST_MSVC         15 &#160; #  pragma warning(push)         16 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         17 &#160; #endif         18 &#160;        19 &#160; namespace  boost {        20 &#160;     namespace  locale {        21 &#160;         namespace  conv {        26 &#160;        30 &#160;             template < typename  CharOut, typename  CharIn>        31 &#160;            std::basic_string<CharOut>         32  &#160;             utf_to_utf (CharIn  const  *begin,CharIn  const  *end, method_type  how =  default_method )        33 &#160;            {        34 &#160;                std::basic_string<CharOut> result;        35 &#160;                result.reserve(end-begin);        36 &#160;                 typedef  std::back_insert_iterator<std::basic_string<CharOut> > inserter_type;        37 &#160;                inserter_type inserter(result);        38 &#160;                 utf::code_point  c;        39 &#160;                 while (begin!=end) {        40 &#160;                    c= utf::utf_traits<CharIn>::template  decode<CharIn const *>(begin,end);        41 &#160;                     if (c== utf::illegal  || c== utf::incomplete ) {        42 &#160;                         if (how== stop )        43 &#160;                             throw   conversion_error ();        44 &#160;                    }        45 &#160;                     else  {        46 &#160;                         utf::utf_traits<CharOut>::template  encode<inserter_type>(c,inserter);        47 &#160;                    }        48 &#160;                }        49 &#160;                 return  result;        50 &#160;            }        51 &#160;        55 &#160;             template < typename  CharOut, typename  CharIn>        56 &#160;            std::basic_string<CharOut>         57  &#160;             utf_to_utf (CharIn  const  *str, method_type  how =  default_method )        58 &#160;            {        59 &#160;                CharIn  const  *end = str;        60 &#160;                 while (*end)        61 &#160;                    end++;        62 &#160;                 return  utf_to_utf<CharOut,CharIn>(str,end,how);        63 &#160;            }        64 &#160;        65 &#160;        69 &#160;             template < typename  CharOut, typename  CharIn>        70 &#160;            std::basic_string<CharOut>         71  &#160;             utf_to_utf (std::basic_string<CharIn>  const  &str, method_type  how =  default_method )        72 &#160;            {        73 &#160;                 return  utf_to_utf<CharOut,CharIn>(str.c_str(),str.c_str()+str.size(),how);        74 &#160;            }        75 &#160;        76 &#160;        78 &#160;        79 &#160;        }  // conv         80 &#160;        81 &#160;    }  // locale         82 &#160;}  // boost         83 &#160;        84 &#160; #ifdef BOOST_MSVC         85 &#160; #pragma warning(pop)         86 &#160; #endif         87 &#160;        88 &#160; #endif         89 &#160;        90 &#160;    boost::locale::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:44     boost::locale::conv::conversion_error   The excepton that is thrown in case of conversion error.   Definition:  encoding_errors.hpp:29     boost::locale::utf::code_point   uint32_t code_point  The integral type that can hold a Unicode code point.   Definition:  utf.hpp:34     boost::locale::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:39     boost::locale::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:63     boost::locale::conv::utf_to_utf   std::basic_string< CharOut > utf_to_utf(CharIn const *begin, CharIn const *end, method_type how=default_method)   Definition:  encoding_utf.hpp:32     boost::locale::conv::default_method   Default method - skip.   Definition:  encoding_errors.hpp:55     boost::locale::conv::stop   Stop conversion and throw conversion_error.   Definition:  encoding_errors.hpp:54     boost::locale::conv::method_type   method_type   Definition:  encoding_errors.hpp:52             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('hold__ptr_8hpp_source.html','');});/* @license-end */       hold_ptr.hpp                1 &#160; //          2 &#160; // Copyright (c) 2010 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_HOLD_PTR_H          8 &#160; #define BOOST_LOCALE_HOLD_PTR_H          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160;        12 &#160; namespace  boost {        13 &#160; namespace  locale {        18 &#160;     template < typename  T>         19  &#160;     class   hold_ptr  {        20 &#160;         hold_ptr ( hold_ptr   const  &other);  // non copyable         21 &#160;         hold_ptr   const  &operator=( hold_ptr   const  &other);  // non assignable         22 &#160;     public :         26  &#160;         hold_ptr () : ptr_(0) {}         30  &#160;         explicit   hold_ptr (T *v) : ptr_(v) {}        31 &#160;         35  &#160;         ~hold_ptr ()        36 &#160;        {        37 &#160;             delete  ptr_;        38 &#160;        }        39 &#160;         43  &#160;        T  const  * get ()  const  {  return  ptr_; }         47  &#160;        T * get () {  return  ptr_; }        48 &#160;         52  &#160;        T  const  & operator * ()  const  {  return  *ptr_; }         56  &#160;        T & operator * () {  return  *ptr_; }         60  &#160;        T  const  * operator-> ()  const  {  return  ptr_; }         64  &#160;        T * operator-> () {  return  ptr_; }        65 &#160;         69  &#160;        T * release () { T *tmp=ptr_; ptr_=0;  return  tmp; }        70 &#160;         74  &#160;         void   reset (T *p=0)        75 &#160;        {        76 &#160;             if (ptr_)  delete  ptr_;        77 &#160;            ptr_=p;        78 &#160;        }         80  &#160;         void   swap ( hold_ptr  &other)        81 &#160;        {        82 &#160;            T *tmp=other.ptr_;        83 &#160;            other.ptr_=ptr_;        84 &#160;            ptr_=tmp;        85 &#160;        }        86 &#160;     private :        87 &#160;        T *ptr_;        88 &#160;    };        89 &#160;        90 &#160;}  // locale         91 &#160;}  // boost         92 &#160;        93 &#160; #endif     boost::locale::hold_ptr::hold_ptr   hold_ptr()   Definition:  hold_ptr.hpp:26     boost::locale::hold_ptr::operator->   T const  * operator->() const   Definition:  hold_ptr.hpp:60     boost::locale::hold_ptr::get   T * get()   Definition:  hold_ptr.hpp:47     boost::locale::hold_ptr::operator *   T const  & operator *() const   Definition:  hold_ptr.hpp:52     boost::locale::hold_ptr::get   T const  * get() const   Definition:  hold_ptr.hpp:43     boost::locale::hold_ptr::hold_ptr   hold_ptr(T *v)   Definition:  hold_ptr.hpp:30     boost::locale::hold_ptr   a smart pointer similar to std::auto_ptr but it is non-copyable and the underlying object has the sam...   Definition:  hold_ptr.hpp:19     boost::locale::hold_ptr::~hold_ptr   ~hold_ptr()   Definition:  hold_ptr.hpp:35     boost::locale::hold_ptr::reset   void reset(T *p=0)   Definition:  hold_ptr.hpp:74     boost::locale::hold_ptr::operator *   T & operator *()   Definition:  hold_ptr.hpp:56     boost::locale::hold_ptr::release   T * release()   Definition:  hold_ptr.hpp:69     boost::locale::hold_ptr::swap   void swap(hold_ptr &other)  Swap two pointers.   Definition:  hold_ptr.hpp:80     boost::locale::hold_ptr::operator->   T * operator->()   Definition:  hold_ptr.hpp:64             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('index_8hpp_source.html','');});/* @license-end */       index.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_INDEX_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_INDEX_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/boundary/types.hpp>         11 &#160; #include <boost/locale/boundary/facets.hpp>         12 &#160; #include <boost/locale/boundary/segment.hpp>         13 &#160; #include <boost/locale/boundary/boundary_point.hpp>         14 &#160; #include <boost/assert.hpp>         15 &#160; #include <boost/cstdint.hpp>         16 &#160; #include <boost/iterator/iterator_facade.hpp>         17 &#160; #include <boost/shared_ptr.hpp>         18 &#160; #include <boost/type_traits/is_same.hpp>         19 &#160; #include <algorithm>         20 &#160; #include <iostream>         21 &#160; #include <iterator>         22 &#160; #include <locale>         23 &#160; #include <stdexcept>         24 &#160; #include <string>         25 &#160; #include <vector>         26 &#160;        27 &#160; #ifdef BOOST_MSVC         28 &#160; #  pragma warning(push)         29 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         30 &#160; #endif         31 &#160;        32 &#160; namespace  boost {        33 &#160;        34 &#160;     namespace  locale {        35 &#160;        36 &#160;         namespace  boundary {        44 &#160;        46 &#160;        47 &#160;             namespace  details {        48 &#160;        49 &#160;                template<typename IteratorType,typename CategoryType = typename std::iterator_traits<IteratorType>::iterator_category>        50 &#160;                 struct  mapping_traits {        51 &#160;                     typedef   typename  std::iterator_traits<IteratorType>::value_type char_type;        52 &#160;                     static   index_type  map( boundary_type  t,IteratorType b,IteratorType e,std::locale  const  &l)        53 &#160;                    {        54 &#160;                        std::basic_string<char_type> str(b,e);        55 &#160;                         return  std::use_facet<boundary_indexing<char_type> >(l).map(t,str.c_str(),str.c_str()+str.size());        56 &#160;                    }        57 &#160;                };        58 &#160;        59 &#160;                 template < typename  CharType, typename  SomeIteratorType>        60 &#160;                 struct  linear_iterator_traits {        61 &#160;                     static   const   bool  is_linear =        62 &#160;                        is_same<SomeIteratorType,CharType*>::value        63 &#160;                        || is_same<SomeIteratorType,CharType const*>::value        64 &#160;                        || is_same<SomeIteratorType,typename std::basic_string<CharType>::iterator>::value        65 &#160;                        || is_same<SomeIteratorType,typename std::basic_string<CharType>::const_iterator>::value        66 &#160;                        || is_same<SomeIteratorType,typename std::vector<CharType>::iterator>::value        67 &#160;                        || is_same<SomeIteratorType,typename std::vector<CharType>::const_iterator>::value        68 &#160;                        ;        69 &#160;                };        70 &#160;        71 &#160;        72 &#160;        73 &#160;                 template < typename  IteratorType>        74 &#160;                 struct  mapping_traits<IteratorType,std::random_access_iterator_tag> {        75 &#160;        76 &#160;                     typedef   typename  std::iterator_traits<IteratorType>::value_type char_type;        77 &#160;        78 &#160;        79 &#160;        80 &#160;                     static   index_type  map( boundary_type  t,IteratorType b,IteratorType e,std::locale  const  &l)        81 &#160;                    {        82 &#160;                         index_type  result;        83 &#160;        84 &#160;                         //         85 &#160;                         // Optimize for most common cases         86 &#160;                         //         87 &#160;                         // C++0x requires that string is continious in memory and all known         88 &#160;                         // string implementations         89 &#160;                         // do this because of c_str() support.         90 &#160;                         //         91 &#160;        92 &#160;                         if (linear_iterator_traits<char_type,IteratorType>::is_linear && b!=e)        93 &#160;                        {        94 &#160;                            char_type  const  *begin = &*b;        95 &#160;                            char_type  const  *end = begin + (e-b);        96 &#160;                             index_type  tmp=std::use_facet<boundary_indexing<char_type> >(l).map(t,begin,end);        97 &#160;                            result.swap(tmp);        98 &#160;                        }        99 &#160;                         else  {       100 &#160;                            std::basic_string<char_type> str(b,e);       101 &#160;                             index_type  tmp = std::use_facet<boundary_indexing<char_type> >(l).map(t,str.c_str(),str.c_str()+str.size());       102 &#160;                            result.swap(tmp);       103 &#160;                        }       104 &#160;                         return  result;       105 &#160;                    }       106 &#160;                };       107 &#160;       108 &#160;                 template < typename  BaseIterator>       109 &#160;                 class  mapping {       110 &#160;                 public :       111 &#160;                     typedef  BaseIterator base_iterator;       112 &#160;                     typedef   typename  std::iterator_traits<base_iterator>::value_type char_type;       113 &#160;       114 &#160;       115 &#160;                    mapping( boundary_type  type,       116 &#160;                            base_iterator begin,       117 &#160;                            base_iterator end,       118 &#160;                            std::locale  const  &loc)       119 &#160;                        :       120 &#160;                            index_(new  index_type ()),       121 &#160;                            begin_(begin),       122 &#160;                            end_(end)       123 &#160;                    {       124 &#160;                         index_type  idx=details::mapping_traits<base_iterator>::map(type,begin,end,loc);       125 &#160;                        index_->swap(idx);       126 &#160;                    }       127 &#160;       128 &#160;                    mapping()       129 &#160;                    {       130 &#160;                    }       131 &#160;       132 &#160;                     index_type   const  &index()  const        133 &#160;                      {       134 &#160;                         return  *index_;       135 &#160;                    }       136 &#160;       137 &#160;                    base_iterator begin()  const        138 &#160;                      {       139 &#160;                         return  begin_;       140 &#160;                    }       141 &#160;       142 &#160;                    base_iterator end()  const        143 &#160;                      {       144 &#160;                         return  end_;       145 &#160;                    }       146 &#160;       147 &#160;                 private :       148 &#160;                    boost::shared_ptr<index_type> index_;       149 &#160;                    base_iterator begin_,end_;       150 &#160;                };       151 &#160;       152 &#160;                 template < typename  BaseIterator>       153 &#160;                 class  segment_index_iterator :       154 &#160;                     public  boost::iterator_facade<       155 &#160;                        segment_index_iterator<BaseIterator>,       156 &#160;                        segment<BaseIterator>,       157 &#160;                        boost::bidirectional_traversal_tag,       158 &#160;                        segment<BaseIterator> const &       159 &#160;                    >       160 &#160;                {       161 &#160;                 public :       162 &#160;                     typedef  BaseIterator base_iterator;       163 &#160;                     typedef  mapping<base_iterator> mapping_type;       164 &#160;                     typedef  segment<base_iterator> segment_type;       165 &#160;       166 &#160;                    segment_index_iterator() : current_(0,0),map_(0)       167 &#160;                    {       168 &#160;                    }       169 &#160;       170 &#160;                    segment_index_iterator(base_iterator p,mapping_type  const  *map, rule_type  mask, bool  full_select) :       171 &#160;                        map_(map),       172 &#160;                        mask_(mask),       173 &#160;                        full_select_(full_select)       174 &#160;                    {       175 &#160;                        set(p);       176 &#160;                    }       177 &#160;                    segment_index_iterator( bool  is_begin,mapping_type  const  *map, rule_type  mask, bool  full_select) :       178 &#160;                        map_(map),       179 &#160;                        mask_(mask),       180 &#160;                        full_select_(full_select)       181 &#160;                    {       182 &#160;                         if (is_begin)       183 &#160;                            set_begin();       184 &#160;                         else        185 &#160;                            set_end();       186 &#160;                    }       187 &#160;       188 &#160;                    segment_type  const  &dereference()  const        189 &#160;                      {       190 &#160;                         return  value_;       191 &#160;                    }       192 &#160;       193 &#160;                     bool  equal(segment_index_iterator  const  &other)  const        194 &#160;                      {       195 &#160;                         return  map_ == other.map_ && current_.second == other.current_.second;       196 &#160;                    }       197 &#160;       198 &#160;                     void  increment()       199 &#160;                    {       200 &#160;                        std::pair<size_t,size_t> next = current_;       201 &#160;                         if (full_select_) {       202 &#160;                            next.first = next.second;       203 &#160;                             while (next.second < size()) {       204 &#160;                                next.second++;       205 &#160;                                 if (valid_offset(next.second))       206 &#160;                                     break ;       207 &#160;                            }       208 &#160;                             if (next.second == size())       209 &#160;                                next.first = next.second - 1;       210 &#160;                        }       211 &#160;                         else  {       212 &#160;                             while (next.second < size()) {       213 &#160;                                next.first = next.second;       214 &#160;                                next.second++;       215 &#160;                                 if (valid_offset(next.second))       216 &#160;                                     break ;       217 &#160;                            }       218 &#160;                        }       219 &#160;                        update_current(next);       220 &#160;                    }       221 &#160;       222 &#160;                     void  decrement()       223 &#160;                    {       224 &#160;                        std::pair<size_t,size_t> next = current_;       225 &#160;                         if (full_select_) {       226 &#160;                             while (next.second >1) {       227 &#160;                                next.second--;       228 &#160;                                 if (valid_offset(next.second))       229 &#160;                                     break ;       230 &#160;                            }       231 &#160;                            next.first = next.second;       232 &#160;                             while (next.first >0) {       233 &#160;                                next.first--;       234 &#160;                                 if (valid_offset(next.first))       235 &#160;                                     break ;       236 &#160;                            }       237 &#160;                        }       238 &#160;                         else  {       239 &#160;                             while (next.second >1) {       240 &#160;                                next.second--;       241 &#160;                                 if (valid_offset(next.second))       242 &#160;                                     break ;       243 &#160;                            }       244 &#160;                            next.first = next.second - 1;       245 &#160;                        }       246 &#160;                        update_current(next);       247 &#160;                    }       248 &#160;       249 &#160;                 private :       250 &#160;       251 &#160;                     void  set_end()       252 &#160;                    {       253 &#160;                        current_.first  = size() - 1;       254 &#160;                        current_.second = size();       255 &#160;                        value_ = segment_type(map_->end(),map_->end(),0);       256 &#160;                    }       257 &#160;                     void  set_begin()       258 &#160;                    {       259 &#160;                        current_.first = current_.second = 0;       260 &#160;                        value_ = segment_type(map_->begin(),map_->begin(),0);       261 &#160;                        increment();       262 &#160;                    }       263 &#160;       264 &#160;                     void  set(base_iterator p)       265 &#160;                    {       266 &#160;                         size_t  dist=std::distance(map_->begin(),p);       267 &#160;                        index_type::const_iterator b=map_->index().begin(),e=map_->index().end();       268 &#160;                        index_type::const_iterator       269 &#160;                            boundary_point=std::upper_bound(b,e,break_info(dist));       270 &#160;                         while (boundary_point != e && (boundary_point->rule & mask_)==0)       271 &#160;                            boundary_point++;       272 &#160;       273 &#160;                        current_.first = current_.second = boundary_point - b;       274 &#160;       275 &#160;                         if (full_select_) {       276 &#160;                             while (current_.first > 0) {       277 &#160;                                current_.first --;       278 &#160;                                 if (valid_offset(current_.first))       279 &#160;                                     break ;       280 &#160;                            }       281 &#160;                        }       282 &#160;                         else  {       283 &#160;                             if (current_.first > 0)       284 &#160;                                current_.first --;       285 &#160;                        }       286 &#160;                        value_.first = map_->begin();       287 &#160;                        std::advance(value_.first,get_offset(current_.first));       288 &#160;                        value_.second = value_.first;       289 &#160;                        std::advance(value_.second,get_offset(current_.second) - get_offset(current_.first));       290 &#160;       291 &#160;                        update_rule();       292 &#160;                    }       293 &#160;       294 &#160;                     void  update_current(std::pair<size_t,size_t> pos)       295 &#160;                    {       296 &#160;                        std::ptrdiff_t first_diff = get_offset(pos.first) - get_offset(current_.first);       297 &#160;                        std::ptrdiff_t second_diff = get_offset(pos.second) - get_offset(current_.second);       298 &#160;                        std::advance(value_.first,first_diff);       299 &#160;                        std::advance(value_.second,second_diff);       300 &#160;                        current_ = pos;       301 &#160;                        update_rule();       302 &#160;                    }       303 &#160;       304 &#160;                     void  update_rule()       305 &#160;                    {       306 &#160;                         if (current_.second != size()) {       307 &#160;                            value_.rule(index()[current_.second].rule);       308 &#160;                        }       309 &#160;                    }       310 &#160;                     size_t  get_offset( size_t  ind)  const        311 &#160;                      {       312 &#160;                         if (ind == size())       313 &#160;                             return  index().back().offset;       314 &#160;                         return  index()[ind].offset;       315 &#160;                    }       316 &#160;       317 &#160;                     bool  valid_offset( size_t  offset)  const        318 &#160;                      {       319 &#160;                         return   offset == 0       320 &#160;                                || offset == size()  // make sure we not acess index[size]        321 &#160;                                || (index()[offset].rule & mask_)!=0;       322 &#160;                    }       323 &#160;       324 &#160;                     size_t  size()  const        325 &#160;                      {       326 &#160;                         return  index().size();       327 &#160;                    }       328 &#160;       329 &#160;                     index_type   const  &index()  const        330 &#160;                      {       331 &#160;                         return  map_->index();       332 &#160;                    }       333 &#160;       334 &#160;       335 &#160;                    segment_type value_;       336 &#160;                    std::pair<size_t,size_t> current_;       337 &#160;                    mapping_type  const  *map_;       338 &#160;                     rule_type  mask_;       339 &#160;                     bool  full_select_;       340 &#160;                };       341 &#160;       342 &#160;                 template < typename  BaseIterator>       343 &#160;                 class  boundary_point_index_iterator :       344 &#160;                     public  boost::iterator_facade<       345 &#160;                        boundary_point_index_iterator<BaseIterator>,       346 &#160;                        boundary_point<BaseIterator>,       347 &#160;                        boost::bidirectional_traversal_tag,       348 &#160;                        boundary_point<BaseIterator> const &       349 &#160;                    >       350 &#160;                {       351 &#160;                 public :       352 &#160;                     typedef  BaseIterator base_iterator;       353 &#160;                     typedef  mapping<base_iterator> mapping_type;       354 &#160;                     typedef  boundary_point<base_iterator> boundary_point_type;       355 &#160;       356 &#160;                    boundary_point_index_iterator() : current_(0),map_(0)       357 &#160;                    {       358 &#160;                    }       359 &#160;       360 &#160;                    boundary_point_index_iterator( bool  is_begin,mapping_type  const  *map, rule_type  mask) :       361 &#160;                        map_(map),       362 &#160;                        mask_(mask)       363 &#160;                    {       364 &#160;                         if (is_begin)       365 &#160;                            set_begin();       366 &#160;                         else        367 &#160;                            set_end();       368 &#160;                    }       369 &#160;                    boundary_point_index_iterator(base_iterator p,mapping_type  const  *map, rule_type  mask) :       370 &#160;                        map_(map),       371 &#160;                        mask_(mask)       372 &#160;                    {       373 &#160;                        set(p);       374 &#160;                    }       375 &#160;       376 &#160;                    boundary_point_type  const  &dereference()  const        377 &#160;                      {       378 &#160;                         return  value_;       379 &#160;                    }       380 &#160;       381 &#160;                     bool  equal(boundary_point_index_iterator  const  &other)  const        382 &#160;                      {       383 &#160;                         return  map_ == other.map_ && current_ == other.current_;       384 &#160;                    }       385 &#160;       386 &#160;                     void  increment()       387 &#160;                    {       388 &#160;                         size_t  next = current_;       389 &#160;                         while (next < size()) {       390 &#160;                            next++;       391 &#160;                             if (valid_offset(next))       392 &#160;                                 break ;       393 &#160;                        }       394 &#160;                        update_current(next);       395 &#160;                    }       396 &#160;       397 &#160;                     void  decrement()       398 &#160;                    {       399 &#160;                         size_t  next = current_;       400 &#160;                         while (next>0) {       401 &#160;                            next--;       402 &#160;                             if (valid_offset(next))       403 &#160;                                 break ;       404 &#160;                        }       405 &#160;                        update_current(next);       406 &#160;                    }       407 &#160;       408 &#160;                 private :       409 &#160;                     void  set_end()       410 &#160;                    {       411 &#160;                        current_ = size();       412 &#160;                        value_ = boundary_point_type(map_->end(),0);       413 &#160;                    }       414 &#160;                     void  set_begin()       415 &#160;                    {       416 &#160;                        current_ = 0;       417 &#160;                        value_ = boundary_point_type(map_->begin(),0);       418 &#160;                    }       419 &#160;       420 &#160;                     void  set(base_iterator p)       421 &#160;                    {       422 &#160;                         size_t  dist =  std::distance(map_->begin(),p);       423 &#160;       424 &#160;                        index_type::const_iterator b=index().begin();       425 &#160;                        index_type::const_iterator e=index().end();       426 &#160;                        index_type::const_iterator ptr = std::lower_bound(b,e,break_info(dist));       427 &#160;       428 &#160;                         if (ptr==index().end())       429 &#160;                            current_=size()-1;       430 &#160;                         else        431 &#160;                            current_=ptr - index().begin();       432 &#160;       433 &#160;                         while (!valid_offset(current_))       434 &#160;                            current_ ++;       435 &#160;       436 &#160;                        std::ptrdiff_t diff = get_offset(current_) - dist;       437 &#160;                        std::advance(p,diff);       438 &#160;                        value_.iterator(p);       439 &#160;                        update_rule();       440 &#160;                    }       441 &#160;       442 &#160;                     void  update_current( size_t  pos)       443 &#160;                    {       444 &#160;                        std::ptrdiff_t diff = get_offset(pos) - get_offset(current_);       445 &#160;                        base_iterator i=value_.iterator();       446 &#160;                        std::advance(i,diff);       447 &#160;                        current_ = pos;       448 &#160;                        value_.iterator(i);       449 &#160;                        update_rule();       450 &#160;                    }       451 &#160;       452 &#160;                     void  update_rule()       453 &#160;                    {       454 &#160;                         if (current_ != size()) {       455 &#160;                            value_.rule(index()[current_].rule);       456 &#160;                        }       457 &#160;                    }       458 &#160;                     size_t  get_offset( size_t  ind)  const        459 &#160;                      {       460 &#160;                         if (ind == size())       461 &#160;                             return  index().back().offset;       462 &#160;                         return  index()[ind].offset;       463 &#160;                    }       464 &#160;       465 &#160;                     bool  valid_offset( size_t  offset)  const        466 &#160;                      {       467 &#160;                         return   offset == 0       468 &#160;                                || offset + 1 >= size()  // last and first are always valid regardless of mark        469 &#160;                                || (index()[offset].rule & mask_)!=0;       470 &#160;                    }       471 &#160;       472 &#160;                     size_t  size()  const        473 &#160;                      {       474 &#160;                         return  index().size();       475 &#160;                    }       476 &#160;       477 &#160;                     index_type   const  &index()  const        478 &#160;                      {       479 &#160;                         return  map_->index();       480 &#160;                    }       481 &#160;       482 &#160;       483 &#160;                    boundary_point_type value_;       484 &#160;                     size_t  current_;       485 &#160;                    mapping_type  const  *map_;       486 &#160;                     rule_type  mask_;       487 &#160;                };       488 &#160;       489 &#160;       490 &#160;            }  // details        491 &#160;       493 &#160;       494 &#160;             template < typename  BaseIterator>        495  &#160;             class   segment_index ;       496 &#160;       497 &#160;             template < typename  BaseIterator>        498  &#160;             class   boundary_point_index ;       499 &#160;       500 &#160;       552 &#160;       553 &#160;             template < typename  BaseIterator>       554 &#160;             class   segment_index  {       555 &#160;             public :       556 &#160;        560  &#160;                 typedef  BaseIterator  base_iterator ;       561 &#160;                 #ifdef BOOST_LOCALE_DOXYGEN        562 &#160;                 typedef  unspecified_iterator_type  iterator ;        580  &#160;                 typedef  unspecified_iterator_type  const_iterator ;       581 &#160;                 #else        582 &#160;                 typedef  details::segment_index_iterator<base_iterator>  iterator ;       583 &#160;                 typedef  details::segment_index_iterator<base_iterator>  const_iterator ;       584 &#160;                 #endif        585 &#160;                 typedef   segment<base_iterator>   value_type ;       590 &#160;        600  &#160;                 segment_index () : mask_(0xFFFFFFFFu),full_select_(false)       601 &#160;                {       602 &#160;                }        607  &#160;                 segment_index ( boundary_type  type,       608 &#160;                             base_iterator   begin ,       609 &#160;                             base_iterator   end ,       610 &#160;                             rule_type  mask,       611 &#160;                            std::locale  const  &loc=std::locale())       612 &#160;                    :       613 &#160;                        map_(type, begin , end ,loc),       614 &#160;                        mask_(mask),       615 &#160;                        full_select_(false)       616 &#160;                {       617 &#160;                }        622  &#160;                 segment_index ( boundary_type  type,       623 &#160;                             base_iterator   begin ,       624 &#160;                             base_iterator   end ,       625 &#160;                            std::locale  const  &loc=std::locale())       626 &#160;                    :       627 &#160;                        map_(type, begin , end ,loc),       628 &#160;                        mask_(0xFFFFFFFFu),       629 &#160;                        full_select_(false)       630 &#160;                {       631 &#160;                }       632 &#160;       643 &#160;                 segment_index ( boundary_point_index<base_iterator>   const  &);       654 &#160;                 segment_index   const  & operator =  ( boundary_point_index<base_iterator>   const  &);       655 &#160;       656 &#160;        663  &#160;                 void   map ( boundary_type  type, base_iterator   begin , base_iterator   end ,std::locale  const  &loc=std::locale())       664 &#160;                {       665 &#160;                    map_ = mapping_type(type, begin , end ,loc);       666 &#160;                }       667 &#160;        677  &#160;                 iterator   begin ()  const        678 &#160;                  {       679 &#160;                     return   iterator ( true ,&map_,mask_,full_select_);       680 &#160;                }       681 &#160;        689  &#160;                 iterator   end ()  const        690 &#160;                  {       691 &#160;                     return   iterator ( false ,&map_,mask_,full_select_);       692 &#160;                }       693 &#160;        711  &#160;                 iterator   find ( base_iterator  p)  const        712 &#160;                  {       713 &#160;                     return   iterator (p,&map_,mask_,full_select_);       714 &#160;                }       715 &#160;        719  &#160;                 rule_type   rule ()  const        720 &#160;                  {       721 &#160;                     return  mask_;       722 &#160;                }        726  &#160;                 void   rule ( rule_type  v)       727 &#160;                {       728 &#160;                    mask_ = v;       729 &#160;                }       730 &#160;       743 &#160;        744  &#160;                 bool   full_select ()   const        745 &#160;                  {       746 &#160;                     return  full_select_;       747 &#160;                }       748 &#160;       761 &#160;        762  &#160;                 void   full_select ( bool  v)       763 &#160;                {       764 &#160;                    full_select_ = v;       765 &#160;                }       766 &#160;       767 &#160;             private :       768 &#160;                 friend   class   boundary_point_index < base_iterator >;       769 &#160;                 typedef  details::mapping<base_iterator> mapping_type;       770 &#160;                mapping_type  map_;       771 &#160;                 rule_type  mask_;       772 &#160;                 bool  full_select_;       773 &#160;            };       774 &#160;       821 &#160;       822 &#160;       823 &#160;             template < typename  BaseIterator>       824 &#160;             class  boundary_point_index {       825 &#160;             public :        829  &#160;                 typedef  BaseIterator  base_iterator ;       830 &#160;                 #ifdef BOOST_LOCALE_DOXYGEN        831 &#160;                 typedef  unspecified_iterator_type  iterator ;        849  &#160;                 typedef  unspecified_iterator_type  const_iterator ;       850 &#160;                 #else        851 &#160;                 typedef  details::boundary_point_index_iterator<base_iterator>  iterator ;       852 &#160;                 typedef  details::boundary_point_index_iterator<base_iterator>  const_iterator ;       853 &#160;                 #endif        854 &#160;                 typedef   boundary_point<base_iterator>   value_type ;       859 &#160;        869  &#160;                 boundary_point_index () : mask_(0xFFFFFFFFu)       870 &#160;                {       871 &#160;                }       872 &#160;        877  &#160;                 boundary_point_index ( boundary_type  type,       878 &#160;                             base_iterator   begin ,       879 &#160;                             base_iterator   end ,       880 &#160;                             rule_type  mask,       881 &#160;                            std::locale  const  &loc=std::locale())       882 &#160;                    :       883 &#160;                        map_(type, begin , end ,loc),       884 &#160;                        mask_(mask)       885 &#160;                {       886 &#160;                }        891  &#160;                 boundary_point_index ( boundary_type  type,       892 &#160;                             base_iterator   begin ,       893 &#160;                             base_iterator   end ,       894 &#160;                            std::locale  const  &loc=std::locale())       895 &#160;                    :       896 &#160;                        map_(type, begin , end ,loc),       897 &#160;                        mask_(0xFFFFFFFFu)       898 &#160;                {       899 &#160;                }       900 &#160;       911 &#160;                 boundary_point_index ( segment_index<base_iterator>   const  &other);       922 &#160;                 boundary_point_index   const  & operator= ( segment_index<base_iterator>   const  &other);       923 &#160;        930  &#160;                 void   map ( boundary_type  type, base_iterator   begin , base_iterator   end ,std::locale  const  &loc=std::locale())       931 &#160;                {       932 &#160;                    map_ = mapping_type(type, begin , end ,loc);       933 &#160;                }       934 &#160;        944  &#160;                 iterator   begin ()  const        945 &#160;                  {       946 &#160;                     return   iterator ( true ,&map_,mask_);       947 &#160;                }       948 &#160;        958  &#160;                 iterator   end ()  const        959 &#160;                  {       960 &#160;                     return   iterator ( false ,&map_,mask_);       961 &#160;                }       962 &#160;        976  &#160;                 iterator   find ( base_iterator  p)  const        977 &#160;                  {       978 &#160;                     return   iterator (p,&map_,mask_);       979 &#160;                }       980 &#160;        984  &#160;                 rule_type   rule ()  const        985 &#160;                  {       986 &#160;                     return  mask_;       987 &#160;                }        991  &#160;                 void   rule ( rule_type  v)       992 &#160;                {       993 &#160;                    mask_ = v;       994 &#160;                }       995 &#160;       996 &#160;             private :       997 &#160;       998 &#160;                 friend   class   segment_index < base_iterator >;       999 &#160;                 typedef  details::mapping<base_iterator> mapping_type;      1000 &#160;                mapping_type  map_;      1001 &#160;                 rule_type  mask_;      1002 &#160;            };      1003 &#160;      1005 &#160;             template < typename  BaseIterator>      1006 &#160;             segment_index<BaseIterator>::segment_index (boundary_point_index<BaseIterator>  const  &other) :      1007 &#160;                map_(other.map_),      1008 &#160;                mask_(0xFFFFFFFFu),      1009 &#160;                full_select_(false)      1010 &#160;            {      1011 &#160;            }      1012 &#160;      1013 &#160;             template < typename  BaseIterator>      1014 &#160;             boundary_point_index<BaseIterator>::boundary_point_index (segment_index<BaseIterator>  const  &other) :      1015 &#160;                map_(other.map_),      1016 &#160;                mask_(0xFFFFFFFFu)      1017 &#160;            {      1018 &#160;            }      1019 &#160;      1020 &#160;             template < typename  BaseIterator>      1021 &#160;            segment_index<BaseIterator>  const  & segment_index<BaseIterator>::operator= (boundary_point_index<BaseIterator>  const  &other)      1022 &#160;            {      1023 &#160;                map_ = other.map_;      1024 &#160;                 return  * this ;      1025 &#160;            }      1026 &#160;      1027 &#160;             template < typename  BaseIterator>      1028 &#160;            boundary_point_index<BaseIterator>  const  & boundary_point_index<BaseIterator>::operator= (segment_index<BaseIterator>  const  &other)      1029 &#160;            {      1030 &#160;                map_ = other.map_;      1031 &#160;                 return  * this ;      1032 &#160;            }      1034 &#160;       1035  &#160;             typedef   segment_index<std::string::const_iterator>   ssegment_index ;             1036  &#160;             typedef   segment_index<std::wstring::const_iterator>   wssegment_index ;          1037 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        1038  &#160;             typedef   segment_index<std::u16string::const_iterator>   u16ssegment_index ;      1039 &#160;             #endif       1040 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        1041  &#160;             typedef   segment_index<std::u32string::const_iterator>   u32ssegment_index ;      1042 &#160;             #endif       1043 &#160;       1044  &#160;             typedef   segment_index<char const *>   csegment_index ;                            1045  &#160;             typedef   segment_index<wchar_t const *>   wcsegment_index ;                       1046 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        1047  &#160;             typedef   segment_index<char16_t const *>   u16csegment_index ;                    1048 &#160;             #endif       1049 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        1050  &#160;             typedef   segment_index<char32_t const *>   u32csegment_index ;                    1051 &#160;             #endif       1052 &#160;       1053  &#160;             typedef   boundary_point_index<std::string::const_iterator>   sboundary_point_index ;       1054  &#160;             typedef   boundary_point_index<std::wstring::const_iterator>   wsboundary_point_index ;      1055 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        1056  &#160;             typedef   boundary_point_index<std::u16string::const_iterator>   u16sboundary_point_index ;      1057 &#160;             #endif       1058 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        1059  &#160;             typedef   boundary_point_index<std::u32string::const_iterator>   u32sboundary_point_index ;      1060 &#160;             #endif       1061 &#160;       1062  &#160;             typedef   boundary_point_index<char const *>   cboundary_point_index ;              1063  &#160;             typedef   boundary_point_index<wchar_t const *>   wcboundary_point_index ;         1064 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        1065  &#160;             typedef   boundary_point_index<char16_t const *>   u16cboundary_point_index ;      1066 &#160;             #endif       1067 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        1068  &#160;             typedef   boundary_point_index<char32_t const *>   u32cboundary_point_index ;      1069 &#160;             #endif       1070 &#160;      1071 &#160;      1072 &#160;      1073 &#160;        }  // boundary       1074 &#160;      1075 &#160;    }  // locale       1076 &#160;}  // boost       1077 &#160;      1084 &#160;      1085 &#160; #ifdef BOOST_MSVC       1086 &#160; #pragma warning(pop)       1087 &#160; #endif       1088 &#160;      1089 &#160; #endif     boost::locale::boundary::segment_index::full_select   void full_select(bool v)   Definition:  index.hpp:762     boost::locale::boundary::boundary_point_index::find   iterator find(base_iterator p) const   Definition:  index.hpp:976     boost::locale::boundary::segment   a segment object that represents a pair of two iterators that define the range where this segment exi...   Definition:  segment.hpp:102     boost::locale::boundary::boundary_type   boundary_type   Definition:  types.hpp:38     boost::locale::boundary::segment_index::full_select   bool full_select() const   Definition:  index.hpp:744     boost::locale::boundary::segment_index::rule   rule_type rule() const   Definition:  index.hpp:719     boost::locale::boundary::boundary_point_index::operator=   boundary_point_index const  & operator=(segment_index< base_iterator > const &other)     boost::locale::boundary::boundary_point_index   This class holds an index of boundary points and allows iterating over them.   Definition:  index.hpp:498     boost::locale::boundary::segment_index::base_iterator   BaseIterator base_iterator   Definition:  index.hpp:560     boost::locale::boundary::u16ssegment_index   segment_index< std::u16string::const_iterator > u16ssegment_index  convenience typedef   Definition:  index.hpp:1038     boost::locale::boundary::csegment_index   segment_index< char const * > csegment_index  convenience typedef   Definition:  index.hpp:1044     boost::locale::boundary::segment_index::map   void map(boundary_type type, base_iterator begin, base_iterator end, std::locale const &loc=std::locale())   Definition:  index.hpp:663     boost::locale::boundary::segment_index::begin   iterator begin() const   Definition:  index.hpp:677     boost::locale::boundary::wsboundary_point_index   boundary_point_index< std::wstring::const_iterator > wsboundary_point_index  convenience typedef   Definition:  index.hpp:1054     boost::locale::boundary::boundary_point_index::end   iterator end() const   Definition:  index.hpp:958     boost::locale::boundary::wcboundary_point_index   boundary_point_index< wchar_t const * > wcboundary_point_index  convenience typedef   Definition:  index.hpp:1063     boost::locale::boundary::boundary_point_index::value_type   boundary_point< base_iterator > value_type   Definition:  index.hpp:858     boost::locale::boundary::segment_index::value_type   segment< base_iterator > value_type   Definition:  index.hpp:589     boost::locale::boundary::boundary_point_index::rule   void rule(rule_type v)   Definition:  index.hpp:991     boost::locale::boundary::segment_index::operator=   segment_index const  & operator=(boundary_point_index< base_iterator > const &)     boost::locale::boundary::rule_type   uint32_t rule_type  Flags used with word boundary analysis – the type of the word, line or sentence boundary found.   Definition:  types.hpp:50     boost::locale::boundary::u16cboundary_point_index   boundary_point_index< char16_t const * > u16cboundary_point_index  convenience typedef   Definition:  index.hpp:1065     boost::locale::boundary::boundary_point_index::map   void map(boundary_type type, base_iterator begin, base_iterator end, std::locale const &loc=std::locale())   Definition:  index.hpp:930     boost::locale::boundary::segment_index::iterator   unspecified_iterator_type iterator   Definition:  index.hpp:576     boost::locale::boundary::segment_index::segment_index   segment_index()   Definition:  index.hpp:600     boost::locale::boundary::u16csegment_index   segment_index< char16_t const * > u16csegment_index  convenience typedef   Definition:  index.hpp:1047     boost::locale::boundary::segment_index::end   iterator end() const   Definition:  index.hpp:689     boost::locale::boundary::boundary_point_index::begin   iterator begin() const   Definition:  index.hpp:944     boost::locale::boundary::sboundary_point_index   boundary_point_index< std::string::const_iterator > sboundary_point_index  convenience typedef   Definition:  index.hpp:1053     boost::locale::boundary::ssegment_index   segment_index< std::string::const_iterator > ssegment_index  convenience typedef   Definition:  index.hpp:1035     boost::locale::boundary::u32csegment_index   segment_index< char32_t const * > u32csegment_index  convenience typedef   Definition:  index.hpp:1050     boost::locale::boundary::wssegment_index   segment_index< std::wstring::const_iterator > wssegment_index  convenience typedef   Definition:  index.hpp:1036     boost::locale::boundary::segment_index::const_iterator   unspecified_iterator_type const_iterator   Definition:  index.hpp:580     boost::locale::boundary::boundary_point_index::const_iterator   unspecified_iterator_type const_iterator   Definition:  index.hpp:849     boost::locale::boundary::boundary_point   This class represents a boundary point in the text.   Definition:  boundary_point.hpp:47     boost::locale::boundary::boundary_point_index::rule   rule_type rule() const   Definition:  index.hpp:984     boost::locale::boundary::segment_index::rule   void rule(rule_type v)   Definition:  index.hpp:726     boost::locale::boundary::boundary_point_index::boundary_point_index   boundary_point_index(boundary_type type, base_iterator begin, base_iterator end, std::locale const &loc=std::locale())   Definition:  index.hpp:891     boost::locale::boundary::u32cboundary_point_index   boundary_point_index< char32_t const * > u32cboundary_point_index  convenience typedef   Definition:  index.hpp:1068     boost::locale::boundary::segment_index::segment_index   segment_index(boundary_type type, base_iterator begin, base_iterator end, rule_type mask, std::locale const &loc=std::locale())   Definition:  index.hpp:607     boost::locale::boundary::cboundary_point_index   boundary_point_index< char const * > cboundary_point_index  convenience typedef   Definition:  index.hpp:1062     boost::locale::boundary::u32sboundary_point_index   boundary_point_index< std::u32string::const_iterator > u32sboundary_point_index  convenience typedef   Definition:  index.hpp:1059     boost::locale::boundary::segment_index::find   iterator find(base_iterator p) const   Definition:  index.hpp:711     boost::locale::boundary::boundary_point_index::iterator   unspecified_iterator_type iterator   Definition:  index.hpp:845     boost::locale::boundary::segment_index::segment_index   segment_index(boundary_type type, base_iterator begin, base_iterator end, std::locale const &loc=std::locale())   Definition:  index.hpp:622     boost::locale::boundary::u16sboundary_point_index   boundary_point_index< std::u16string::const_iterator > u16sboundary_point_index  convenience typedef   Definition:  index.hpp:1056     boost::locale::boundary::boundary_point_index::base_iterator   BaseIterator base_iterator   Definition:  index.hpp:829     boost::locale::boundary::u32ssegment_index   segment_index< std::u32string::const_iterator > u32ssegment_index  convenience typedef   Definition:  index.hpp:1041     boost::locale::boundary::index_type   std::vector< break_info > index_type   Definition:  facets.hpp:82     boost::locale::boundary::boundary_point_index::boundary_point_index   boundary_point_index()   Definition:  index.hpp:869     boost::locale::boundary::segment_index   This class holds an index of segments in the text range and allows to iterate over them.   Definition:  index.hpp:495     boost::locale::boundary::boundary_point_index::boundary_point_index   boundary_point_index(boundary_type type, base_iterator begin, base_iterator end, rule_type mask, std::locale const &loc=std::locale())   Definition:  index.hpp:877     boost::locale::boundary::wcsegment_index   segment_index< wchar_t const * > wcsegment_index  convenience typedef   Definition:  index.hpp:1045             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('encoding__errors_8hpp_source.html','');});/* @license-end */       encoding_errors.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_ENCODING_ERRORS_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_ENCODING_ERRORS_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <stdexcept>         12 &#160;        13 &#160; #ifdef BOOST_MSVC         14 &#160; #  pragma warning(push)         15 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         16 &#160; #endif         17 &#160;        18 &#160; namespace  boost {        19 &#160;     namespace  locale {        20 &#160;         namespace  conv {        25 &#160;         29  &#160;             class  BOOST_SYMBOL_VISIBLE  conversion_error  :  public  std::runtime_error {        30 &#160;             public :        31 &#160;                 conversion_error () : std::runtime_error( &quot;Conversion failed&quot; ) {}        32 &#160;            };        33 &#160;         38  &#160;             class  BOOST_SYMBOL_VISIBLE  invalid_charset_error  :  public  std::runtime_error {        39 &#160;             public :        40 &#160;         42  &#160;                 invalid_charset_error (std::string charset) :        43 &#160;                    std::runtime_error( &quot;Invalid or unsupported charset:&quot;  + charset)        44 &#160;                {        45 &#160;                }        46 &#160;            };        47 &#160;        48 &#160;         52  &#160;             typedef   enum  {         53  &#160;                 skip             = 0,             54  &#160;                 stop             = 1,             55  &#160;                 default_method   =  skip           56 &#160;            }  method_type ;        57 &#160;        58 &#160;        60 &#160;        61 &#160;        }  // conv         62 &#160;        63 &#160;    }  // locale         64 &#160;}  // boost         65 &#160;        66 &#160; #ifdef BOOST_MSVC         67 &#160; #pragma warning(pop)         68 &#160; #endif         69 &#160;        70 &#160; #endif         71 &#160;        72 &#160;    boost::locale::conv::conversion_error   The excepton that is thrown in case of conversion error.   Definition:  encoding_errors.hpp:29     boost::locale::conv::invalid_charset_error   This exception is thrown in case of use of unsupported or invalid character set.   Definition:  encoding_errors.hpp:38     boost::locale::conv::default_method   Default method - skip.   Definition:  encoding_errors.hpp:55     boost::locale::conv::invalid_charset_error::invalid_charset_error   invalid_charset_error(std::string charset)  Create an error for charset charset.   Definition:  encoding_errors.hpp:42     boost::locale::conv::stop   Stop conversion and throw conversion_error.   Definition:  encoding_errors.hpp:54     boost::locale::conv::skip   Skip illegal/unconvertable characters.   Definition:  encoding_errors.hpp:53     boost::locale::conv::method_type   method_type   Definition:  encoding_errors.hpp:52             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('generator_8hpp_source.html','');});/* @license-end */       generator.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_GENERATOR_HPP          8 &#160; #define BOOST_LOCALE_GENERATOR_HPP          9 &#160; #include <boost/locale/config.hpp>         10 &#160; #include <boost/locale/hold_ptr.hpp>         11 &#160; #include <boost/cstdint.hpp>         12 &#160; #include <string>         13 &#160; #include <locale>         14 &#160; #include <memory>         15 &#160;        16 &#160; #ifdef BOOST_MSVC         17 &#160; #  pragma warning(push)         18 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         19 &#160; #endif         20 &#160;        21 &#160; namespace  boost {        22 &#160;        26 &#160;     namespace  locale {        27 &#160;        28 &#160;         class  localization_backend;        29 &#160;         class  localization_backend_manager;        30 &#160;         31  &#160;         static   const  uint32_t  nochar_facet     = 0;                 32  &#160;         static   const  uint32_t  char_facet       = 1 << 0;            33  &#160;         static   const  uint32_t  wchar_t_facet    = 1 << 1;            34  &#160;         static   const  uint32_t  char16_t_facet   = 1 << 2;            35  &#160;         static   const  uint32_t  char32_t_facet   = 1 << 3;           36 &#160;         37  &#160;         static   const  uint32_t  character_first_facet  =  char_facet ;           38  &#160;         static   const  uint32_t  character_last_facet  =  char32_t_facet ;          39  &#160;         static   const  uint32_t  all_characters  = 0xFFFF;             40 &#160;         41  &#160;         typedef  uint32_t  character_facet_type ;         42 &#160;         43  &#160;         static   const  uint32_t      convert_facet    = 1 << 0;            44  &#160;         static   const  uint32_t      collation_facet  = 1 << 1;            45  &#160;         static   const  uint32_t      formatting_facet = 1 << 2;            46  &#160;         static   const  uint32_t      parsing_facet    = 1 << 3;            47  &#160;         static   const  uint32_t      message_facet    = 1 << 4;            48  &#160;         static   const  uint32_t      codepage_facet   = 1 << 5;            49  &#160;         static   const  uint32_t      boundary_facet   = 1 << 6;           50 &#160;         51  &#160;         static   const  uint32_t      per_character_facet_first  =  convert_facet ;          52  &#160;         static   const  uint32_t      per_character_facet_last  =  boundary_facet ;         53 &#160;         54  &#160;         static   const  uint32_t      calendar_facet   = 1 << 16;            55  &#160;         static   const  uint32_t      information_facet  = 1 << 17;           56 &#160;         57  &#160;         static   const  uint32_t     non_character_facet_first  =  calendar_facet ;          58  &#160;         static   const  uint32_t     non_character_facet_last  =  information_facet ;        59 &#160;        60 &#160;         61  &#160;         static   const  uint32_t     all_categories   = 0xFFFFFFFFu;           62 &#160;         63  &#160;         typedef  uint32_t  locale_category_type ;         64 &#160;        71 &#160;         72  &#160;         class  BOOST_LOCALE_DECL  generator  {        73 &#160;         public :        74 &#160;        78 &#160;             generator ();        82 &#160;             generator ( localization_backend_manager   const  &);        83 &#160;        84 &#160;            ~ generator ();        85 &#160;        89 &#160;             void  categories( locale_category_type  cats);        93 &#160;             locale_category_type  categories()  const ;        94 &#160;        98 &#160;             void  characters( character_facet_type  chars);       102 &#160;             character_facet_type  characters()  const ;       103 &#160;       124 &#160;             void  add_messages_domain(std::string  const  & domain );       129 &#160;             void  set_default_messages_domain(std::string  const  & domain );       130 &#160;       134 &#160;             void  clear_domains();       135 &#160;       150 &#160;             void  add_messages_path(std::string  const  &path);       151 &#160;       155 &#160;             void  clear_paths();       156 &#160;       160 &#160;             void  clear_cache();       161 &#160;       165 &#160;             void  locale_cache_enabled( bool  on);       166 &#160;       170 &#160;             bool  locale_cache_enabled()  const ;       171 &#160;       175 &#160;             bool  use_ansi_encoding()  const ;       176 &#160;       184 &#160;             void  use_ansi_encoding( bool  enc);       185 &#160;       189 &#160;            std::locale generate(std::string  const  & id )  const ;       194 &#160;            std::locale generate(std::locale  const  &base,std::string  const  & id )  const ;        198  &#160;            std::locale  operator() (std::string  const  & id )  const        199 &#160;              {       200 &#160;                 return  generate( id );       201 &#160;            }       202 &#160;       206 &#160;             void  set_option(std::string  const  &name,std::string  const  &value);       207 &#160;       211 &#160;             void  clear_options();       212 &#160;       213 &#160;         private :       214 &#160;       215 &#160;             void  set_all_options( localization_backend & backend,std::string  const  & id )  const ;       216 &#160;       217 &#160;             generator ( generator   const  &);       218 &#160;             void  operator=( generator   const  &);       219 &#160;       220 &#160;             struct  data;       221 &#160;             hold_ptr<data>  d;       222 &#160;        };       223 &#160;       224 &#160;    }       225 &#160;}       226 &#160; #ifdef BOOST_MSVC        227 &#160; #pragma warning(pop)        228 &#160; #endif        229 &#160;       230 &#160;       231 &#160; #endif        232 &#160;    boost::locale::boundary_facet   static const uint32_t boundary_facet  Generate boundary analysis facet.   Definition:  generator.hpp:49     boost::locale::non_character_facet_first   static const uint32_t non_character_facet_first  First character independent facet.   Definition:  generator.hpp:57     boost::locale::calendar_facet   the facet that generates calendar for specific locale   Definition:  date_time_facet.hpp:230     boost::locale::localization_backend_manager   Localization backend manager is a class that holds various backend and allows creation of their combi...   Definition:  localization_backend.hpp:82     boost::locale::parsing_facet   static const uint32_t parsing_facet  Generate numbers, currency, date-time formatting facets.   Definition:  generator.hpp:46     boost::locale::generator::operator()   std::locale operator()(std::string const &id) const   Definition:  generator.hpp:198     boost::locale::nochar_facet   static const uint32_t nochar_facet  Unspecified character category for character independent facets.   Definition:  generator.hpp:31     boost::locale::character_facet_type   uint32_t character_facet_type  type that specifies the character type that locales can be generated for   Definition:  generator.hpp:41     boost::locale::formatting_facet   static const uint32_t formatting_facet  Generate numbers, currency, date-time formatting facets.   Definition:  generator.hpp:45     boost::locale::convert_facet   static const uint32_t convert_facet  Generate conversion facets.   Definition:  generator.hpp:43     boost::locale::per_character_facet_last   static const uint32_t per_character_facet_last  Last facet specific for character.   Definition:  generator.hpp:52     boost::locale::calendar_facet   static const uint32_t calendar_facet  Generate boundary analysis facet.   Definition:  generator.hpp:54     boost::locale::message_facet   static const uint32_t message_facet  Generate message facets.   Definition:  generator.hpp:47     boost::locale::localization_backend   this class represents a localization backend that can be used for localizing your application.   Definition:  localization_backend.hpp:45     boost::locale::codepage_facet   static const uint32_t codepage_facet  Generate character set conversion facets (derived from std::codecvt)   Definition:  generator.hpp:48     boost::locale::per_character_facet_first   static const uint32_t per_character_facet_first  First facet specific for character.   Definition:  generator.hpp:51     boost::locale::character_last_facet   static const uint32_t character_last_facet  Last facet specific for character type.   Definition:  generator.hpp:38     boost::locale::hold_ptr< data >      boost::locale::character_first_facet   static const uint32_t character_first_facet  First facet specific for character type.   Definition:  generator.hpp:37     boost::locale::collation_facet   static const uint32_t collation_facet  Generate collation facets.   Definition:  generator.hpp:44     boost::locale::non_character_facet_last   static const uint32_t non_character_facet_last  Last character independent facet.   Definition:  generator.hpp:58     boost::locale::char16_t_facet   static const uint32_t char16_t_facet  C++0x char16_t facets.   Definition:  generator.hpp:34     boost::locale::as::domain   unspecified_type domain(std::string const &id)   Definition:  message.hpp:788     boost::locale::char32_t_facet   static const uint32_t char32_t_facet  C++0x char32_t facets.   Definition:  generator.hpp:35     boost::locale::locale_category_type   uint32_t locale_category_type  a type used for more fine grained generation of facets   Definition:  generator.hpp:63     boost::locale::information_facet   static const uint32_t information_facet  Generate general locale information facet.   Definition:  generator.hpp:55     boost::locale::generator   the major class used for locale generation   Definition:  generator.hpp:72     boost::locale::char_facet   static const uint32_t char_facet  8-bit character facets   Definition:  generator.hpp:32     boost::locale::all_categories   static const uint32_t all_categories  Generate all of them.   Definition:  generator.hpp:61     boost::locale::wchar_t_facet   static const uint32_t wchar_t_facet  wide character facets   Definition:  generator.hpp:33     boost::locale::all_characters   static const uint32_t all_characters  Special mask – generate all.   Definition:  generator.hpp:39             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('utf8__codecvt_8hpp_source.html','');});/* @license-end */       utf8_codecvt.hpp                1 &#160; //          2 &#160; // Copyright (c) 2015 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_UTF8_CODECVT_HPP          8 &#160; #define BOOST_LOCALE_UTF8_CODECVT_HPP          9 &#160;        10 &#160; #include <boost/locale/utf.hpp>         11 &#160; #include <boost/locale/generic_codecvt.hpp>         12 &#160; #include <boost/cstdint.hpp>         13 &#160; #include <locale>         14 &#160;        15 &#160; namespace  boost {        16 &#160; namespace  locale {        17 &#160;        21 &#160; template < typename  CharType>         22  &#160; class   utf8_codecvt  :  public   generic_codecvt <CharType,utf8_codecvt<CharType> >        23 &#160;{        24 &#160; public :        25 &#160;         26  &#160;     struct   state_type  {};        27 &#160;        28 &#160;     utf8_codecvt ( size_t  refs = 0) :  generic_codecvt <CharType, utf8_codecvt <CharType> >(refs)        29 &#160;    {        30 &#160;    }        31 &#160;        32 &#160;     static   int  max_encoding_length()        33 &#160;    {        34 &#160;         return  4;        35 &#160;    }        36 &#160;        37 &#160;     static  state_type initial_state( generic_codecvt_base::initial_convertion_state   /* unused */ )        38 &#160;    {        39 &#160;         return  state_type();        40 &#160;    }        41 &#160;     static   utf::code_point  to_unicode(state_type &, char   const  *&begin, char   const  *end)        42 &#160;    {        43 &#160;         char   const  *p=begin;        44 &#160;        45 &#160;         utf::code_point  c =  utf::utf_traits<char>::decode (p,end);        46 &#160;         if (c!= utf::illegal  && c!= utf::incomplete )        47 &#160;            begin = p;        48 &#160;         return  c;        49 &#160;    }        50 &#160;        51 &#160;     static   utf::code_point  from_unicode(state_type &, utf::code_point  u, char  *begin, char   const  *end)        52 &#160;    {        53 &#160;         if (! utf::is_valid_codepoint (u))        54 &#160;             return   utf::illegal ;        55 &#160;         int  width;        56 &#160;         if ((width= utf::utf_traits<char>::width (u)) > end - begin)        57 &#160;             return   utf::incomplete ;        58 &#160;         utf::utf_traits<char>::encode (u,begin);        59 &#160;         return  width;        60 &#160;    }        61 &#160;};        62 &#160;        63 &#160;}  // locale         64 &#160;}  // namespace boost         65 &#160;        66 &#160; #endif         67 &#160;   boost::locale::utf::utf_traits::decode   static code_point decode(Iterator &p, Iterator e)     boost::locale::utf::is_valid_codepoint   bool is_valid_codepoint(code_point v)  the function checks if v is a valid code point   Definition:  utf.hpp:49     boost::locale::utf::utf_traits::encode   static Iterator encode(code_point value, Iterator out)     boost::locale::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:44     boost::locale::utf8_codecvt   Geneneric utf8 codecvt facet, it allows to convert UTF-8 strings to UTF-16 and UTF-32 using wchar_t,...   Definition:  utf8_codecvt.hpp:22     boost::locale::utf::code_point   uint32_t code_point  The integral type that can hold a Unicode code point.   Definition:  utf.hpp:34     boost::locale::generic_codecvt_base::initial_convertion_state   initial_convertion_state   Definition:  generic_codecvt.hpp:38     boost::locale::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:39     boost::locale::utf::utf_traits::width   static int width(code_point value)     boost::locale::utf8_codecvt::state_type    Definition:  utf8_codecvt.hpp:26     boost::locale::generic_codecvt   Geneneric generic codecvt facet, various stateless encodings to UTF-16 and UTF-32 using wchar_t,...   Definition:  generic_codecvt.hpp:139             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('formatting_8hpp_source.html','');});/* @license-end */       formatting.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_FORMATTING_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_FORMATTING_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/locale/time_zone.hpp>         12 &#160; #include <boost/cstdint.hpp>         13 &#160; #include <cstring>         14 &#160; #include <istream>         15 &#160; #include <ostream>         16 &#160; #include <string>         17 &#160; #include <typeinfo>         18 &#160;        19 &#160; #ifdef BOOST_MSVC         20 &#160; #  pragma warning(push)         21 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         22 &#160; #endif         23 &#160;        24 &#160; namespace  boost {        25 &#160;     namespace  locale {         30  &#160;         namespace  flags {         35  &#160;             typedef   enum  {        36 &#160;                posix               = 0,        37 &#160;                number              = 1,        38 &#160;                currency            = 2,        39 &#160;                percent             = 3,        40 &#160;                date                = 4,        41 &#160;                time                = 5,        42 &#160;                datetime            = 6,        43 &#160;                strftime            = 7,        44 &#160;                spellout            = 8,        45 &#160;                ordinal             = 9,        46 &#160;        47 &#160;                display_flags_mask  = 31,        48 &#160;        49 &#160;                currency_default    = 0 << 5,        50 &#160;                currency_iso        = 1 << 5,        51 &#160;                currency_national   = 2 << 5,        52 &#160;        53 &#160;                currency_flags_mask = 3 << 5,        54 &#160;        55 &#160;                time_default        = 0 << 7,        56 &#160;                time_short          = 1 << 7,        57 &#160;                time_medium         = 2 << 7,        58 &#160;                time_long           = 3 << 7,        59 &#160;                time_full           = 4 << 7,        60 &#160;                time_flags_mask     = 7 << 7,        61 &#160;        62 &#160;                date_default        = 0 << 10,        63 &#160;                date_short          = 1 << 10,        64 &#160;                date_medium         = 2 << 10,        65 &#160;                date_long           = 3 << 10,        66 &#160;                date_full           = 4 << 10,        67 &#160;                date_flags_mask     = 7 << 10,        68 &#160;        69 &#160;                datetime_flags_mask = date_flags_mask | time_flags_mask        70 &#160;        71 &#160;            }  display_flags_type ;        72 &#160;         77  &#160;             typedef   enum  {         78  &#160;                 datetime_pattern ,            79  &#160;                 time_zone_id                 80 &#160;            }  pattern_type ;        81 &#160;         85  &#160;             typedef   enum  {         86  &#160;                 domain_id                    87 &#160;            }  value_type ;        88 &#160;        89 &#160;        90 &#160;        }  // flags         91 &#160;         98  &#160;         class  BOOST_LOCALE_DECL  ios_info  {        99 &#160;         public :       100 &#160;       102 &#160;       103 &#160;             ios_info ();       104 &#160;             ios_info ( ios_info   const  &);       105 &#160;             ios_info   const  &operator=( ios_info   const  &);       106 &#160;            ~ ios_info ();       107 &#160;       109 &#160;       113 &#160;             static   ios_info  &get(std::ios_base &ios);       114 &#160;       118 &#160;             void  display_flags(uint64_t flags);       119 &#160;       123 &#160;             void  currency_flags(uint64_t flags);       124 &#160;       128 &#160;             void  date_flags(uint64_t flags);       129 &#160;       133 &#160;             void  time_flags(uint64_t flags);       134 &#160;       138 &#160;             void  datetime_flags(uint64_t flags);       139 &#160;       143 &#160;             void  domain_id( int );       144 &#160;       148 &#160;             void   time_zone (std::string  const  &);       149 &#160;       150 &#160;       154 &#160;             template < typename  CharType>        155  &#160;             void   date_time_pattern (std::basic_string<CharType>  const  &str)       156 &#160;            {       157 &#160;                string_set &s = date_time_pattern_set();       158 &#160;                s.set<CharType>(str.c_str());       159 &#160;            }       160 &#160;       161 &#160;       165 &#160;            uint64_t display_flags()  const ;       166 &#160;       170 &#160;            uint64_t currency_flags()  const ;       171 &#160;       172 &#160;       176 &#160;            uint64_t date_flags()  const ;       177 &#160;       181 &#160;            uint64_t time_flags()  const ;       182 &#160;       186 &#160;            uint64_t datetime_flags()  const ;       187 &#160;       191 &#160;             int  domain_id()  const ;       192 &#160;       196 &#160;            std::string  time_zone ()  const ;       197 &#160;       201 &#160;             template < typename  CharType>        202  &#160;            std::basic_string<CharType>  date_time_pattern ()  const        203 &#160;              {       204 &#160;                string_set  const  &s = date_time_pattern_set();       205 &#160;                 return  s.get<CharType>();       206 &#160;            }       207 &#160;       209 &#160;             void  on_imbue();       211 &#160;       212 &#160;         private :       213 &#160;       214 &#160;             class  string_set;       215 &#160;       216 &#160;            string_set  const  &date_time_pattern_set()  const ;       217 &#160;            string_set &date_time_pattern_set();       218 &#160;       219 &#160;             class  BOOST_LOCALE_DECL string_set {       220 &#160;             public :       221 &#160;                string_set();       222 &#160;                ~string_set();       223 &#160;                string_set(string_set  const  &other);       224 &#160;                string_set  const  &operator=(string_set  const  &other);       225 &#160;                 void  swap(string_set &other);       226 &#160;       227 &#160;                 template < typename  Char>       228 &#160;                 void  set(Char  const  *s)       229 &#160;                {       230 &#160;                     delete  [] ptr;       231 &#160;                    ptr = 0;       232 &#160;                    type=& typeid (Char);       233 &#160;                    Char  const  *end = s;       234 &#160;                     while (*end!=0) end++;       235 &#160;                     // if ptr = 0 it does not matter what is value of size        236 &#160;                    size =  sizeof (Char)*(end - s+1);       237 &#160;                    ptr =  new   char [size];       238 &#160;                    memcpy(ptr,s,size);       239 &#160;                }       240 &#160;       241 &#160;                 template < typename  Char>       242 &#160;                std::basic_string<Char> get()  const        243 &#160;                  {       244 &#160;                     if (type==0 || *type!= typeid (Char))       245 &#160;                         throw  std::bad_cast();       246 &#160;                    std::basic_string<Char> result = reinterpret_cast<Char const *>(ptr);       247 &#160;                     return  result;       248 &#160;                }       249 &#160;       250 &#160;             private :       251 &#160;                std::type_info  const  *type;       252 &#160;                 size_t  size;       253 &#160;                 char  *ptr;       254 &#160;            };       255 &#160;       256 &#160;            uint64_t flags_;       257 &#160;             int  domain_id_;       258 &#160;            std::string time_zone_;       259 &#160;            string_set datetime_;       260 &#160;       261 &#160;             struct  data;       262 &#160;            data *d;       263 &#160;       264 &#160;        };       265 &#160;       266 &#160;        270  &#160;         namespace  as {       276 &#160;       281 &#160;        282  &#160;             inline  std::ios_base &  posix (std::ios_base & ios)       283 &#160;            {       284 &#160;                 ios_info::get (ios). display_flags (flags::posix);       285 &#160;                 return  ios;       286 &#160;            }       287 &#160;        292  &#160;             inline  std::ios_base &  number (std::ios_base & ios)       293 &#160;            {       294 &#160;                 ios_info::get (ios). display_flags (flags::number);       295 &#160;                 return  ios;       296 &#160;            }       297 &#160;        301  &#160;             inline  std::ios_base &  currency (std::ios_base & ios)       302 &#160;            {       303 &#160;                 ios_info::get (ios). display_flags (flags::currency);       304 &#160;                 return  ios;       305 &#160;            }       306 &#160;        310  &#160;             inline  std::ios_base &  percent (std::ios_base & ios)       311 &#160;            {       312 &#160;                 ios_info::get (ios). display_flags (flags::percent);       313 &#160;                 return  ios;       314 &#160;            }       315 &#160;        319  &#160;             inline  std::ios_base &  date (std::ios_base & ios)       320 &#160;            {       321 &#160;                 ios_info::get (ios). display_flags (flags::date);       322 &#160;                 return  ios;       323 &#160;            }       324 &#160;        328  &#160;             inline  std::ios_base &  time (std::ios_base & ios)       329 &#160;            {       330 &#160;                 ios_info::get (ios). display_flags (flags::time);       331 &#160;                 return  ios;       332 &#160;            }       333 &#160;        337  &#160;             inline  std::ios_base &  datetime (std::ios_base & ios)       338 &#160;            {       339 &#160;                 ios_info::get (ios). display_flags (flags::datetime);       340 &#160;                 return  ios;       341 &#160;            }       342 &#160;        347  &#160;             inline  std::ios_base &  strftime (std::ios_base & ios)       348 &#160;            {       349 &#160;                 ios_info::get (ios). display_flags (flags::strftime);       350 &#160;                 return  ios;       351 &#160;            }       352 &#160;        356  &#160;             inline  std::ios_base &  spellout (std::ios_base & ios)       357 &#160;            {       358 &#160;                 ios_info::get (ios). display_flags (flags::spellout);       359 &#160;                 return  ios;       360 &#160;            }       361 &#160;        365  &#160;             inline  std::ios_base &  ordinal (std::ios_base & ios)       366 &#160;            {       367 &#160;                 ios_info::get (ios). display_flags (flags::ordinal);       368 &#160;                 return  ios;       369 &#160;            }       370 &#160;        374  &#160;             inline  std::ios_base &  currency_default (std::ios_base & ios)       375 &#160;            {       376 &#160;                 ios_info::get (ios). currency_flags (flags::currency_default);       377 &#160;                 return  ios;       378 &#160;            }       379 &#160;        383  &#160;             inline  std::ios_base &  currency_iso (std::ios_base & ios)       384 &#160;            {       385 &#160;                 ios_info::get (ios). currency_flags (flags::currency_iso);       386 &#160;                 return  ios;       387 &#160;            }       388 &#160;        392  &#160;             inline  std::ios_base &  currency_national (std::ios_base & ios)       393 &#160;            {       394 &#160;                 ios_info::get (ios). currency_flags (flags::currency_national);       395 &#160;                 return  ios;       396 &#160;            }       397 &#160;        401  &#160;             inline  std::ios_base &  time_default (std::ios_base & ios)       402 &#160;            {       403 &#160;                 ios_info::get (ios). time_flags (flags::time_default);       404 &#160;                 return  ios;       405 &#160;            }       406 &#160;        410  &#160;             inline  std::ios_base &  time_short (std::ios_base & ios)       411 &#160;            {       412 &#160;                 ios_info::get (ios). time_flags (flags::time_short);       413 &#160;                 return  ios;       414 &#160;            }       415 &#160;        419  &#160;             inline  std::ios_base &  time_medium (std::ios_base & ios)       420 &#160;            {       421 &#160;                 ios_info::get (ios). time_flags (flags::time_medium);       422 &#160;                 return  ios;       423 &#160;            }       424 &#160;        428  &#160;             inline  std::ios_base &  time_long (std::ios_base & ios)       429 &#160;            {       430 &#160;                 ios_info::get (ios). time_flags (flags::time_long);       431 &#160;                 return  ios;       432 &#160;            }       433 &#160;        437  &#160;             inline  std::ios_base &  time_full (std::ios_base & ios)       438 &#160;            {       439 &#160;                 ios_info::get (ios). time_flags (flags::time_full);       440 &#160;                 return  ios;       441 &#160;            }       442 &#160;        446  &#160;             inline  std::ios_base &  date_default (std::ios_base & ios)       447 &#160;            {       448 &#160;                 ios_info::get (ios). date_flags (flags::date_default);       449 &#160;                 return  ios;       450 &#160;            }       451 &#160;        455  &#160;             inline  std::ios_base &  date_short (std::ios_base & ios)       456 &#160;            {       457 &#160;                 ios_info::get (ios). date_flags (flags::date_short);       458 &#160;                 return  ios;       459 &#160;            }       460 &#160;        464  &#160;             inline  std::ios_base &  date_medium (std::ios_base & ios)       465 &#160;            {       466 &#160;                 ios_info::get (ios). date_flags (flags::date_medium);       467 &#160;                 return  ios;       468 &#160;            }       469 &#160;        473  &#160;             inline  std::ios_base &  date_long (std::ios_base & ios)       474 &#160;            {       475 &#160;                 ios_info::get (ios). date_flags (flags::date_long);       476 &#160;                 return  ios;       477 &#160;            }       478 &#160;        482  &#160;             inline  std::ios_base &  date_full (std::ios_base & ios)       483 &#160;            {       484 &#160;                 ios_info::get (ios). date_flags (flags::date_full);       485 &#160;                 return  ios;       486 &#160;            }       487 &#160;       488 &#160;       490 &#160;             namespace  details {       491 &#160;                 template < typename  CharType>       492 &#160;                 struct  add_ftime {       493 &#160;       494 &#160;                    std::basic_string<CharType>  ftime ;       495 &#160;       496 &#160;                     void  apply(std::basic_ios<CharType> &ios)  const        497 &#160;                      {       498 &#160;                         ios_info::get (ios). date_time_pattern ( ftime );       499 &#160;                         as::strftime (ios);       500 &#160;                    }       501 &#160;       502 &#160;                };       503 &#160;       504 &#160;                 template < typename  CharType>       505 &#160;                std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out,add_ftime<CharType>  const  &fmt)       506 &#160;                {       507 &#160;                    fmt.apply(out);       508 &#160;                     return  out;       509 &#160;                }       510 &#160;       511 &#160;                 template < typename  CharType>       512 &#160;                std::basic_istream<CharType> & operator>> (std::basic_istream<CharType> &in,add_ftime<CharType>  const  &fmt)       513 &#160;                {       514 &#160;                    fmt.apply(in);       515 &#160;                     return  in;       516 &#160;                }       517 &#160;       518 &#160;            }       520 &#160;       555 &#160;       556 &#160;       557 &#160;             template < typename  CharType>       558 &#160;             #ifdef BOOST_LOCALE_DOXYGEN        559 &#160;            unspecified_type       560 &#160;             #else        561 &#160;            details::add_ftime<CharType>       562 &#160;             #endif         563  &#160;             ftime (std::basic_string<CharType>  const  & format )       564 &#160;            {       565 &#160;                details::add_ftime<CharType> fmt;       566 &#160;                fmt.ftime= format ;       567 &#160;                 return  fmt;       568 &#160;            }       569 &#160;       573 &#160;             template < typename  CharType>       574 &#160;             #ifdef BOOST_LOCALE_DOXYGEN        575 &#160;            unspecified_type       576 &#160;             #else        577 &#160;            details::add_ftime<CharType>       578 &#160;             #endif         579  &#160;             ftime (CharType  const  * format )       580 &#160;            {       581 &#160;                details::add_ftime<CharType> fmt;       582 &#160;                fmt.ftime= format ;       583 &#160;                 return  fmt;       584 &#160;            }       585 &#160;       587 &#160;             namespace  details {       588 &#160;                 struct  set_timezone {       589 &#160;                    std::string id;       590 &#160;                };       591 &#160;                 template < typename  CharType>       592 &#160;                std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out,set_timezone  const  &fmt)       593 &#160;                {       594 &#160;                     ios_info::get (out). time_zone (fmt.id);       595 &#160;                     return  out;       596 &#160;                }       597 &#160;       598 &#160;                 template < typename  CharType>       599 &#160;                std::basic_istream<CharType> & operator>> (std::basic_istream<CharType> &in,set_timezone  const  &fmt)       600 &#160;                {       601 &#160;                     ios_info::get (in). time_zone (fmt.id);       602 &#160;                     return  in;       603 &#160;                }       604 &#160;            }       606 &#160;        610  &#160;             inline  std::ios_base & gmt (std::ios_base &ios)       611 &#160;            {       612 &#160;                 ios_info::get (ios). time_zone ( &quot;GMT&quot; );       613 &#160;                 return  ios;       614 &#160;            }       615 &#160;        619  &#160;             inline  std::ios_base & local_time (std::ios_base &ios)       620 &#160;            {       621 &#160;                 ios_info::get (ios). time_zone ( time_zone::global ());       622 &#160;                 return  ios;       623 &#160;            }       624 &#160;       628 &#160;             inline        629 &#160;             #ifdef BOOST_LOCALE_DOXYGEN        630 &#160;            unspecified_type       631 &#160;             #else        632 &#160;            details::set_timezone       633 &#160;             #endif         634  &#160;             time_zone ( char   const  * id )       635 &#160;            {       636 &#160;                details::set_timezone tz;       637 &#160;                tz.id=id;       638 &#160;                 return  tz;       639 &#160;            }       640 &#160;       644 &#160;             inline        645 &#160;             #ifdef BOOST_LOCALE_DOXYGEN        646 &#160;            unspecified_type       647 &#160;             #else        648 &#160;            details::set_timezone       649 &#160;             #endif         650  &#160;             time_zone (std::string  const  & id )       651 &#160;            {       652 &#160;                details::set_timezone tz;       653 &#160;                tz.id=id;       654 &#160;                 return  tz;       655 &#160;            }       656 &#160;       657 &#160;       661 &#160;       662 &#160;        }  // as manipulators        663 &#160;       664 &#160;    }  // locale        665 &#160;}  // boost        666 &#160;       667 &#160; #ifdef BOOST_MSVC        668 &#160; #pragma warning(pop)        669 &#160; #endif        670 &#160;       671 &#160;       672 &#160; #endif     boost::locale::basic_format   a printf like class that allows type-safe and locale aware message formatting   Definition:  format.hpp:204     boost::locale::as::date_long   std::ios_base & date_long(std::ios_base &ios)   Definition:  formatting.hpp:473     boost::locale::as::time_zone   unspecified_type time_zone(std::string const &id)   Definition:  formatting.hpp:650     boost::locale::as::time_default   std::ios_base & time_default(std::ios_base &ios)   Definition:  formatting.hpp:401     boost::locale::time_zone::global   std::string global()     boost::locale::as::strftime   std::ios_base & strftime(std::ios_base &ios)   Definition:  formatting.hpp:347     boost::locale::as::date_medium   std::ios_base & date_medium(std::ios_base &ios)   Definition:  formatting.hpp:464     boost::locale::as::currency   std::ios_base & currency(std::ios_base &ios)   Definition:  formatting.hpp:301     boost::locale::as::time_full   std::ios_base & time_full(std::ios_base &ios)   Definition:  formatting.hpp:437     boost::locale::as::time_zone   unspecified_type time_zone(char const *id)   Definition:  formatting.hpp:634     boost::locale::as::ordinal   std::ios_base & ordinal(std::ios_base &ios)   Definition:  formatting.hpp:365     boost::locale::as::ftime   unspecified_type ftime(std::basic_string< CharType > const &format)   Definition:  formatting.hpp:563     boost::locale::as::date_full   std::ios_base & date_full(std::ios_base &ios)   Definition:  formatting.hpp:482     boost::locale::as::posix   std::ios_base & posix(std::ios_base &ios)   Definition:  formatting.hpp:282     boost::locale::as::currency_default   std::ios_base & currency_default(std::ios_base &ios)   Definition:  formatting.hpp:374     boost::locale::as::time_medium   std::ios_base & time_medium(std::ios_base &ios)   Definition:  formatting.hpp:419     boost::locale::ios_info::date_flags   void date_flags(uint64_t flags)     boost::locale::as::time_long   std::ios_base & time_long(std::ios_base &ios)   Definition:  formatting.hpp:428     boost::locale::as::gmt   std::ios_base & gmt(std::ios_base &ios)   Definition:  formatting.hpp:610     boost::locale::flags::display_flags_type   display_flags_type   Definition:  formatting.hpp:35     boost::locale::as::number   std::ios_base & number(std::ios_base &ios)   Definition:  formatting.hpp:292     boost::locale::as::percent   std::ios_base & percent(std::ios_base &ios)   Definition:  formatting.hpp:310     boost::locale::as::spellout   std::ios_base & spellout(std::ios_base &ios)   Definition:  formatting.hpp:356     boost::locale::as::currency_national   std::ios_base & currency_national(std::ios_base &ios)   Definition:  formatting.hpp:392     boost::locale::flags::time_zone_id   time zone name   Definition:  formatting.hpp:79     boost::locale::as::date   std::ios_base & date(std::ios_base &ios)   Definition:  formatting.hpp:319     boost::locale::ios_info::display_flags   void display_flags(uint64_t flags)     boost::locale::ios_info::get   static ios_info & get(std::ios_base &ios)     boost::locale::ios_info   This class holds an external data - beyond existing fmtflags that std::ios_base holds.   Definition:  formatting.hpp:98     boost::locale::flags::datetime_pattern   strftime like formatting   Definition:  formatting.hpp:78     boost::locale::ios_info::time_flags   void time_flags(uint64_t flags)     boost::locale::as::date_default   std::ios_base & date_default(std::ios_base &ios)   Definition:  formatting.hpp:446     boost::locale::as::datetime   std::ios_base & datetime(std::ios_base &ios)   Definition:  formatting.hpp:337     boost::locale::ios_info::time_zone   void time_zone(std::string const &)     boost::locale::as::time_short   std::ios_base & time_short(std::ios_base &ios)   Definition:  formatting.hpp:410     boost::locale::operator<<   std::basic_ostream< CharType > & operator<<(std::basic_ostream< CharType > &out, date_time const &t)   Definition:  date_time.hpp:871     boost::locale::as::date_short   std::ios_base & date_short(std::ios_base &ios)   Definition:  formatting.hpp:455     boost::locale::as::local_time   std::ios_base & local_time(std::ios_base &ios)   Definition:  formatting.hpp:619     boost::locale::operator>>   std::basic_istream< CharType > & operator>>(std::basic_istream< CharType > &in, date_time &t)   Definition:  date_time.hpp:898     boost::locale::ios_info::date_time_pattern   std::basic_string< CharType > date_time_pattern() const   Definition:  formatting.hpp:202     boost::locale::format   basic_format< char > format   Definition:  format.hpp:469     boost::locale::as::time   std::ios_base & time(std::ios_base &ios)   Definition:  formatting.hpp:328     boost::locale::ios_info::currency_flags   void currency_flags(uint64_t flags)     boost::locale::flags::domain_id   Domain code - for message formatting.   Definition:  formatting.hpp:86     boost::locale::ios_info::date_time_pattern   void date_time_pattern(std::basic_string< CharType > const &str)   Definition:  formatting.hpp:155     boost::locale::flags::pattern_type   pattern_type   Definition:  formatting.hpp:77     boost::locale::flags::value_type   value_type   Definition:  formatting.hpp:85     boost::locale::as::currency_iso   std::ios_base & currency_iso(std::ios_base &ios)   Definition:  formatting.hpp:383             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('date__time__facet_8hpp_source.html','');});/* @license-end */       date_time_facet.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_DATE_TIME_FACET_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_DATE_TIME_FACET_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/cstdint.hpp>         12 &#160; #include <locale>         13 &#160;        14 &#160; #ifdef BOOST_MSVC         15 &#160; #  pragma warning(push)         16 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         17 &#160; #endif         18 &#160;        19 &#160; namespace  boost {        20 &#160;     namespace  locale {        24 &#160;         namespace  period {         28  &#160;             namespace  marks {         30  &#160;                 enum   period_mark  {         31  &#160;                     invalid ,                             32  &#160;                     era ,                                 33  &#160;                     year ,                                34  &#160;                     extended_year ,                       35  &#160;                     month ,                               36  &#160;                     day ,                                 37  &#160;                     day_of_year ,                         38  &#160;                     day_of_week ,                        39 &#160;                     day_of_week_in_month ,               44 &#160;                     day_of_week_local ,                   46  &#160;                     hour ,                                47  &#160;                     hour_12 ,                             48  &#160;                     am_pm ,                               49  &#160;                     minute ,                              50  &#160;                     second ,                              51  &#160;                     week_of_year ,                        52  &#160;                     week_of_month ,                       53  &#160;                     first_day_of_week ,                  54 &#160;                };        55 &#160;        56 &#160;            }  // marks         57 &#160;         69  &#160;             class   period_type  {        70 &#160;             public :         74  &#160;                 period_type ( marks::period_mark  m =  marks::invalid ) : mark_(m)        75 &#160;                {        76 &#160;                }        77 &#160;         81  &#160;                 marks::period_mark   mark ()  const         82 &#160;                  {        83 &#160;                     return  mark_;        84 &#160;                }        85 &#160;         89  &#160;                 bool   operator== ( period_type   const  &other)  const         90 &#160;                  {        91 &#160;                     return   mark ()==other. mark ();        92 &#160;                }         96  &#160;                 bool   operator!= ( period_type   const  &other)  const         97 &#160;                  {        98 &#160;                     return   mark ()!=other. mark ();        99 &#160;                }       100 &#160;             private :       101 &#160;                 marks::period_mark  mark_;       102 &#160;            };       103 &#160;       104 &#160;        }  // namespace period        105 &#160;        110  &#160;         struct   posix_time  {        111  &#160;            int64_t  seconds ;         112  &#160;            uint32_t  nanoseconds ;         113 &#160;        };       114 &#160;       120 &#160;        121  &#160;         class   abstract_calendar  {       122 &#160;         public :       123 &#160;        127  &#160;             typedef   enum  {        128  &#160;                 absolute_minimum ,           129  &#160;                 actual_minimum ,             130  &#160;                 greatest_minimum ,           131  &#160;                 current ,                    132  &#160;                 least_maximum ,             133 &#160;                 actual_maximum ,             135  &#160;                 absolute_maximum ,          136 &#160;            }  value_type ;       137 &#160;        141  &#160;             typedef   enum  {        142  &#160;                 move ,           143  &#160;                 roll ,          144 &#160;            }  update_type ;       145 &#160;        149  &#160;             typedef   enum  {        150  &#160;                 is_gregorian ,           151  &#160;                 is_dst                  152 &#160;            }  calendar_option_type ;       153 &#160;       157 &#160;             virtual   abstract_calendar  * clone ()  const  = 0;       158 &#160;       169 &#160;             virtual   void   set_value ( period::marks::period_mark  m, int  value) = 0;       170 &#160;       174 &#160;             virtual   void   normalize () = 0;       175 &#160;       179 &#160;             virtual   int   get_value ( period::marks::period_mark  m, value_type  v)  const  = 0;       180 &#160;       184 &#160;             virtual   void   set_time ( posix_time   const  &p)  = 0;       188 &#160;             virtual   posix_time   get_time ()  const   = 0;       189 &#160;       193 &#160;             virtual   void   set_option ( calendar_option_type  opt, int  v) = 0;       197 &#160;             virtual   int   get_option ( calendar_option_type  opt)  const  = 0;       198 &#160;       203 &#160;             virtual   void   adjust_value ( period::marks::period_mark  m, update_type  u, int   difference ) = 0;       204 &#160;       208 &#160;             virtual   int   difference ( abstract_calendar   const  *other, period::marks::period_mark  m)  const  = 0;       209 &#160;       213 &#160;             virtual   void   set_timezone (std::string  const  &tz) = 0;       217 &#160;             virtual  std::string  get_timezone ()  const  = 0;       218 &#160;       222 &#160;             virtual   bool   same ( abstract_calendar   const  *other)  const  = 0;       223 &#160;       224 &#160;             virtual  ~ abstract_calendar () {}       225 &#160;        };       226 &#160;        230  &#160;         class  BOOST_LOCALE_DECL  calendar_facet  :  public  std::locale::facet {       231 &#160;         public :        235  &#160;             calendar_facet ( size_t  refs = 0) : std::locale::facet(refs)       236 &#160;            {       237 &#160;            }       241 &#160;             virtual   abstract_calendar  *create_calendar()  const  = 0;       242 &#160;        246  &#160;             static  std::locale::id  id ;       247 &#160;        };       248 &#160;       249 &#160;    }  // locale        250 &#160;}  // boost        251 &#160;       252 &#160; #ifdef BOOST_MSVC        253 &#160; #pragma warning(pop)        254 &#160; #endif        255 &#160;       256 &#160;       257 &#160; #endif        258 &#160;    boost::locale::period::marks::period_mark   period_mark  the type that defines a flag that holds a period identifier   Definition:  date_time_facet.hpp:30     boost::locale::period::period_type::operator==   bool operator==(period_type const &other) const   Definition:  date_time_facet.hpp:89     boost::locale::period::marks::week_of_month   The week number within current month.   Definition:  date_time_facet.hpp:52     boost::locale::abstract_calendar::same   virtual bool same(abstract_calendar const *other) const =0     boost::locale::period::marks::day_of_week_in_month    Definition:  date_time_facet.hpp:43     boost::locale::calendar_facet   the facet that generates calendar for specific locale   Definition:  date_time_facet.hpp:230     boost::locale::abstract_calendar::is_dst   Check if the current time is in daylight time savings.   Definition:  date_time_facet.hpp:151     boost::locale::period::period_type::operator!=   bool operator!=(period_type const &other) const   Definition:  date_time_facet.hpp:96     boost::locale::period::period_type::mark   marks::period_mark mark() const   Definition:  date_time_facet.hpp:81     boost::locale::period::marks::day_of_week    Definition:  date_time_facet.hpp:38     boost::locale::period::marks::year   Year, it is calendar specific, for example 2011 in Gregorian calendar.   Definition:  date_time_facet.hpp:33     boost::locale::calendar_facet::calendar_facet   calendar_facet(size_t refs=0)   Definition:  date_time_facet.hpp:235     boost::locale::abstract_calendar::least_maximum    Definition:  date_time_facet.hpp:132     boost::locale::abstract_calendar::actual_minimum   Actual minimal value for this period.   Definition:  date_time_facet.hpp:129     boost::locale::abstract_calendar::get_option   virtual int get_option(calendar_option_type opt) const =0     boost::locale::abstract_calendar::actual_maximum   Actual maximum, for it can be 28, 29, 30, 31 for day according to current month.   Definition:  date_time_facet.hpp:134     boost::locale::posix_time::seconds   int64_t seconds  Seconds since epoch.   Definition:  date_time_facet.hpp:111     boost::locale::period::marks::day_of_year   The number of day in year, starting from 1, in Gregorian [1..366].   Definition:  date_time_facet.hpp:37     boost::locale::abstract_calendar::is_gregorian   Check if the calendar is Gregorian.   Definition:  date_time_facet.hpp:150     boost::locale::abstract_calendar::adjust_value   virtual void adjust_value(period::marks::period_mark m, update_type u, int difference)=0     boost::locale::abstract_calendar::calendar_option_type   calendar_option_type   Definition:  date_time_facet.hpp:149     boost::locale::abstract_calendar::set_timezone   virtual void set_timezone(std::string const &tz)=0     boost::locale::posix_time::nanoseconds   uint32_t nanoseconds  Nanoseconds resolution.   Definition:  date_time_facet.hpp:112     boost::locale::abstract_calendar::get_value   virtual int get_value(period::marks::period_mark m, value_type v) const =0     boost::locale::abstract_calendar::move   Change the value up or down effecting others for example 1990-12-31 + 1 day = 1991-01-01.   Definition:  date_time_facet.hpp:142     boost::locale::abstract_calendar::difference   virtual int difference(abstract_calendar const *other, period::marks::period_mark m) const =0     boost::locale::abstract_calendar    Definition:  date_time_facet.hpp:121     boost::locale::period::marks::week_of_year   The week number in the year.   Definition:  date_time_facet.hpp:51     boost::locale::period::marks::hour   24 clock hour [0..23]   Definition:  date_time_facet.hpp:46     boost::locale::period::marks::invalid   Special invalid value, should not be used directly.   Definition:  date_time_facet.hpp:31     boost::locale::posix_time    Definition:  date_time_facet.hpp:110     boost::locale::period::marks::day   The day of month, calendar specific, in Gregorian [1..31].   Definition:  date_time_facet.hpp:36     boost::locale::period::marks::minute   minute [0..59]   Definition:  date_time_facet.hpp:49     boost::locale::abstract_calendar::absolute_minimum   Absolute possible minimum for the value, for example for day is 1.   Definition:  date_time_facet.hpp:128     boost::locale::abstract_calendar::update_type   update_type   Definition:  date_time_facet.hpp:141     boost::locale::period::marks::month   The month of year, calendar specific, in Gregorian [0..11].   Definition:  date_time_facet.hpp:35     boost::locale::period::marks::day_of_week_local   Local day of week, for example in France Monday is 1, in US Sunday is 1, [1..7].   Definition:  date_time_facet.hpp:45     boost::locale::abstract_calendar::get_time   virtual posix_time get_time() const =0     boost::locale::period::marks::hour_12   12 clock hour [0..11]   Definition:  date_time_facet.hpp:47     boost::locale::abstract_calendar::set_option   virtual void set_option(calendar_option_type opt, int v)=0     boost::locale::period::marks::am_pm   am or pm marker [0..1]   Definition:  date_time_facet.hpp:48     boost::locale::abstract_calendar::absolute_maximum   Maximal value, for Gregorian day it would be 31.   Definition:  date_time_facet.hpp:135     boost::locale::abstract_calendar::normalize   virtual void normalize()=0     boost::locale::abstract_calendar::set_time   virtual void set_time(posix_time const &p)=0     boost::locale::abstract_calendar::value_type   value_type   Definition:  date_time_facet.hpp:127     boost::locale::abstract_calendar::get_timezone   virtual std::string get_timezone() const =0     boost::locale::calendar_facet::id   static std::locale::id id   Definition:  date_time_facet.hpp:246     boost::locale::period::marks::era   Era i.e. AC, BC in Gregorian and Julian calendar, range [0,1].   Definition:  date_time_facet.hpp:32     boost::locale::abstract_calendar::roll   Change the value up or down not effecting others for example 1990-12-31 + 1 day = 1990-12-01.   Definition:  date_time_facet.hpp:143     boost::locale::period::marks::first_day_of_week   First day of week, constant, for example Sunday in US = 1, Monday in France = 2.   Definition:  date_time_facet.hpp:53     boost::locale::period::marks::extended_year   Extended year for Gregorian/Julian calendars, where 1 BC == 0, 2 BC == -1.   Definition:  date_time_facet.hpp:34     boost::locale::abstract_calendar::current   Current value of this period.   Definition:  date_time_facet.hpp:131     boost::locale::abstract_calendar::greatest_minimum   Maximal minimum value that can be for this period.   Definition:  date_time_facet.hpp:130     boost::locale::period::marks::second   second [0..59]   Definition:  date_time_facet.hpp:50     boost::locale::abstract_calendar::clone   virtual abstract_calendar * clone() const =0     boost::locale::period::period_type::period_type   period_type(marks::period_mark m=marks::invalid)   Definition:  date_time_facet.hpp:74     boost::locale::abstract_calendar::set_value   virtual void set_value(period::marks::period_mark m, int value)=0     boost::locale::period::period_type   This class holds a type that represents certain period of time like year, hour, second and so on.   Definition:  date_time_facet.hpp:69             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('utf_8hpp_source.html','');});/* @license-end */       utf.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_UTF_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_UTF_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/cstdint.hpp>         12 &#160;        13 &#160; namespace  boost {        14 &#160; namespace  locale {         20  &#160; namespace  utf {        22 &#160;     #ifdef __GNUC__         23 &#160;     #   define BOOST_LOCALE_LIKELY(x)   __builtin_expect((x),1)         24 &#160;     #   define BOOST_LOCALE_UNLIKELY(x) __builtin_expect((x),0)         25 &#160;     #else         26 &#160;     #   define BOOST_LOCALE_LIKELY(x)   (x)         27 &#160;     #   define BOOST_LOCALE_UNLIKELY(x) (x)         28 &#160;     #endif         29 &#160;         34  &#160;     typedef  uint32_t  code_point ;        35 &#160;         39  &#160;     static   const   code_point   illegal  = 0xFFFFFFFFu;        40 &#160;         44  &#160;     static   const   code_point   incomplete  = 0xFFFFFFFEu;        45 &#160;         49  &#160;     inline   bool   is_valid_codepoint ( code_point  v)        50 &#160;    {        51 &#160;         if (v>0x10FFFF)        52 &#160;             return   false ;        53 &#160;         if (0xD800 <=v && v<= 0xDFFF)  // surrogates         54 &#160;             return   false ;        55 &#160;         return   true ;        56 &#160;    }        57 &#160;        58 &#160;     #ifdef BOOST_LOCALE_DOXYGEN         59 &#160;     template < typename  CharType, int  size=sizeof(CharType)>         63  &#160;     struct   utf_traits  {         67  &#160;         typedef  CharType  char_type ;        82 &#160;         template < typename  Iterator>        83 &#160;         static   code_point   decode (Iterator &p,Iterator e);        84 &#160;         92  &#160;         static   const   int   max_width ;        99 &#160;         static   int   width ( code_point  value);       100 &#160;       106 &#160;         static   int   trail_length ( char_type  c);       110 &#160;         static   bool   is_trail ( char_type  c);       114 &#160;         static   bool   is_lead ( char_type  c);       115 &#160;       126 &#160;         template < typename  Iterator>       127 &#160;         static  Iterator  encode ( code_point  value,Iterator out);       133 &#160;         template < typename  Iterator>       134 &#160;         static   code_point   decode_valid (Iterator &p);       135 &#160;    };       136 &#160;       137 &#160;     #else        138 &#160;       139 &#160;     template < typename  CharType, int  size=sizeof(CharType)>       140 &#160;     struct   utf_traits ;       141 &#160;       142 &#160;     template < typename  CharType>       143 &#160;     struct   utf_traits <CharType,1> {       144 &#160;       145 &#160;         typedef  CharType  char_type ;       146 &#160;       147 &#160;         static   int   trail_length ( char_type  ci)       148 &#160;        {       149 &#160;             unsigned   char  c = ci;       150 &#160;             if (c < 128)       151 &#160;                 return  0;       152 &#160;             if (BOOST_LOCALE_UNLIKELY(c < 194))       153 &#160;                 return  -1;       154 &#160;             if (c < 224)       155 &#160;                 return  1;       156 &#160;             if (c < 240)       157 &#160;                 return  2;       158 &#160;             if (BOOST_LOCALE_LIKELY(c <=244))       159 &#160;                 return  3;       160 &#160;             return  -1;       161 &#160;        }       162 &#160;       163 &#160;         static   const   int   max_width  = 4;       164 &#160;       165 &#160;         static   int   width ( code_point  value)       166 &#160;        {       167 &#160;             if (value <=0x7F) {       168 &#160;                 return  1;       169 &#160;            }       170 &#160;             else   if (value <=0x7FF) {       171 &#160;                 return  2;       172 &#160;            }       173 &#160;             else   if (BOOST_LOCALE_LIKELY(value <=0xFFFF)) {       174 &#160;                 return  3;       175 &#160;            }       176 &#160;             else  {       177 &#160;                 return  4;       178 &#160;            }       179 &#160;        }       180 &#160;       181 &#160;         static   bool   is_trail ( char_type  ci)       182 &#160;        {       183 &#160;             unsigned   char  c=ci;       184 &#160;             return  (c & 0xC0)==0x80;       185 &#160;        }       186 &#160;       187 &#160;         static   bool   is_lead ( char_type  ci)       188 &#160;        {       189 &#160;             return  ! is_trail (ci);       190 &#160;        }       191 &#160;       192 &#160;         template < typename  Iterator>       193 &#160;         static   code_point   decode (Iterator &p,Iterator e)       194 &#160;        {       195 &#160;             if (BOOST_LOCALE_UNLIKELY(p==e))       196 &#160;                 return   incomplete ;       197 &#160;       198 &#160;             unsigned   char  lead = *p++;       199 &#160;       200 &#160;             // First byte is fully validated here        201 &#160;             int  trail_size =  trail_length (lead);       202 &#160;       203 &#160;             if (BOOST_LOCALE_UNLIKELY(trail_size < 0))       204 &#160;                 return   illegal ;       205 &#160;       206 &#160;             //        207 &#160;             // Ok as only ASCII may be of size = 0        208 &#160;             // also optimize for ASCII text        209 &#160;             //        210 &#160;             if (trail_size == 0)       211 &#160;                 return  lead;       212 &#160;       213 &#160;             code_point  c = lead & ((1 << (6-trail_size))-1);       214 &#160;       215 &#160;             // Read the rest        216 &#160;             unsigned   char  tmp;       217 &#160;             switch (trail_size) {       218 &#160;             case  3:       219 &#160;                 if (BOOST_LOCALE_UNLIKELY(p==e))       220 &#160;                     return   incomplete ;       221 &#160;                tmp = *p++;       222 &#160;                 if  (! is_trail (tmp))       223 &#160;                     return   illegal ;       224 &#160;                c = (c << 6) | ( tmp & 0x3F);       225 &#160;                BOOST_FALLTHROUGH;       226 &#160;             case  2:       227 &#160;                 if (BOOST_LOCALE_UNLIKELY(p==e))       228 &#160;                     return   incomplete ;       229 &#160;                tmp = *p++;       230 &#160;                 if  (! is_trail (tmp))       231 &#160;                     return   illegal ;       232 &#160;                c = (c << 6) | ( tmp & 0x3F);       233 &#160;                BOOST_FALLTHROUGH;       234 &#160;             case  1:       235 &#160;                 if (BOOST_LOCALE_UNLIKELY(p==e))       236 &#160;                     return   incomplete ;       237 &#160;                tmp = *p++;       238 &#160;                 if  (! is_trail (tmp))       239 &#160;                     return   illegal ;       240 &#160;                c = (c << 6) | ( tmp & 0x3F);       241 &#160;            }       242 &#160;       243 &#160;             // Check code point validity: no surrogates and        244 &#160;             // valid range        245 &#160;             if (BOOST_LOCALE_UNLIKELY(! is_valid_codepoint (c)))       246 &#160;                 return   illegal ;       247 &#160;       248 &#160;             // make sure it is the most compact representation        249 &#160;             if (BOOST_LOCALE_UNLIKELY( width (c)!=trail_size + 1))       250 &#160;                 return   illegal ;       251 &#160;       252 &#160;             return  c;       253 &#160;       254 &#160;        }       255 &#160;       256 &#160;         template < typename  Iterator>       257 &#160;         static   code_point   decode_valid (Iterator &p)       258 &#160;        {       259 &#160;             unsigned   char  lead = *p++;       260 &#160;             if (lead < 192)       261 &#160;                 return  lead;       262 &#160;       263 &#160;             int  trail_size;       264 &#160;       265 &#160;             if (lead < 224)       266 &#160;                trail_size = 1;       267 &#160;             else   if (BOOST_LOCALE_LIKELY(lead < 240))  // non-BMP rare        268 &#160;                trail_size = 2;       269 &#160;             else        270 &#160;                trail_size = 3;       271 &#160;       272 &#160;             code_point  c = lead & ((1 << (6-trail_size))-1);       273 &#160;       274 &#160;             switch (trail_size) {       275 &#160;             case  3:       276 &#160;                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);       277 &#160;                BOOST_FALLTHROUGH;       278 &#160;             case  2:       279 &#160;                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);       280 &#160;                BOOST_FALLTHROUGH;       281 &#160;             case  1:       282 &#160;                c = (c << 6) | ( static_cast<unsigned char>(*p++) & 0x3F);       283 &#160;            }       284 &#160;       285 &#160;             return  c;       286 &#160;        }       287 &#160;       288 &#160;       289 &#160;       290 &#160;         template < typename  Iterator>       291 &#160;         static  Iterator  encode ( code_point  value,Iterator out)       292 &#160;        {       293 &#160;             if (value <= 0x7F) {       294 &#160;                *out++ = static_cast<char_type>(value);       295 &#160;            }       296 &#160;             else   if (value <= 0x7FF) {       297 &#160;                *out++ = static_cast<char_type>((value >> 6) | 0xC0);       298 &#160;                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       299 &#160;            }       300 &#160;             else   if (BOOST_LOCALE_LIKELY(value <= 0xFFFF)) {       301 &#160;                *out++ = static_cast<char_type>((value >> 12) | 0xE0);       302 &#160;                *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);       303 &#160;                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       304 &#160;            }       305 &#160;             else  {       306 &#160;                *out++ = static_cast<char_type>((value >> 18) | 0xF0);       307 &#160;                *out++ = static_cast<char_type>(((value >> 12) & 0x3F) | 0x80);       308 &#160;                *out++ = static_cast<char_type>(((value >> 6) & 0x3F) | 0x80);       309 &#160;                *out++ = static_cast<char_type>((value & 0x3F) | 0x80);       310 &#160;            }       311 &#160;             return  out;       312 &#160;        }       313 &#160;    };  // utf8        314 &#160;       315 &#160;     template < typename  CharType>       316 &#160;     struct  utf_traits<CharType,2> {       317 &#160;         typedef  CharType  char_type ;       318 &#160;       319 &#160;         // See RFC 2781        320 &#160;         static   bool  is_first_surrogate(uint16_t x)       321 &#160;        {       322 &#160;             return  0xD800 <=x && x<= 0xDBFF;       323 &#160;        }       324 &#160;         static   bool  is_second_surrogate(uint16_t x)       325 &#160;        {       326 &#160;             return  0xDC00 <=x && x<= 0xDFFF;       327 &#160;        }       328 &#160;         static   code_point  combine_surrogate(uint16_t w1,uint16_t w2)       329 &#160;        {       330 &#160;             return  (( code_point (w1 & 0x3FF) << 10) | (w2 & 0x3FF)) + 0x10000;       331 &#160;        }       332 &#160;         static   int   trail_length ( char_type  c)       333 &#160;        {       334 &#160;             if (is_first_surrogate(c))       335 &#160;                 return  1;       336 &#160;             if (is_second_surrogate(c))       337 &#160;                 return  -1;       338 &#160;             return  0;       339 &#160;        }       343 &#160;         static   bool   is_trail ( char_type  c)       344 &#160;        {       345 &#160;             return  is_second_surrogate(c);       346 &#160;        }       350 &#160;         static   bool   is_lead ( char_type  c)       351 &#160;        {       352 &#160;             return  !is_second_surrogate(c);       353 &#160;        }       354 &#160;       355 &#160;         template < typename  It>       356 &#160;         static   code_point   decode (It &current,It last)       357 &#160;        {       358 &#160;             if (BOOST_LOCALE_UNLIKELY(current == last))       359 &#160;                 return   incomplete ;       360 &#160;            uint16_t w1=*current++;       361 &#160;             if (BOOST_LOCALE_LIKELY(w1 < 0xD800 || 0xDFFF < w1)) {       362 &#160;                 return  w1;       363 &#160;            }       364 &#160;             if (w1 > 0xDBFF)       365 &#160;                 return   illegal ;       366 &#160;             if (current==last)       367 &#160;                 return   incomplete ;       368 &#160;            uint16_t w2=*current++;       369 &#160;             if (w2 < 0xDC00 || 0xDFFF < w2)       370 &#160;                 return   illegal ;       371 &#160;             return  combine_surrogate(w1,w2);       372 &#160;        }       373 &#160;         template < typename  It>       374 &#160;         static   code_point   decode_valid (It &current)       375 &#160;        {       376 &#160;            uint16_t w1=*current++;       377 &#160;             if (BOOST_LOCALE_LIKELY(w1 < 0xD800 || 0xDFFF < w1)) {       378 &#160;                 return  w1;       379 &#160;            }       380 &#160;            uint16_t w2=*current++;       381 &#160;             return  combine_surrogate(w1,w2);       382 &#160;        }       383 &#160;       384 &#160;         static   const   int   max_width  = 2;       385 &#160;         static   int   width ( code_point  u)       386 &#160;        {       387 &#160;             return  u>=0x10000 ? 2 : 1;       388 &#160;        }       389 &#160;         template < typename  It>       390 &#160;         static  It  encode ( code_point  u,It out)       391 &#160;        {       392 &#160;             if (BOOST_LOCALE_LIKELY(u<=0xFFFF)) {       393 &#160;                *out++ = static_cast<char_type>(u);       394 &#160;            }       395 &#160;             else  {       396 &#160;                u -= 0x10000;       397 &#160;                *out++ = static_cast<char_type>(0xD800 | (u>>10));       398 &#160;                *out++ = static_cast<char_type>(0xDC00 | (u & 0x3FF));       399 &#160;            }       400 &#160;             return  out;       401 &#160;        }       402 &#160;    };  // utf16;        403 &#160;       404 &#160;       405 &#160;     template < typename  CharType>       406 &#160;     struct  utf_traits<CharType,4> {       407 &#160;         typedef  CharType  char_type ;       408 &#160;         static   int   trail_length ( char_type  c)       409 &#160;        {       410 &#160;             if ( is_valid_codepoint (c))       411 &#160;                 return  0;       412 &#160;             return  -1;       413 &#160;        }       414 &#160;         static   bool   is_trail ( char_type   /*c*/ )       415 &#160;        {       416 &#160;             return   false ;       417 &#160;        }       418 &#160;         static   bool   is_lead ( char_type   /*c*/ )       419 &#160;        {       420 &#160;             return   true ;       421 &#160;        }       422 &#160;       423 &#160;         template < typename  It>       424 &#160;         static   code_point   decode_valid (It &current)       425 &#160;        {       426 &#160;             return  *current++;       427 &#160;        }       428 &#160;       429 &#160;         template < typename  It>       430 &#160;         static   code_point   decode (It &current,It last)       431 &#160;        {       432 &#160;             if (BOOST_LOCALE_UNLIKELY(current == last))       433 &#160;                 return   boost::locale::utf::incomplete ;       434 &#160;             code_point  c=*current++;       435 &#160;             if (BOOST_LOCALE_UNLIKELY(! is_valid_codepoint (c)))       436 &#160;                 return   boost::locale::utf::illegal ;       437 &#160;             return  c;       438 &#160;        }       439 &#160;         static   const   int   max_width  = 1;       440 &#160;         static   int   width ( code_point   /*u*/ )       441 &#160;        {       442 &#160;             return  1;       443 &#160;        }       444 &#160;         template < typename  It>       445 &#160;         static  It  encode ( code_point  u,It out)       446 &#160;        {       447 &#160;            *out++ = static_cast<char_type>(u);       448 &#160;             return  out;       449 &#160;        }       450 &#160;       451 &#160;    };  // utf32        452 &#160;       453 &#160;     #endif        454 &#160;       455 &#160;       456 &#160;}  // utf        457 &#160;}  // locale        458 &#160;}  // boost        459 &#160;       460 &#160;       461 &#160; #endif        462 &#160;       463 &#160;    boost::locale::utf::utf_traits::decode   static code_point decode(Iterator &p, Iterator e)     boost::locale::utf::is_valid_codepoint   bool is_valid_codepoint(code_point v)  the function checks if v is a valid code point   Definition:  utf.hpp:49     boost::locale::utf::utf_traits::encode   static Iterator encode(code_point value, Iterator out)     boost::locale::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:44     boost::locale::utf::code_point   uint32_t code_point  The integral type that can hold a Unicode code point.   Definition:  utf.hpp:34     boost::locale::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:39     boost::locale::utf::utf_traits   UTF Traits class - functions to convert UTF sequences to and from Unicode code points.   Definition:  utf.hpp:63     boost::locale::utf::utf_traits::width   static int width(code_point value)     boost::locale::utf::utf_traits::char_type   CharType char_type   Definition:  utf.hpp:67     boost::locale::utf::utf_traits::trail_length   static int trail_length(char_type c)     boost::locale::utf::utf_traits::is_lead   static bool is_lead(char_type c)     boost::locale::utf::utf_traits::decode_valid   static code_point decode_valid(Iterator &p)     boost::locale::utf::utf_traits::is_trail   static bool is_trail(char_type c)     boost::locale::utf::utf_traits::max_width   static const int max_width   Definition:  utf.hpp:92             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('segment_8hpp_source.html','');});/* @license-end */       segment.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_SEGMENT_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_SEGMENT_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <iosfwd>         12 &#160; #include <iterator>         13 &#160; #include <locale>         14 &#160; #include <string>         15 &#160;        16 &#160; #ifdef BOOST_MSVC         17 &#160; #  pragma warning(push)         18 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         19 &#160; #endif         20 &#160;        21 &#160; namespace  boost {        22 &#160; namespace  locale {        23 &#160; namespace  boundary {        25 &#160;     namespace  details {        26 &#160;         template < typename  LeftIterator, typename  RightIterator>        27 &#160;         int  compare_text(LeftIterator l_begin,LeftIterator l_end,RightIterator r_begin,RightIterator r_end)        28 &#160;        {        29 &#160;             typedef  LeftIterator left_iterator;        30 &#160;             typedef   typename  std::iterator_traits<left_iterator>::value_type char_type;        31 &#160;             typedef  std::char_traits<char_type> traits;        32 &#160;             while (l_begin!=l_end && r_begin!=r_end) {        33 &#160;                char_type lchar = *l_begin++;        34 &#160;                char_type rchar = *r_begin++;        35 &#160;                 if (traits::eq(lchar,rchar))        36 &#160;                     continue ;        37 &#160;                 if (traits::lt(lchar,rchar))        38 &#160;                     return  -1;        39 &#160;                 else         40 &#160;                     return  1;        41 &#160;            }        42 &#160;             if (l_begin==l_end && r_begin==r_end)        43 &#160;                 return  0;        44 &#160;             if (l_begin==l_end)        45 &#160;                 return  -1;        46 &#160;             else         47 &#160;                 return  1;        48 &#160;        }        49 &#160;        50 &#160;        51 &#160;         template < typename  Left, typename  Right>        52 &#160;         int  compare_text(Left  const  &l,Right  const  &r)        53 &#160;        {        54 &#160;             return  compare_text(l.begin(),l.end(),r.begin(),r.end());        55 &#160;        }        56 &#160;        57 &#160;         template < typename  Left, typename  Char>        58 &#160;         int  compare_string(Left  const  &l,Char  const  *begin)        59 &#160;        {        60 &#160;            Char  const  *end = begin;        61 &#160;             while (*end!=0)        62 &#160;                end++;        63 &#160;             return  compare_text(l.begin(),l.end(),begin,end);        64 &#160;        }        65 &#160;        66 &#160;         template < typename  Right, typename  Char>        67 &#160;         int  compare_string(Char  const  *begin,Right  const  &r)        68 &#160;        {        69 &#160;            Char  const  *end = begin;        70 &#160;             while (*end!=0)        71 &#160;                end++;        72 &#160;             return  compare_text(begin,end,r.begin(),r.end());        73 &#160;        }        74 &#160;        75 &#160;    }        77 &#160;        81 &#160;       101 &#160;     template < typename  IteratorType>        102  &#160;     class   segment  :  public  std::pair<IteratorType,IteratorType> {       103 &#160;     public :        107  &#160;         typedef   typename  std::iterator_traits<IteratorType>::value_type  char_type ;        111  &#160;         typedef  std::basic_string<char_type>  string_type ;        115  &#160;         typedef   char_type   value_type ;        119  &#160;         typedef  IteratorType  iterator ;        123  &#160;         typedef  IteratorType  const_iterator ;        127  &#160;         typedef   typename  std::iterator_traits<IteratorType>::difference_type  difference_type ;       128 &#160;        132  &#160;         segment () {}        136  &#160;         segment ( iterator  b, iterator  e, rule_type  r) :       137 &#160;            std::pair<IteratorType,IteratorType>(b,e),       138 &#160;            rule_(r)       139 &#160;        {       140 &#160;        }        144  &#160;         void   begin ( iterator   const  &v)       145 &#160;        {       146 &#160;            this->first = v;       147 &#160;        }        151  &#160;          void   end ( iterator   const  &v)       152 &#160;        {       153 &#160;            this->second = v;       154 &#160;        }       155 &#160;        159  &#160;        IteratorType  begin ()  const        160 &#160;          {       161 &#160;             return  this->first;       162 &#160;        }        166  &#160;        IteratorType  end ()  const        167 &#160;          {       168 &#160;             return  this->second;       169 &#160;        }       170 &#160;       174 &#160;         template  < class  T,  class  A>        175  &#160;         operator  std::basic_string<char_type, T, A> () const        176 &#160;          {       177 &#160;             return  std::basic_string<char_type, T, A>(this->first, this->second);       178 &#160;        }       179 &#160;        183  &#160;         string_type   str ()  const        184 &#160;          {       185 &#160;             return   string_type ( begin (), end ());       186 &#160;        }       187 &#160;       191 &#160;        192  &#160;         size_t   length ()  const        193 &#160;          {       194 &#160;             return  std::distance( begin (), end ());       195 &#160;        }       196 &#160;        200  &#160;         bool   empty ()  const        201 &#160;          {       202 &#160;             return   begin () ==  end ();       203 &#160;        }       204 &#160;        208  &#160;         rule_type   rule ()  const        209 &#160;          {       210 &#160;             return  rule_;       211 &#160;        }        215  &#160;         void   rule ( rule_type  r)       216 &#160;        {       217 &#160;            rule_ = r;       218 &#160;        }       219 &#160;       220 &#160;         // make sure we override std::pair&#39;s operator==        221 &#160;        223  &#160;         bool   operator== ( segment   const  &other)  const        224 &#160;          {       225 &#160;             return  details::compare_text(* this ,other) == 0;       226 &#160;        }       227 &#160;        229  &#160;         bool   operator!= ( segment   const  &other)  const        230 &#160;          {       231 &#160;             return  details::compare_text(* this ,other) != 0;       232 &#160;        }       233 &#160;       234 &#160;     private :       235 &#160;         rule_type  rule_;       236 &#160;       237 &#160;    };       238 &#160;       239 &#160;       241 &#160;     template < typename  IteratorL, typename  IteratorR>        242  &#160;     bool   operator== ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       243 &#160;    {       244 &#160;         return  details::compare_text(l,r) == 0;       245 &#160;    }       247 &#160;     template < typename  IteratorL, typename  IteratorR>        248  &#160;     bool   operator!= ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       249 &#160;    {       250 &#160;         return  details::compare_text(l,r) != 0;       251 &#160;    }       252 &#160;       254 &#160;     template < typename  IteratorL, typename  IteratorR>        255  &#160;     bool   operator< ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       256 &#160;    {       257 &#160;         return  details::compare_text(l,r) < 0;       258 &#160;    }       260 &#160;     template < typename  IteratorL, typename  IteratorR>        261  &#160;     bool   operator<= ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       262 &#160;    {       263 &#160;         return  details::compare_text(l,r) <= 0;       264 &#160;    }       266 &#160;     template < typename  IteratorL, typename  IteratorR>        267  &#160;     bool   operator> ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       268 &#160;    {       269 &#160;         return  details::compare_text(l,r) > 0;       270 &#160;    }       272 &#160;     template < typename  IteratorL, typename  IteratorR>        273  &#160;     bool   operator>= ( segment<IteratorL>   const  &l, segment<IteratorR>   const  &r)       274 &#160;    {       275 &#160;         return  details::compare_text(l,r) >= 0;       276 &#160;    }       277 &#160;       279 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        280  &#160;     bool   operator== (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       281 &#160;    {       282 &#160;         return  details::compare_text(l,r) == 0;       283 &#160;    }       285 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        286  &#160;     bool   operator!= (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       287 &#160;    {       288 &#160;         return  details::compare_text(l,r) != 0;       289 &#160;    }       290 &#160;       292 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        293  &#160;     bool   operator< (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       294 &#160;    {       295 &#160;         return  details::compare_text(l,r) < 0;       296 &#160;    }       298 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        299  &#160;     bool   operator<= (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       300 &#160;    {       301 &#160;         return  details::compare_text(l,r) <= 0;       302 &#160;    }       304 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        305  &#160;     bool   operator> (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       306 &#160;    {       307 &#160;         return  details::compare_text(l,r) > 0;       308 &#160;    }       310 &#160;     template < typename  CharType, typename  Traits, typename  Alloc, typename  IteratorR>        311  &#160;     bool   operator>= (std::basic_string<CharType,Traits,Alloc>  const  &l, segment<IteratorR>   const  &r)       312 &#160;    {       313 &#160;         return  details::compare_text(l,r) >= 0;       314 &#160;    }       315 &#160;       317 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        318  &#160;     bool   operator== ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       319 &#160;    {       320 &#160;         return  details::compare_text(l,r) == 0;       321 &#160;    }       323 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        324  &#160;     bool   operator!= ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       325 &#160;    {       326 &#160;         return  details::compare_text(l,r) != 0;       327 &#160;    }       328 &#160;       330 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        331  &#160;     bool   operator< ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       332 &#160;    {       333 &#160;         return  details::compare_text(l,r) < 0;       334 &#160;    }       336 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        337  &#160;     bool   operator<= ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       338 &#160;    {       339 &#160;         return  details::compare_text(l,r) <= 0;       340 &#160;    }       342 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        343  &#160;     bool   operator> ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       344 &#160;    {       345 &#160;         return  details::compare_text(l,r) > 0;       346 &#160;    }       348 &#160;     template < typename  Iterator, typename  CharType, typename  Traits, typename  Alloc>        349  &#160;     bool   operator>= ( segment<Iterator>   const  &l,std::basic_string<CharType,Traits,Alloc>  const  &r)       350 &#160;    {       351 &#160;         return  details::compare_text(l,r) >= 0;       352 &#160;    }       353 &#160;       354 &#160;       356 &#160;     template < typename  CharType, typename  IteratorR>        357  &#160;     bool   operator== (CharType  const  *l, segment<IteratorR>   const  &r)       358 &#160;    {       359 &#160;         return  details::compare_string(l,r) == 0;       360 &#160;    }       362 &#160;     template < typename  CharType, typename  IteratorR>        363  &#160;     bool   operator!= (CharType  const  *l, segment<IteratorR>   const  &r)       364 &#160;    {       365 &#160;         return  details::compare_string(l,r) != 0;       366 &#160;    }       367 &#160;       369 &#160;     template < typename  CharType, typename  IteratorR>        370  &#160;     bool   operator< (CharType  const  *l, segment<IteratorR>   const  &r)       371 &#160;    {       372 &#160;         return  details::compare_string(l,r) < 0;       373 &#160;    }       375 &#160;     template < typename  CharType, typename  IteratorR>        376  &#160;     bool   operator<= (CharType  const  *l, segment<IteratorR>   const  &r)       377 &#160;    {       378 &#160;         return  details::compare_string(l,r) <= 0;       379 &#160;    }       381 &#160;     template < typename  CharType, typename  IteratorR>        382  &#160;     bool   operator> (CharType  const  *l, segment<IteratorR>   const  &r)       383 &#160;    {       384 &#160;         return  details::compare_string(l,r) > 0;       385 &#160;    }       387 &#160;     template < typename  CharType, typename  IteratorR>        388  &#160;     bool   operator>= (CharType  const  *l, segment<IteratorR>   const  &r)       389 &#160;    {       390 &#160;         return  details::compare_string(l,r) >= 0;       391 &#160;    }       392 &#160;       394 &#160;     template < typename  Iterator, typename  CharType>        395  &#160;     bool   operator== ( segment<Iterator>   const  &l,CharType  const  *r)       396 &#160;    {       397 &#160;         return  details::compare_string(l,r) == 0;       398 &#160;    }       400 &#160;     template < typename  Iterator, typename  CharType>        401  &#160;     bool   operator!= ( segment<Iterator>   const  &l,CharType  const  *r)       402 &#160;    {       403 &#160;         return  details::compare_string(l,r) != 0;       404 &#160;    }       405 &#160;       407 &#160;     template < typename  Iterator, typename  CharType>        408  &#160;     bool   operator< ( segment<Iterator>   const  &l,CharType  const  *r)       409 &#160;    {       410 &#160;         return  details::compare_string(l,r) < 0;       411 &#160;    }       413 &#160;     template < typename  Iterator, typename  CharType>        414  &#160;     bool   operator<= ( segment<Iterator>   const  &l,CharType  const  *r)       415 &#160;    {       416 &#160;         return  details::compare_string(l,r) <= 0;       417 &#160;    }       419 &#160;     template < typename  Iterator, typename  CharType>        420  &#160;     bool   operator> ( segment<Iterator>   const  &l,CharType  const  *r)       421 &#160;    {       422 &#160;         return  details::compare_string(l,r) > 0;       423 &#160;    }       425 &#160;     template < typename  Iterator, typename  CharType>        426  &#160;     bool   operator>= ( segment<Iterator>   const  &l,CharType  const  *r)       427 &#160;    {       428 &#160;         return  details::compare_string(l,r) >= 0;       429 &#160;    }       430 &#160;       431 &#160;       432 &#160;       433 &#160;       434 &#160;       435 &#160;        436  &#160;     typedef   segment<std::string::const_iterator>   ssegment ;              437  &#160;     typedef   segment<std::wstring::const_iterator>   wssegment ;           438 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR16_T         439  &#160;     typedef   segment<std::u16string::const_iterator>   u16ssegment ;       440 &#160;     #endif        441 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR32_T         442  &#160;     typedef   segment<std::u32string::const_iterator>   u32ssegment ;       443 &#160;     #endif        444 &#160;        445  &#160;     typedef   segment<char const *>   csegment ;                             446  &#160;     typedef   segment<wchar_t const *>   wcsegment ;                        447 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR16_T         448  &#160;     typedef   segment<char16_t const *>   u16csegment ;                     449 &#160;     #endif        450 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR32_T         451  &#160;     typedef   segment<char32_t const *>   u32csegment ;                     452 &#160;     #endif        453 &#160;       454 &#160;       455 &#160;       456 &#160;       457 &#160;       461 &#160;     template < typename  CharType, typename  TraitsType, typename  Iterator>        462  &#160;    std::basic_ostream<CharType,TraitsType> & operator<< (       463 &#160;            std::basic_ostream<CharType,TraitsType> &out,       464 &#160;             segment<Iterator>   const  &tok)       465 &#160;    {       466 &#160;         for (Iterator p=tok. begin (),e=tok. end ();p!=e;++p)       467 &#160;            out << *p;       468 &#160;         return  out;       469 &#160;    }       470 &#160;       472 &#160;       473 &#160;}  // boundary        474 &#160;}  // locale        475 &#160;}  // boost        476 &#160;       477 &#160; #ifdef BOOST_MSVC        478 &#160; #pragma warning(pop)        479 &#160; #endif        480 &#160;       481 &#160; #endif        482 &#160;    boost::locale::boundary::segment::end   IteratorType end() const   Definition:  segment.hpp:166     boost::locale::boundary::csegment   segment< char const * > csegment  convenience typedef   Definition:  segment.hpp:445     boost::locale::boundary::segment::operator==   bool operator==(segment const &other) const  Compare two segments.   Definition:  segment.hpp:223     boost::locale::boundary::segment::char_type   std::iterator_traits< IteratorType >::value_type char_type   Definition:  segment.hpp:107     boost::locale::boundary::segment::segment   segment(iterator b, iterator e, rule_type r)   Definition:  segment.hpp:136     boost::locale::boundary::segment::begin   IteratorType begin() const   Definition:  segment.hpp:159     boost::locale::boundary::segment::empty   bool empty() const   Definition:  segment.hpp:200     boost::locale::boundary::segment   a segment object that represents a pair of two iterators that define the range where this segment exi...   Definition:  segment.hpp:102     boost::locale::boundary::segment::rule   rule_type rule() const   Definition:  segment.hpp:208     boost::locale::boundary::wcsegment   segment< wchar_t const * > wcsegment  convenience typedef   Definition:  segment.hpp:446     boost::locale::boundary::u16csegment   segment< char16_t const * > u16csegment  convenience typedef   Definition:  segment.hpp:448     boost::locale::boundary::u16ssegment   segment< std::u16string::const_iterator > u16ssegment  convenience typedef   Definition:  segment.hpp:439     boost::locale::boundary::ssegment   segment< std::string::const_iterator > ssegment  convenience typedef   Definition:  segment.hpp:436     boost::locale::boundary::segment::string_type   std::basic_string< char_type > string_type   Definition:  segment.hpp:111     boost::locale::boundary::segment::str   string_type str() const   Definition:  segment.hpp:183     boost::locale::boundary::rule_type   uint32_t rule_type  Flags used with word boundary analysis – the type of the word, line or sentence boundary found.   Definition:  types.hpp:50     boost::locale::boundary::operator<   bool operator<(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:255     boost::locale::boundary::operator<=   bool operator<=(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:261     boost::locale::boundary::segment::rule   void rule(rule_type r)   Definition:  segment.hpp:215     boost::locale::boundary::operator>=   bool operator>=(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:273     boost::locale::boundary::segment::value_type   char_type value_type   Definition:  segment.hpp:115     boost::locale::boundary::operator==   bool operator==(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:141     boost::locale::boundary::operator<<   std::basic_ostream< CharType, TraitsType > & operator<<(std::basic_ostream< CharType, TraitsType > &out, segment< Iterator > const &tok)   Definition:  segment.hpp:462     boost::locale::boundary::segment::length   size_t length() const   Definition:  segment.hpp:192     boost::locale::boundary::segment::const_iterator   IteratorType const_iterator   Definition:  segment.hpp:123     boost::locale::boundary::segment::begin   void begin(iterator const &v)   Definition:  segment.hpp:144     boost::locale::boundary::segment::segment   segment()   Definition:  segment.hpp:132     boost::locale::boundary::wssegment   segment< std::wstring::const_iterator > wssegment  convenience typedef   Definition:  segment.hpp:437     boost::locale::boundary::u32ssegment   segment< std::u32string::const_iterator > u32ssegment  convenience typedef   Definition:  segment.hpp:442     boost::locale::boundary::u32csegment   segment< char32_t const * > u32csegment  convenience typedef   Definition:  segment.hpp:451     boost::locale::boundary::segment::operator!=   bool operator!=(segment const &other) const  Compare two segments.   Definition:  segment.hpp:229     boost::locale::boundary::segment::end   void end(iterator const &v)   Definition:  segment.hpp:151     boost::locale::boundary::segment::iterator   IteratorType iterator   Definition:  segment.hpp:119     boost::locale::boundary::operator>   bool operator>(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:267     boost::locale::boundary::segment::difference_type   std::iterator_traits< IteratorType >::difference_type difference_type   Definition:  segment.hpp:127     boost::locale::boundary::operator!=   bool operator!=(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:149             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('boundary__point_8hpp_source.html','');});/* @license-end */       boundary_point.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_BOUNDARY_POINT_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_BOUNDARY_POINT_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/boundary/types.hpp>         11 &#160;        12 &#160; namespace  boost {        13 &#160; namespace  locale {         14  &#160; namespace  boundary {        15 &#160;        19 &#160;        46 &#160;     template < typename  IteratorType>         47  &#160;     class   boundary_point   {        48 &#160;     public :         52  &#160;         typedef  IteratorType  iterator_type ;        53 &#160;         57  &#160;         boundary_point () : rule_(0) {}        58 &#160;         62  &#160;         boundary_point ( iterator_type  p, rule_type  r) :        63 &#160;            iterator_(p),        64 &#160;            rule_(r)        65 &#160;        {        66 &#160;        }         70  &#160;         void   iterator ( iterator_type  i)        71 &#160;        {        72 &#160;            iterator_ = i;        73 &#160;        }         77  &#160;         void   rule ( rule_type  r)        78 &#160;        {        79 &#160;            rule_ = r;        80 &#160;        }         84  &#160;         iterator_type   iterator ()  const         85 &#160;          {        86 &#160;             return  iterator_;        87 &#160;        }         91  &#160;         rule_type   rule ()  const         92 &#160;          {        93 &#160;             return  rule_;        94 &#160;        }         98  &#160;         bool   operator== ( boundary_point   const  &other)  const         99 &#160;          {       100 &#160;             return  iterator_ == other.iterator_ && rule_ = other.rule_;       101 &#160;        }        105  &#160;         bool   operator!= ( boundary_point   const  &other)  const        106 &#160;          {       107 &#160;             return  !(* this ==other);       108 &#160;        }        112  &#160;         bool   operator== ( iterator_type   const  &other)  const        113 &#160;          {       114 &#160;             return  iterator_ == other;       115 &#160;        }        119  &#160;         bool   operator!= ( iterator_type   const  &other)  const        120 &#160;          {       121 &#160;             return  iterator_ != other;       122 &#160;        }       123 &#160;        127  &#160;         operator   iterator_type  () const        128 &#160;          {       129 &#160;             return  iterator_;       130 &#160;        }       131 &#160;       132 &#160;     private :       133 &#160;         iterator_type  iterator_;       134 &#160;         rule_type  rule_;       135 &#160;       136 &#160;    };       140 &#160;     template < typename  BaseIterator>        141  &#160;     bool   operator== (BaseIterator  const  &l, boundary_point<BaseIterator>   const  &r)       142 &#160;    {       143 &#160;         return  r==l;       144 &#160;    }       148 &#160;     template < typename  BaseIterator>        149  &#160;     bool   operator!= (BaseIterator  const  &l, boundary_point<BaseIterator>   const  &r)       150 &#160;    {       151 &#160;         return  r!=l;       152 &#160;    }       153 &#160;       155 &#160;        156  &#160;     typedef   boundary_point<std::string::const_iterator>   sboundary_point ;              157  &#160;     typedef   boundary_point<std::wstring::const_iterator>   wsboundary_point ;           158 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR16_T         159  &#160;     typedef   boundary_point<std::u16string::const_iterator>   u16sboundary_point ;       160 &#160;     #endif        161 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR32_T         162  &#160;     typedef   boundary_point<std::u32string::const_iterator>   u32sboundary_point ;       163 &#160;     #endif        164 &#160;        165  &#160;     typedef   boundary_point<char const *>   cboundary_point ;                             166  &#160;     typedef   boundary_point<wchar_t const *>   wcboundary_point ;                        167 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR16_T         168  &#160;     typedef   boundary_point<char16_t const *>   u16cboundary_point ;                     169 &#160;     #endif        170 &#160;     #ifdef BOOST_LOCALE_ENABLE_CHAR32_T         171  &#160;     typedef   boundary_point<char32_t const *>   u32cboundary_point ;                     172 &#160;     #endif        173 &#160;       174 &#160;       175 &#160;}  // boundary        176 &#160;}  // locale        177 &#160;}  // boost        178 &#160;       179 &#160;       180 &#160; #endif        181 &#160;    boost::locale::boundary::boundary_point::boundary_point   boundary_point(iterator_type p, rule_type r)   Definition:  boundary_point.hpp:62     boost::locale::boundary::boundary_point::rule   void rule(rule_type r)   Definition:  boundary_point.hpp:77     boost::locale::boundary::boundary_point::operator!=   bool operator!=(boundary_point const &other) const   Definition:  boundary_point.hpp:105     boost::locale::boundary::boundary_point::iterator   iterator_type iterator() const   Definition:  boundary_point.hpp:84     boost::locale::boundary::boundary_point::rule   rule_type rule() const   Definition:  boundary_point.hpp:91     boost::locale::boundary::wcboundary_point   boundary_point< wchar_t const * > wcboundary_point  convenience typedef   Definition:  boundary_point.hpp:166     boost::locale::boundary::u16cboundary_point   boundary_point< char16_t const * > u16cboundary_point  convenience typedef   Definition:  boundary_point.hpp:168     boost::locale::boundary::rule_type   uint32_t rule_type  Flags used with word boundary analysis – the type of the word, line or sentence boundary found.   Definition:  types.hpp:50     boost::locale::boundary::sboundary_point   boundary_point< std::string::const_iterator > sboundary_point  convenience typedef   Definition:  boundary_point.hpp:156     boost::locale::boundary::boundary_point::operator==   bool operator==(iterator_type const &other) const   Definition:  boundary_point.hpp:112     boost::locale::boundary::operator==   bool operator==(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:141     boost::locale::boundary::boundary_point::operator!=   bool operator!=(iterator_type const &other) const   Definition:  boundary_point.hpp:119     boost::locale::boundary::boundary_point::operator==   bool operator==(boundary_point const &other) const   Definition:  boundary_point.hpp:98     boost::locale::boundary::u32sboundary_point   boundary_point< std::u32string::const_iterator > u32sboundary_point  convenience typedef   Definition:  boundary_point.hpp:162     boost::locale::boundary::wsboundary_point   boundary_point< std::wstring::const_iterator > wsboundary_point  convenience typedef   Definition:  boundary_point.hpp:157     boost::locale::boundary::boundary_point::boundary_point   boundary_point()   Definition:  boundary_point.hpp:57     boost::locale::boundary::cboundary_point   boundary_point< char const * > cboundary_point  convenience typedef   Definition:  boundary_point.hpp:165     boost::locale::boundary::boundary_point   This class represents a boundary point in the text.   Definition:  boundary_point.hpp:47     boost::locale::boundary::boundary_point::iterator   void iterator(iterator_type i)   Definition:  boundary_point.hpp:70     boost::locale::boundary::u32cboundary_point   boundary_point< char32_t const * > u32cboundary_point  convenience typedef   Definition:  boundary_point.hpp:171     boost::locale::boundary::boundary_point::iterator_type   IteratorType iterator_type   Definition:  boundary_point.hpp:52     boost::locale::boundary::u16sboundary_point   boundary_point< std::u16string::const_iterator > u16sboundary_point  convenience typedef   Definition:  boundary_point.hpp:159     boost::locale::boundary::operator!=   bool operator!=(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:149             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('date__time_8hpp_source.html','');});/* @license-end */       date_time.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_DATE_TIME_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_DATE_TIME_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/date_time_facet.hpp>         11 &#160; #include <boost/locale/formatting.hpp>         12 &#160; #include <boost/locale/hold_ptr.hpp>         13 &#160; #include <boost/locale/time_zone.hpp>         14 &#160; #include <locale>         15 &#160; #include <stdexcept>         16 &#160; #include <vector>         17 &#160;        18 &#160; #ifdef BOOST_MSVC         19 &#160; #  pragma warning(push)         20 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         21 &#160; #endif         22 &#160;        23 &#160; namespace  boost {        24 &#160;     namespace  locale {        31 &#160;        32 &#160;         36  &#160;         class  BOOST_SYMBOL_VISIBLE  date_time_error  :  public  std::runtime_error {        37 &#160;         public :         41  &#160;             date_time_error (std::string  const  &e) : std::runtime_error(e) {}        42 &#160;        };        43 &#160;        44 &#160;         53  &#160;         struct   date_time_period         54 &#160;        {         55  &#160;             period::period_type   type ;            56  &#160;             int   value ;                          57 &#160;             date_time_period   operator+ ()  const  {  return  * this ; }         64  &#160;             date_time_period   operator- ()  const  {  return   date_time_period ( type ,- value ); }        65 &#160;         69  &#160;             date_time_period ( period::period_type  f= period::period_type (), int  v=1) :  type (f),  value (v) {}        70 &#160;        };        71 &#160;         72  &#160;         namespace  period {         76  &#160;             inline   period_type   invalid (){  return   period_type ( marks::invalid ); }         80  &#160;             inline   period_type   era (){  return   period_type ( marks::era ); }         84  &#160;             inline   period_type   year (){  return   period_type ( marks::year ); }         88  &#160;             inline   period_type   extended_year (){  return   period_type ( marks::extended_year ); }         92  &#160;             inline   period_type   month (){  return   period_type ( marks::month ); }         96  &#160;             inline   period_type   day (){  return   period_type ( marks::day ); }        100  &#160;             inline   period_type   day_of_year (){  return   period_type ( marks::day_of_year ); }        109  &#160;             inline   period_type   day_of_week (){  return   period_type ( marks::day_of_week ); }        114  &#160;             inline   period_type   day_of_week_in_month (){  return   period_type ( marks::day_of_week_in_month ); }        118  &#160;             inline   period_type   day_of_week_local (){  return   period_type ( marks::day_of_week_local ); }        122  &#160;             inline   period_type   hour (){  return   period_type ( marks::hour ); }        126  &#160;             inline   period_type   hour_12 (){  return   period_type ( marks::hour_12 ); }        130  &#160;             inline   period_type   am_pm (){  return   period_type ( marks::am_pm ); }        134  &#160;             inline   period_type   minute (){  return   period_type ( marks::minute ); }        138  &#160;             inline   period_type   second (){  return   period_type ( marks::second ); }        142  &#160;             inline   period_type   week_of_year (){  return   period_type ( marks::week_of_year ); }        146  &#160;             inline   period_type   week_of_month (){  return   period_type ( marks::week_of_month ); }        150  &#160;             inline   period_type   first_day_of_week (){  return   period_type ( marks::first_day_of_week ); }       151 &#160;        155  &#160;             inline   date_time_period   era ( int  v) {  return   date_time_period ( era (),v); }        159  &#160;             inline   date_time_period   year ( int  v) {  return   date_time_period ( year (),v); }        163  &#160;             inline   date_time_period   extended_year ( int  v) {  return   date_time_period ( extended_year (),v); }        167  &#160;             inline   date_time_period   month ( int  v) {  return   date_time_period ( month (),v); }        171  &#160;             inline   date_time_period   day ( int  v) {  return   date_time_period ( day (),v); }        175  &#160;             inline   date_time_period   day_of_year ( int  v) {  return   date_time_period ( day_of_year (),v); }        184  &#160;             inline   date_time_period   day_of_week ( int  v) {  return   date_time_period ( day_of_week (),v); }        189  &#160;             inline   date_time_period   day_of_week_in_month ( int  v) {  return   date_time_period ( day_of_week_in_month (),v); }        193  &#160;             inline   date_time_period   day_of_week_local ( int  v) {  return   date_time_period ( day_of_week_local (),v); }        197  &#160;             inline   date_time_period   hour ( int  v) {  return   date_time_period ( hour (),v); }        201  &#160;             inline   date_time_period   hour_12 ( int  v) {  return   date_time_period ( hour_12 (),v); }        205  &#160;             inline   date_time_period   am_pm ( int  v) {  return   date_time_period ( am_pm (),v); }        209  &#160;             inline   date_time_period   minute ( int  v) {  return   date_time_period ( minute (),v); }        213  &#160;             inline   date_time_period   second ( int  v) {  return   date_time_period ( second (),v); }        217  &#160;             inline   date_time_period   week_of_year ( int  v) {  return   date_time_period ( week_of_year (),v); }        221  &#160;             inline   date_time_period   week_of_month ( int  v) {  return   date_time_period ( week_of_month (),v); }        225  &#160;             inline   date_time_period   first_day_of_week ( int  v) {  return   date_time_period ( first_day_of_week (),v); }       226 &#160;        230  &#160;             inline   date_time_period   january () {  return   date_time_period ( month (),0); }        234  &#160;             inline   date_time_period   february () {  return   date_time_period ( month (),1); }        238  &#160;             inline   date_time_period   march () {  return   date_time_period ( month (),2); }        242  &#160;             inline   date_time_period   april () {  return   date_time_period ( month (),3); }        246  &#160;             inline   date_time_period   may () {  return   date_time_period ( month (),4); }        250  &#160;             inline   date_time_period   june () {  return   date_time_period ( month (),5); }        254  &#160;             inline   date_time_period   july () {  return   date_time_period ( month (),6); }        258  &#160;             inline   date_time_period   august () {  return   date_time_period ( month (),7); }        262  &#160;             inline   date_time_period   september () {  return   date_time_period ( month (),8); }        266  &#160;             inline   date_time_period   october () {  return   date_time_period ( month (),9); }        270  &#160;             inline   date_time_period   november () {  return   date_time_period ( month (),10); }        274  &#160;             inline   date_time_period   december () {  return   date_time_period ( month (),11); }       275 &#160;        279  &#160;             inline   date_time_period   sunday () {  return   date_time_period ( day_of_week (),1); }        283  &#160;             inline   date_time_period   monday () {  return   date_time_period ( day_of_week (),2); }        287  &#160;             inline   date_time_period   tuesday () {  return   date_time_period ( day_of_week (),3); }        291  &#160;             inline   date_time_period   wednesday () {  return   date_time_period ( day_of_week (),4); }        295  &#160;             inline   date_time_period   thursday () {  return   date_time_period ( day_of_week (),5); }        299  &#160;             inline   date_time_period   friday () {  return   date_time_period ( day_of_week (),6); }        303  &#160;             inline   date_time_period   saturday () {  return   date_time_period ( day_of_week (),7); }        307  &#160;             inline   date_time_period   am () {  return   date_time_period ( am_pm (),0); }        311  &#160;             inline   date_time_period   pm () {  return   date_time_period ( am_pm (),1); }       312 &#160;        316  &#160;             inline   date_time_period   operator+ ( period::period_type  f)       317 &#160;            {       318 &#160;                 return   date_time_period (f);       319 &#160;            }        323  &#160;             inline   date_time_period   operator- ( period::period_type  f)       324 &#160;            {       325 &#160;                 return   date_time_period (f,-1);       326 &#160;            }       327 &#160;       331 &#160;             template < typename  T>        332  &#160;             date_time_period   operator* ( period::period_type  f,T v)       333 &#160;            {       334 &#160;                 return   date_time_period (f,v);       335 &#160;            }       336 &#160;       340 &#160;             template < typename  T>        341  &#160;             date_time_period   operator* (T v, period::period_type  f)       342 &#160;            {       343 &#160;                 return   date_time_period (f,v);       344 &#160;            }       348 &#160;             template < typename  T>        349  &#160;             date_time_period   operator* (T v, date_time_period  f)       350 &#160;            {       351 &#160;                 return   date_time_period (f. type ,f. value *v);       352 &#160;            }       353 &#160;       357 &#160;             template < typename  T>        358  &#160;             date_time_period   operator* ( date_time_period  f,T v)       359 &#160;            {       360 &#160;                 return   date_time_period (f. type ,f. value *v);       361 &#160;            }       362 &#160;       363 &#160;       364 &#160;        }  // period        365 &#160;       366 &#160;        373  &#160;         class   date_time_period_set  {       374 &#160;         public :       375 &#160;        379  &#160;             date_time_period_set ()       380 &#160;            {       381 &#160;            }        385  &#160;             date_time_period_set ( period::period_type  f)       386 &#160;            {       387 &#160;                basic_[0]= date_time_period (f);       388 &#160;            }        392  &#160;             date_time_period_set ( date_time_period   const  &fl)       393 &#160;            {       394 &#160;                basic_[0]=fl;       395 &#160;            }        399  &#160;             void   add ( date_time_period  f)       400 &#160;            {       401 &#160;                 size_t  n= size ();       402 &#160;                 if (n < 4)       403 &#160;                    basic_[n]=f;       404 &#160;                 else        405 &#160;                    periods_.push_back(f);       406 &#160;            }        410  &#160;             size_t   size ()  const        411 &#160;              {       412 &#160;                 if (basic_[0].type ==  period::period_type ())       413 &#160;                     return  0;       414 &#160;                 if (basic_[1].type ==  period::period_type ())       415 &#160;                     return  1;       416 &#160;                 if (basic_[2].type ==  period::period_type ())       417 &#160;                     return  2;       418 &#160;                 if (basic_[3].type ==  period::period_type ())       419 &#160;                     return  3;       420 &#160;                 return  4+periods_.size();       421 &#160;            }        425  &#160;             date_time_period   const  & operator[] ( size_t  n)  const        426 &#160;              {       427 &#160;                 if (n >=  size ())       428 &#160;                     throw  std::out_of_range( &quot;Invalid index to date_time_period&quot; );       429 &#160;                 if (n < 4)       430 &#160;                     return  basic_[n];       431 &#160;                 else        432 &#160;                     return  periods_[n-4];       433 &#160;            }       434 &#160;         private :       435 &#160;             date_time_period  basic_[4];       436 &#160;            std::vector<date_time_period> periods_;       437 &#160;        };       438 &#160;       439 &#160;        443  &#160;         inline   date_time_period_set   operator+ ( date_time_period_set   const  &a, date_time_period_set   const  &b)       444 &#160;        {       445 &#160;             date_time_period_set  s(a);       446 &#160;             for ( unsigned  i=0;i<b. size ();i++)       447 &#160;                s. add (b[i]);       448 &#160;             return  s;       449 &#160;        }       450 &#160;        454  &#160;         inline   date_time_period_set   operator- ( date_time_period_set   const  &a, date_time_period_set   const  &b)       455 &#160;        {       456 &#160;             date_time_period_set  s(a);       457 &#160;             for ( unsigned  i=0;i<b. size ();i++)       458 &#160;                s. add (-b[i]);       459 &#160;             return  s;       460 &#160;        }       461 &#160;       462 &#160;        470  &#160;         class  BOOST_LOCALE_DECL  calendar  {       471 &#160;         public :       472 &#160;       479 &#160;             calendar (std::ios_base &ios);       485 &#160;             calendar (std::locale  const  &l,std::string  const  &zone);       491 &#160;             calendar (std::locale  const  &l);       497 &#160;             calendar (std::string  const  &zone);       503 &#160;             calendar ();       504 &#160;            ~ calendar ();       505 &#160;       509 &#160;             calendar ( calendar   const  &other);       513 &#160;             calendar   const  &operator=( calendar   const  &other);       514 &#160;       518 &#160;             int  minimum( period::period_type  f)  const ;       522 &#160;             int  greatest_minimum( period::period_type  f)  const ;       526 &#160;             int  maximum( period::period_type  f)  const ;       530 &#160;             int  least_maximum( period::period_type  f)  const ;       531 &#160;       534 &#160;             int  first_day_of_week()  const ;       535 &#160;       539 &#160;            std::locale get_locale()  const ;       543 &#160;            std::string get_time_zone()  const ;       544 &#160;       548 &#160;             bool  is_gregorian()  const ;       549 &#160;       553 &#160;             bool   operator== ( calendar   const  &other)  const ;       557 &#160;             bool   operator!= ( calendar   const  &other)  const ;       558 &#160;       559 &#160;         private :       560 &#160;             friend   class   date_time ;       561 &#160;            std::locale locale_;       562 &#160;            std::string tz_;       563 &#160;             hold_ptr<abstract_calendar>  impl_;       564 &#160;        };       565 &#160;       586 &#160;        587  &#160;         class  BOOST_LOCALE_DECL  date_time  {       588 &#160;         public :       589 &#160;       595 &#160;             date_time ();       599 &#160;             date_time ( date_time   const  &other);       603 &#160;             date_time ( date_time   const  &other, date_time_period_set   const  &set);       607 &#160;             date_time   const  &operator=( date_time   const  &other);       608 &#160;            ~ date_time ();       609 &#160;       615 &#160;             date_time ( double   time );       619 &#160;             date_time ( double   time , calendar   const  &cal);       623 &#160;             date_time ( calendar   const  &cal);       624 &#160;       630 &#160;             date_time ( date_time_period_set   const  &set);       634 &#160;             date_time ( date_time_period_set   const  &set, calendar   const  &cal);       635 &#160;       636 &#160;       640 &#160;             date_time   const  &operator=( date_time_period_set   const  &f);       641 &#160;       645 &#160;             void  set( period::period_type  f, int  v);       649 &#160;             int  get( period::period_type  f)  const ;       650 &#160;        654  &#160;             int   operator/ ( period::period_type  f)  const        655 &#160;              {       656 &#160;                 return  get(f);       657 &#160;            }       658 &#160;        662  &#160;             date_time   operator+ ( period::period_type  f)  const        663 &#160;              {       664 &#160;                 return  * this + date_time_period (f);       665 &#160;            }       666 &#160;        670  &#160;             date_time   operator- ( period::period_type  f)  const        671 &#160;              {       672 &#160;                 return  * this - date_time_period (f);       673 &#160;            }       674 &#160;        678  &#160;             date_time   const  & operator+= ( period::period_type  f)       679 &#160;            {       680 &#160;                 return  * this += date_time_period (f);       681 &#160;            }        685  &#160;             date_time   const  & operator-= ( period::period_type  f)       686 &#160;            {       687 &#160;                 return  * this -= date_time_period (f);       688 &#160;            }       689 &#160;        693  &#160;             date_time   operator<< ( period::period_type  f)  const        694 &#160;              {       695 &#160;                 return  * this  <<  date_time_period (f);       696 &#160;            }       697 &#160;        701  &#160;             date_time   operator>> ( period::period_type  f)  const        702 &#160;              {       703 &#160;                 return  * this >> date_time_period (f);       704 &#160;            }       705 &#160;        709  &#160;             date_time   const  & operator<<= ( period::period_type  f)       710 &#160;            {       711 &#160;                 return  * this  <<=  date_time_period (f);       712 &#160;            }        716  &#160;             date_time   const  & operator>>= ( period::period_type  f)       717 &#160;            {       718 &#160;                 return  * this  >>=  date_time_period (f);       719 &#160;            }       720 &#160;       724 &#160;             date_time   operator+ ( date_time_period   const  &v)  const ;       728 &#160;             date_time   operator- ( date_time_period   const  &v)  const ;       732 &#160;             date_time   const  &operator+=( date_time_period   const  &v);       736 &#160;             date_time   const  &operator-=( date_time_period   const  &v);       737 &#160;       741 &#160;             date_time   operator<< ( date_time_period   const  &v)  const ;       745 &#160;             date_time   operator>> ( date_time_period   const  &v)  const  ;       749 &#160;             date_time   const  &operator<<=( date_time_period   const  &v);       753 &#160;             date_time   const  &operator>>=( date_time_period   const  &v);       754 &#160;       758 &#160;             date_time   operator+ ( date_time_period_set   const  &v)  const ;       762 &#160;             date_time   operator- ( date_time_period_set   const  &v)  const ;       766 &#160;             date_time   const  &operator+=( date_time_period_set   const  &v);       770 &#160;             date_time   const  &operator-=( date_time_period_set   const  &v);       771 &#160;       775 &#160;             date_time   operator<< ( date_time_period_set   const  &v)  const ;       779 &#160;             date_time   operator>> ( date_time_period_set   const  &v)  const  ;       783 &#160;             date_time   const  &operator<<=( date_time_period_set   const  &v);       787 &#160;             date_time   const  &operator>>=( date_time_period_set   const  &v);       788 &#160;       794 &#160;             double   time ()  const ;       801 &#160;             void   time ( double  v);       802 &#160;       806 &#160;             bool   operator== ( date_time   const  &other)  const ;       810 &#160;             bool   operator!= ( date_time   const  &other)  const ;       814 &#160;             bool   operator< ( date_time   const  &other)  const ;       818 &#160;             bool   operator> ( date_time   const  &other)  const ;       822 &#160;             bool   operator<= ( date_time   const  &other)  const ;       826 &#160;             bool   operator>= ( date_time   const  &other)  const ;       827 &#160;       831 &#160;             void  swap( date_time  &other);       832 &#160;       836 &#160;             int  difference( date_time   const  &other, period::period_type  f)  const ;       837 &#160;       841 &#160;             int  minimum( period::period_type  f)  const ;       846 &#160;             int  maximum( period::period_type  f)  const ;       847 &#160;       851 &#160;             bool  is_in_daylight_saving_time()  const ;       852 &#160;       853 &#160;         private :       854 &#160;             hold_ptr<abstract_calendar>  impl_;       855 &#160;        };       856 &#160;       870 &#160;         template < typename  CharType>        871  &#160;        std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out, date_time   const  &t)       872 &#160;        {       873 &#160;             double  time_point = t. time ();       874 &#160;            uint64_t display_flags =  ios_info::get (out). display_flags ();       875 &#160;             if   (       876 &#160;                    display_flags == flags::date       877 &#160;                    || display_flags == flags::time       878 &#160;                    || display_flags == flags::datetime       879 &#160;                    || display_flags == flags::strftime       880 &#160;                )       881 &#160;            {       882 &#160;                out << time_point;       883 &#160;            }       884 &#160;             else  {       885 &#160;                 ios_info::get (out). display_flags (flags::datetime);       886 &#160;                out << time_point;       887 &#160;                 ios_info::get (out). display_flags (display_flags);       888 &#160;            }       889 &#160;             return  out;       890 &#160;        }       891 &#160;       897 &#160;         template < typename  CharType>        898  &#160;        std::basic_istream<CharType> & operator>> (std::basic_istream<CharType> &in, date_time  &t)       899 &#160;        {       900 &#160;             double  v;       901 &#160;            uint64_t display_flags =  ios_info::get (in). display_flags ();       902 &#160;             if   (       903 &#160;                    display_flags == flags::date       904 &#160;                    || display_flags == flags::time       905 &#160;                    || display_flags == flags::datetime       906 &#160;                    || display_flags == flags::strftime       907 &#160;                )       908 &#160;            {       909 &#160;                in >> v;       910 &#160;            }       911 &#160;             else  {       912 &#160;                 ios_info::get (in). display_flags (flags::datetime);       913 &#160;                in >> v;       914 &#160;                 ios_info::get (in). display_flags (display_flags);       915 &#160;            }       916 &#160;             if (!in.fail())       917 &#160;                t. time (v);       918 &#160;             return  in;       919 &#160;        }       920 &#160;       921 &#160; #ifdef BOOST_MSVC        922 &#160; #pragma warning(push)        923 &#160; #pragma warning(disable:4512) //assignment operator could not be generated        924 &#160; #endif        925 &#160;         class  date_time_duration {       934 &#160;         public :       935 &#160;        940  &#160;             date_time_duration ( date_time   const  &first, date_time   const  &second) :       941 &#160;                s_(first),       942 &#160;                e_(second)       943 &#160;            {       944 &#160;            }       945 &#160;        949  &#160;             int   get ( period::period_type  f)  const        950 &#160;              {       951 &#160;                 return   start (). difference ( end (),f);       952 &#160;            }       953 &#160;        957  &#160;             int   operator /  ( period::period_type  f)  const        958 &#160;              {       959 &#160;                 return   start (). difference ( end (),f);       960 &#160;            }       961 &#160;        965  &#160;             date_time   const  & start ()  const  {  return  s_; }        969  &#160;             date_time   const  & end ()  const  {  return  e_; }       970 &#160;         private :       971 &#160;             date_time   const  &s_;       972 &#160;             date_time   const  &e_;       973 &#160;        };       974 &#160; #ifdef BOOST_MSVC        975 &#160; #pragma warning(pop)        976 &#160; #endif        977 &#160;        982  &#160;         inline   date_time_duration   operator- ( date_time   const  &later, date_time   const  &earlier)       983 &#160;        {       984 &#160;             return   date_time_duration (earlier,later);       985 &#160;        }       986 &#160;       987 &#160;       988 &#160;         namespace  period {        992  &#160;             inline   int   era ( date_time   const  &dt) {  return  dt. get ( era ()); }        996  &#160;             inline   int   year ( date_time   const  &dt) {  return  dt. get ( year ()); }       1000  &#160;             inline   int   extended_year ( date_time   const  &dt) {  return  dt. get ( extended_year ()); }       1004  &#160;             inline   int   month ( date_time   const  &dt) {  return  dt. get ( month ()); }       1008  &#160;             inline   int   day ( date_time   const  &dt) {  return  dt. get ( day ()); }       1012  &#160;             inline   int   day_of_year ( date_time   const  &dt) {  return  dt. get ( day_of_year ()); }       1021  &#160;             inline   int   day_of_week ( date_time   const  &dt) {  return  dt. get ( day_of_week ()); }       1026  &#160;             inline   int   day_of_week_in_month ( date_time   const  &dt) {  return  dt. get ( day_of_week_in_month ()); }       1030  &#160;             inline   int   day_of_week_local ( date_time   const  &dt) {  return  dt. get ( day_of_week_local ()); }       1034  &#160;             inline   int   hour ( date_time   const  &dt) {  return  dt. get ( hour ()); }       1038  &#160;             inline   int   hour_12 ( date_time   const  &dt) {  return  dt. get ( hour_12 ()); }       1042  &#160;             inline   int   am_pm ( date_time   const  &dt) {  return  dt. get ( am_pm ()); }       1046  &#160;             inline   int   minute ( date_time   const  &dt) {  return  dt. get ( minute ()); }       1050  &#160;             inline   int   second ( date_time   const  &dt) {  return  dt. get ( second ()); }       1054  &#160;             inline   int   week_of_year ( date_time   const  &dt) {  return  dt. get ( week_of_year ()); }       1058  &#160;             inline   int   week_of_month ( date_time   const  &dt) {  return  dt. get ( week_of_month ()); }       1062  &#160;             inline   int   first_day_of_week ( date_time   const  &dt) {  return  dt. get ( first_day_of_week ()); }      1063 &#160;       1067  &#160;             inline   int   era ( date_time_duration   const  &dt) {  return  dt.get( era ()); }       1071  &#160;             inline   int   year ( date_time_duration   const  &dt) {  return  dt.get( year ()); }       1075  &#160;             inline   int   extended_year ( date_time_duration   const  &dt) {  return  dt.get( extended_year ()); }       1079  &#160;             inline   int   month ( date_time_duration   const  &dt) {  return  dt.get( month ()); }       1083  &#160;             inline   int   day ( date_time_duration   const  &dt) {  return  dt.get( day ()); }       1087  &#160;             inline   int   day_of_year ( date_time_duration   const  &dt) {  return  dt.get( day_of_year ()); }       1091  &#160;             inline   int   day_of_week ( date_time_duration   const  &dt) {  return  dt.get( day_of_week ()); }       1095  &#160;             inline   int   day_of_week_in_month ( date_time_duration   const  &dt) {  return  dt.get( day_of_week_in_month ()); }       1099  &#160;             inline   int   day_of_week_local ( date_time_duration   const  &dt) {  return  dt.get( day_of_week_local ()); }       1103  &#160;             inline   int   hour ( date_time_duration   const  &dt) {  return  dt.get( hour ()); }       1107  &#160;             inline   int   hour_12 ( date_time_duration   const  &dt) {  return  dt.get( hour_12 ()); }       1111  &#160;             inline   int   am_pm ( date_time_duration   const  &dt) {  return  dt.get( am_pm ()); }       1115  &#160;             inline   int   minute ( date_time_duration   const  &dt) {  return  dt.get( minute ()); }       1119  &#160;             inline   int   second ( date_time_duration   const  &dt) {  return  dt.get( second ()); }       1123  &#160;             inline   int   week_of_year ( date_time_duration   const  &dt) {  return  dt.get( week_of_year ()); }       1127  &#160;             inline   int   week_of_month ( date_time_duration   const  &dt) {  return  dt.get( week_of_month ()); }       1131  &#160;             inline   int   first_day_of_week ( date_time_duration   const  &dt) {  return  dt.get( first_day_of_week ()); }      1132 &#160;      1133 &#160;      1134 &#160;        }      1135 &#160;      1137 &#160;      1138 &#160;      1139 &#160;    }  // locale       1140 &#160;}  // boost       1141 &#160;      1142 &#160; #ifdef BOOST_MSVC       1143 &#160; #pragma warning(pop)       1144 &#160; #endif       1145 &#160;      1146 &#160;      1147 &#160; #endif       1148 &#160;    boost::locale::period::am_pm   period_type am_pm()   Definition:  date_time.hpp:130     boost::locale::date_time::get   int get(period::period_type f) const     boost::locale::period::week_of_year   period_type week_of_year()   Definition:  date_time.hpp:142     boost::locale::period::minute   period_type minute()   Definition:  date_time.hpp:134     boost::locale::period::marks::week_of_month   The week number within current month.   Definition:  date_time_facet.hpp:52     boost::locale::date_time_period::type   period::period_type type  The type of period, i.e. era, year, day etc.   Definition:  date_time.hpp:55     boost::locale::period::marks::day_of_week_in_month    Definition:  date_time_facet.hpp:43     boost::locale::period::extended_year   period_type extended_year()   Definition:  date_time.hpp:88     boost::locale::period::saturday   date_time_period saturday()   Definition:  date_time.hpp:303     boost::locale::date_time_period_set::date_time_period_set   date_time_period_set()   Definition:  date_time.hpp:379     boost::locale::date_time_duration::get   int get(period::period_type f) const   Definition:  date_time.hpp:949     boost::locale::period::marks::day_of_week    Definition:  date_time_facet.hpp:38     boost::locale::period::marks::year   Year, it is calendar specific, for example 2011 in Gregorian calendar.   Definition:  date_time_facet.hpp:33     boost::locale::date_time_period_set   this class that represents a set of periods,   Definition:  date_time.hpp:373     boost::locale::date_time::time   double time() const     boost::locale::period::january   date_time_period january()   Definition:  date_time.hpp:230     boost::locale::date_time::difference   int difference(date_time const &other, period::period_type f) const     boost::locale::period::november   date_time_period november()   Definition:  date_time.hpp:270     boost::locale::date_time_error::date_time_error   date_time_error(std::string const &e)   Definition:  date_time.hpp:41     boost::locale::date_time_duration   This class represents a period: a pair of two date_time objects.   Definition:  date_time.hpp:933     boost::locale::date_time::operator>>=   date_time const  & operator>>=(period::period_type f)   Definition:  date_time.hpp:716     boost::locale::period::march   date_time_period march()   Definition:  date_time.hpp:238     boost::locale::period::day_of_week   period_type day_of_week()   Definition:  date_time.hpp:109     boost::locale::period::marks::day_of_year   The number of day in year, starting from 1, in Gregorian [1..366].   Definition:  date_time_facet.hpp:37     boost::locale::period::monday   date_time_period monday()   Definition:  date_time.hpp:283     boost::locale::period::february   date_time_period february()   Definition:  date_time.hpp:234     boost::locale::period::april   date_time_period april()   Definition:  date_time.hpp:242     boost::locale::boundary::operator<   bool operator<(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:255     boost::locale::period::first_day_of_week   period_type first_day_of_week()   Definition:  date_time.hpp:150     boost::locale::boundary::operator<=   bool operator<=(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:261     boost::locale::calendar   this class provides an access to general calendar information.   Definition:  date_time.hpp:470     boost::locale::period::august   date_time_period august()   Definition:  date_time.hpp:258     boost::locale::date_time_duration::operator/   int operator/(period::period_type f) const   Definition:  date_time.hpp:957     boost::locale::date_time_period::operator+   date_time_period operator+() const   Definition:  date_time.hpp:60     boost::locale::period::am   date_time_period am()   Definition:  date_time.hpp:307     boost::locale::boundary::operator>=   bool operator>=(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:273     boost::locale::period::october   date_time_period october()   Definition:  date_time.hpp:266     boost::locale::date_time::operator<<   date_time operator<<(period::period_type f) const   Definition:  date_time.hpp:693     boost::locale::date_time_period_set::add   void add(date_time_period f)   Definition:  date_time.hpp:399     boost::locale::date_time::operator+   date_time operator+(period::period_type f) const   Definition:  date_time.hpp:662     boost::locale::boundary::operator==   bool operator==(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:141     boost::locale::date_time_duration::start   date_time const  & start() const   Definition:  date_time.hpp:965     boost::locale::period::december   date_time_period december()   Definition:  date_time.hpp:274     boost::locale::period::era   period_type era()   Definition:  date_time.hpp:80     boost::locale::period::hour   period_type hour()   Definition:  date_time.hpp:122     boost::locale::hold_ptr   a smart pointer similar to std::auto_ptr but it is non-copyable and the underlying object has the sam...   Definition:  hold_ptr.hpp:19     boost::locale::ios_info::display_flags   void display_flags(uint64_t flags)     boost::locale::ios_info::get   static ios_info & get(std::ios_base &ios)     boost::locale::date_time::operator-=   date_time const  & operator-=(period::period_type f)   Definition:  date_time.hpp:685     boost::locale::period::marks::week_of_year   The week number in the year.   Definition:  date_time_facet.hpp:51     boost::locale::period::marks::hour   24 clock hour [0..23]   Definition:  date_time_facet.hpp:46     boost::locale::period::marks::invalid   Special invalid value, should not be used directly.   Definition:  date_time_facet.hpp:31     boost::locale::period::marks::day   The day of month, calendar specific, in Gregorian [1..31].   Definition:  date_time_facet.hpp:36     boost::locale::period::day_of_week_local   period_type day_of_week_local()   Definition:  date_time.hpp:118     boost::locale::period::marks::minute   minute [0..59]   Definition:  date_time_facet.hpp:49     boost::locale::period::marks::month   The month of year, calendar specific, in Gregorian [0..11].   Definition:  date_time_facet.hpp:35     boost::locale::period::marks::day_of_week_local   Local day of week, for example in France Monday is 1, in US Sunday is 1, [1..7].   Definition:  date_time_facet.hpp:45     boost::locale::period::operator-   date_time_period operator-(period::period_type f)   Definition:  date_time.hpp:323     boost::locale::period::operator *   date_time_period operator *(period::period_type f, T v)   Definition:  date_time.hpp:332     boost::locale::period::day_of_week_in_month   period_type day_of_week_in_month()   Definition:  date_time.hpp:114     boost::locale::date_time_duration::end   date_time const  & end() const   Definition:  date_time.hpp:969     boost::locale::period::marks::hour_12   12 clock hour [0..11]   Definition:  date_time_facet.hpp:47     boost::locale::date_time::operator-   date_time operator-(period::period_type f) const   Definition:  date_time.hpp:670     boost::locale::date_time_period   This class represents a pair of period_type and the integer values that describes its amount....   Definition:  date_time.hpp:53     boost::locale::period::pm   date_time_period pm()   Definition:  date_time.hpp:311     boost::locale::period::day   period_type day()   Definition:  date_time.hpp:96     boost::locale::period::year   period_type year()   Definition:  date_time.hpp:84     boost::locale::period::week_of_month   period_type week_of_month()   Definition:  date_time.hpp:146     boost::locale::date_time_period_set::operator[]   date_time_period const  & operator[](size_t n) const   Definition:  date_time.hpp:425     boost::locale::operator-   date_time_period_set operator-(date_time_period_set const &a, date_time_period_set const &b)   Definition:  date_time.hpp:454     boost::locale::period::wednesday   date_time_period wednesday()   Definition:  date_time.hpp:291     boost::locale::date_time::operator<<=   date_time const  & operator<<=(period::period_type f)   Definition:  date_time.hpp:709     boost::locale::date_time_error   This error is thrown in case of invalid state that occurred.   Definition:  date_time.hpp:36     boost::locale::period::thursday   date_time_period thursday()   Definition:  date_time.hpp:295     boost::locale::period::marks::am_pm   am or pm marker [0..1]   Definition:  date_time_facet.hpp:48     boost::locale::date_time_period_set::date_time_period_set   date_time_period_set(period::period_type f)   Definition:  date_time.hpp:385     boost::locale::date_time_period_set::date_time_period_set   date_time_period_set(date_time_period const &fl)   Definition:  date_time.hpp:392     boost::locale::period::sunday   date_time_period sunday()   Definition:  date_time.hpp:279     boost::locale::operator<<   std::basic_ostream< CharType > & operator<<(std::basic_ostream< CharType > &out, date_time const &t)   Definition:  date_time.hpp:871     boost::locale::date_time_period_set::size   size_t size() const   Definition:  date_time.hpp:410     boost::locale::period::friday   date_time_period friday()   Definition:  date_time.hpp:299     boost::locale::period::tuesday   date_time_period tuesday()   Definition:  date_time.hpp:287     boost::locale::date_time_period::value   int value   Definition:  date_time.hpp:56     boost::locale::period::operator+   date_time_period operator+(period::period_type f)   Definition:  date_time.hpp:316     boost::locale::date_time_duration::date_time_duration   date_time_duration(date_time const &first, date_time const &second)   Definition:  date_time.hpp:940     boost::locale::period::day_of_year   period_type day_of_year()   Definition:  date_time.hpp:100     boost::locale::period::marks::era   Era i.e. AC, BC in Gregorian and Julian calendar, range [0,1].   Definition:  date_time_facet.hpp:32     boost::locale::period::marks::first_day_of_week   First day of week, constant, for example Sunday in US = 1, Monday in France = 2.   Definition:  date_time_facet.hpp:53     boost::locale::operator+   date_time_period_set operator+(date_time_period_set const &a, date_time_period_set const &b)   Definition:  date_time.hpp:443     boost::locale::period::hour_12   period_type hour_12()   Definition:  date_time.hpp:126     boost::locale::operator>>   std::basic_istream< CharType > & operator>>(std::basic_istream< CharType > &in, date_time &t)   Definition:  date_time.hpp:898     boost::locale::period::marks::extended_year   Extended year for Gregorian/Julian calendars, where 1 BC == 0, 2 BC == -1.   Definition:  date_time_facet.hpp:34     boost::locale::period::invalid   period_type invalid()   Definition:  date_time.hpp:76     boost::locale::date_time::operator+=   date_time const  & operator+=(period::period_type f)   Definition:  date_time.hpp:678     boost::locale::period::june   date_time_period june()   Definition:  date_time.hpp:250     boost::locale::period::may   date_time_period may()   Definition:  date_time.hpp:246     boost::locale::date_time   this class represents a date time and allows to perform various operation according to the locale set...   Definition:  date_time.hpp:587     boost::locale::date_time::operator>>   date_time operator>>(period::period_type f) const   Definition:  date_time.hpp:701     boost::locale::date_time_period::operator-   date_time_period operator-() const   Definition:  date_time.hpp:64     boost::locale::as::time   std::ios_base & time(std::ios_base &ios)   Definition:  formatting.hpp:328     boost::locale::date_time_period::date_time_period   date_time_period(period::period_type f=period::period_type(), int v=1)   Definition:  date_time.hpp:69     boost::locale::boundary::operator>   bool operator>(segment< IteratorL > const &l, segment< IteratorR > const &r)  Compare two segments.   Definition:  segment.hpp:267     boost::locale::period::second   period_type second()   Definition:  date_time.hpp:138     boost::locale::period::marks::second   second [0..59]   Definition:  date_time_facet.hpp:50     boost::locale::period::month   period_type month()   Definition:  date_time.hpp:92     boost::locale::period::july   date_time_period july()   Definition:  date_time.hpp:254     boost::locale::boundary::operator!=   bool operator!=(BaseIterator const &l, boundary_point< BaseIterator > const &r)   Definition:  boundary_point.hpp:149     boost::locale::period::september   date_time_period september()   Definition:  date_time.hpp:262     boost::locale::date_time::operator/   int operator/(period::period_type f) const   Definition:  date_time.hpp:654     boost::locale::period::period_type   This class holds a type that represents certain period of time like year, hour, second and so on.   Definition:  date_time_facet.hpp:69             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('encoding_8hpp_source.html','');});/* @license-end */       encoding.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_ENCODING_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_ENCODING_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <boost/locale/info.hpp>         12 &#160; #include <boost/locale/encoding_errors.hpp>         13 &#160; #include <boost/locale/encoding_utf.hpp>         14 &#160;        15 &#160; #ifdef BOOST_MSVC         16 &#160; #  pragma warning(push)         17 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         18 &#160; #endif         19 &#160;        20 &#160; namespace  boost {        21 &#160;     namespace  locale {        22 &#160;         26  &#160;         namespace  conv {        31 &#160;        35 &#160;             template < typename  CharType>        36 &#160;            std::basic_string<CharType>  to_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how= default_method );        37 &#160;        41 &#160;             template < typename  CharType>        42 &#160;            std::string  from_utf (CharType  const  *begin,CharType  const  *end,std::string  const  &charset, method_type  how= default_method );        43 &#160;        49 &#160;             template < typename  CharType>         50  &#160;            std::basic_string<CharType>  to_utf ( char   const  *begin, char   const  *end,std::locale  const  &loc, method_type  how= default_method )        51 &#160;            {        52 &#160;                 return  to_utf<CharType>(begin,end,std::use_facet<info>(loc).encoding(),how);        53 &#160;            }        54 &#160;        60 &#160;             template < typename  CharType>         61  &#160;            std::string  from_utf (CharType  const  *begin,CharType  const  *end,std::locale  const  &loc, method_type  how= default_method )        62 &#160;            {        63 &#160;                 return   from_utf (begin,end,std::use_facet<info>(loc).encoding(),how);        64 &#160;            }        65 &#160;        69 &#160;        70 &#160;             template < typename  CharType>         71  &#160;            std::basic_string<CharType>  to_utf (std::string  const  &text,std::string  const  &charset, method_type  how= default_method )        72 &#160;            {        73 &#160;                 return  to_utf<CharType>(text.c_str(),text.c_str()+text.size(),charset,how);        74 &#160;            }        75 &#160;        79 &#160;             template < typename  CharType>         80  &#160;            std::string  from_utf (std::basic_string<CharType>  const  &text,std::string  const  &charset, method_type  how= default_method )        81 &#160;            {        82 &#160;                 return   from_utf (text.c_str(),text.c_str()+text.size(),charset,how);        83 &#160;            }        84 &#160;        88 &#160;             template < typename  CharType>         89  &#160;            std::basic_string<CharType>  to_utf ( char   const  *text,std::string  const  &charset, method_type  how= default_method )        90 &#160;            {        91 &#160;                 char   const  *text_end = text;        92 &#160;                 while (*text_end)        93 &#160;                    text_end++;        94 &#160;                 return  to_utf<CharType>(text,text_end,charset,how);        95 &#160;            }        96 &#160;       100 &#160;             template < typename  CharType>        101  &#160;            std::string  from_utf (CharType  const  *text,std::string  const  &charset, method_type  how= default_method )       102 &#160;            {       103 &#160;                CharType  const  *text_end = text;       104 &#160;                 while (*text_end)       105 &#160;                    text_end++;       106 &#160;                 return   from_utf (text,text_end,charset,how);       107 &#160;            }       108 &#160;       114 &#160;             template < typename  CharType>        115  &#160;            std::basic_string<CharType>  to_utf (std::string  const  &text,std::locale  const  &loc, method_type  how= default_method )       116 &#160;            {       117 &#160;                 return  to_utf<CharType>(text.c_str(),text.c_str()+text.size(),loc,how);       118 &#160;            }       119 &#160;       125 &#160;             template < typename  CharType>        126  &#160;            std::string  from_utf (std::basic_string<CharType>  const  &text,std::locale  const  &loc, method_type  how= default_method )       127 &#160;            {       128 &#160;                 return   from_utf (text.c_str(),text.c_str()+text.size(),loc,how);       129 &#160;            }       130 &#160;       136 &#160;             template < typename  CharType>        137  &#160;            std::basic_string<CharType>  to_utf ( char   const  *text,std::locale  const  &loc, method_type  how= default_method )       138 &#160;            {       139 &#160;                 char   const  *text_end = text;       140 &#160;                 while (*text_end)       141 &#160;                    text_end++;       142 &#160;                 return  to_utf<CharType>(text,text_end,loc,how);       143 &#160;            }       144 &#160;       150 &#160;             template < typename  CharType>        151  &#160;            std::string  from_utf (CharType  const  *text,std::locale  const  &loc, method_type  how= default_method )       152 &#160;            {       153 &#160;                CharType  const  *text_end = text;       154 &#160;                 while (*text_end)       155 &#160;                    text_end++;       156 &#160;                 return   from_utf (text,text_end,loc,how);       157 &#160;            }       158 &#160;       159 &#160;       163 &#160;       164 &#160;            BOOST_LOCALE_DECL       165 &#160;            std::string  between ( char   const  *begin,       166 &#160;                                 char   const  *end,       167 &#160;                                std::string  const  &to_encoding,       168 &#160;                                std::string  const  &from_encoding,       169 &#160;                                 method_type  how= default_method );       170 &#160;       174 &#160;       175 &#160;             inline         176  &#160;            std::string  between ( char   const  *text,       177 &#160;                                std::string  const  &to_encoding,       178 &#160;                                std::string  const  &from_encoding,       179 &#160;                                 method_type  how= default_method )       180 &#160;            {       181 &#160;                 char   const  *end=text;       182 &#160;                 while (*end)       183 &#160;                    end++;       184 &#160;                 return   boost::locale::conv::between (text,end,to_encoding,from_encoding,how);       185 &#160;            }       186 &#160;       190 &#160;             inline         191  &#160;            std::string  between (std::string  const  &text,       192 &#160;                                std::string  const  &to_encoding,       193 &#160;                                std::string  const  &from_encoding,       194 &#160;                                 method_type  how= default_method )       195 &#160;            {       196 &#160;                 return   boost::locale::conv::between (text.c_str(),text.c_str()+text.size(),to_encoding,from_encoding,how);       197 &#160;            }       198 &#160;       200 &#160;       201 &#160;             template <>       202 &#160;            BOOST_LOCALE_DECL std::basic_string<char>  to_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how);       203 &#160;       204 &#160;             template <>       205 &#160;            BOOST_LOCALE_DECL std::string  from_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how);       206 &#160;       207 &#160;             template <>       208 &#160;            BOOST_LOCALE_DECL std::basic_string<wchar_t>  to_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how);       209 &#160;       210 &#160;             template <>       211 &#160;            BOOST_LOCALE_DECL std::string  from_utf ( wchar_t   const  *begin, wchar_t   const  *end,std::string  const  &charset, method_type  how);       212 &#160;       213 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        214 &#160;             template <>       215 &#160;            BOOST_LOCALE_DECL std::basic_string<char16_t>  to_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how);       216 &#160;       217 &#160;             template <>       218 &#160;            BOOST_LOCALE_DECL std::string  from_utf (char16_t  const  *begin,char16_t  const  *end,std::string  const  &charset, method_type  how);       219 &#160;             #endif        220 &#160;       221 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        222 &#160;             template <>       223 &#160;            BOOST_LOCALE_DECL std::basic_string<char32_t>  to_utf ( char   const  *begin, char   const  *end,std::string  const  &charset, method_type  how);       224 &#160;       225 &#160;             template <>       226 &#160;            BOOST_LOCALE_DECL std::string  from_utf (char32_t  const  *begin,char32_t  const  *end,std::string  const  &charset, method_type  how);       227 &#160;             #endif        228 &#160;       229 &#160;       231 &#160;       233 &#160;       234 &#160;        }  // conv        235 &#160;       236 &#160;    }  // locale        237 &#160;}  // boost        238 &#160;       239 &#160; #ifdef BOOST_MSVC        240 &#160; #pragma warning(pop)        241 &#160; #endif        242 &#160;       243 &#160; #endif        244 &#160;       245 &#160;    boost::locale::conv::from_utf   std::string from_utf(CharType const *begin, CharType const *end, std::string const &charset, method_type how=default_method)     boost::locale::conv::to_utf   std::basic_string< CharType > to_utf(char const *begin, char const *end, std::string const &charset, method_type how=default_method)     boost::locale::conv::default_method   Default method - skip.   Definition:  encoding_errors.hpp:55     boost::locale::conv::between   std::string between(char const *begin, char const *end, std::string const &to_encoding, std::string const &from_encoding, method_type how=default_method)     boost::locale::conv::method_type   method_type   Definition:  encoding_errors.hpp:52             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('generic__codecvt_8hpp_source.html','');});/* @license-end */       generic_codecvt.hpp                1 &#160; //          2 &#160; // Copyright (c) 2015 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_GENERIC_CODECVT_HPP          8 &#160; #define BOOST_LOCALE_GENERIC_CODECVT_HPP          9 &#160;        10 &#160; #include <boost/locale/utf.hpp>         11 &#160; #include <boost/cstdint.hpp>         12 &#160; #include <boost/static_assert.hpp>         13 &#160; #include <locale>         14 &#160;        15 &#160; namespace  boost {        16 &#160; namespace  locale {        17 &#160;        18 &#160; #ifndef BOOST_LOCALE_DOXYGEN         19 &#160; //         20 &#160; // Make sure that mbstate can keep 16 bit of UTF-16 sequence         21 &#160; //         22 &#160;BOOST_STATIC_ASSERT( sizeof (std::mbstate_t)>=2);        23 &#160; #endif         24 &#160;        25 &#160; #if defined(_MSC_VER) && _MSC_VER < 1700         26 &#160; // up to MSVC 11 (2012) do_length is non-standard it counts wide characters instead of narrow and does not change mbstate         27 &#160; #define BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST         28 &#160; #endif         29 &#160;         33  &#160; class   generic_codecvt_base  {        34 &#160; public :         38  &#160;     enum   initial_convertion_state  {         39  &#160;         to_unicode_state ,          40  &#160;         from_unicode_state          41 &#160;    };        42 &#160;};        43 &#160;       138 &#160; template < typename  CharType, typename  CodecvtImpl, int  CharSize=sizeof(CharType)>        139  &#160; class   generic_codecvt ;       140 &#160;       149 &#160; template < typename  CharType, typename  CodecvtImpl>        150  &#160; class   generic_codecvt <CharType,CodecvtImpl,2> :  public  std::codecvt<CharType,char,std::mbstate_t>,  public   generic_codecvt_base        151 &#160;{       152 &#160; public :       153 &#160;       154 &#160;     typedef  CharType uchar;       155 &#160;       156 &#160;     generic_codecvt ( size_t  refs = 0) :       157 &#160;        std::codecvt<CharType,char,std::mbstate_t>(refs)       158 &#160;    {       159 &#160;    }       160 &#160;    CodecvtImpl  const  &implementation()  const        161 &#160;      {       162 &#160;         return  *static_cast<CodecvtImpl const *>( this );       163 &#160;    }       164 &#160;       165 &#160; protected :       166 &#160;       167 &#160;       168 &#160;    std::codecvt_base::result do_unshift(std::mbstate_t &s, char  *from, char  *  /*to*/ , char  *&next)  const  BOOST_OVERRIDE       169 &#160;    {       170 &#160;        boost::uint16_t &state = *reinterpret_cast<boost::uint16_t *>(&s);       171 &#160; #ifdef DEBUG_CODECVT        172 &#160;        std::cout <<  &quot;Entering unshift &quot;  << std::hex << state << std::dec << std::endl;       173 &#160; #endif        174 &#160;         if (state != 0)       175 &#160;             return  std::codecvt_base::error;       176 &#160;        next=from;       177 &#160;         return  std::codecvt_base::ok;       178 &#160;    }       179 &#160;     int  do_encoding()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       180 &#160;    {       181 &#160;         return  0;       182 &#160;    }       183 &#160;     int  do_max_length()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       184 &#160;    {       185 &#160;         return  implementation().max_encoding_length();       186 &#160;    }       187 &#160;     bool  do_always_noconv()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       188 &#160;    {       189 &#160;         return   false ;       190 &#160;    }       191 &#160;       192 &#160;     int        193 &#160;    do_length(  std::mbstate_t       194 &#160;    #ifdef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST       195 &#160;             const        196 &#160;    #endif       197 &#160;            &std_state,       198 &#160;             char   const  *from,       199 &#160;             char   const  *from_end,       200 &#160;             size_t  max)  const  BOOST_OVERRIDE       201 &#160;    {       202 &#160;         #ifndef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST        203 &#160;         char   const  *save_from = from;       204 &#160;        boost::uint16_t &state = *reinterpret_cast<boost::uint16_t *>(&std_state);       205 &#160;         #else        206 &#160;         size_t  save_max = max;       207 &#160;        boost::uint16_t state = *reinterpret_cast<boost::uint16_t const *>(&std_state);       208 &#160;         #endif        209 &#160;       210 &#160;         typename  CodecvtImpl::state_type cvt_state = implementation().initial_state( generic_codecvt_base::to_unicode_state );       211 &#160;         while (max > 0 && from < from_end){       212 &#160;             char   const  *prev_from = from;       213 &#160;            boost::uint32_t ch=implementation().to_unicode(cvt_state,from,from_end);       214 &#160;             if (ch== boost::locale::utf::incomplete  || ch== boost::locale::utf::illegal ) {       215 &#160;                from = prev_from;       216 &#160;                 break ;       217 &#160;            }       218 &#160;            max --;       219 &#160;             if (ch > 0xFFFF) {       220 &#160;                 if (state == 0) {       221 &#160;                    from = prev_from;       222 &#160;                    state = 1;       223 &#160;                }       224 &#160;                 else  {       225 &#160;                    state = 0;       226 &#160;                }       227 &#160;            }       228 &#160;        }       229 &#160;         #ifndef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST        230 &#160;         return  static_cast<int>(from - save_from);       231 &#160;         #else        232 &#160;         return  static_cast<int>(save_max - max);       233 &#160;         #endif        234 &#160;    }       235 &#160;       236 &#160;       237 &#160;    std::codecvt_base::result       238 &#160;    do_in(  std::mbstate_t &std_state,       239 &#160;             char   const  *from,       240 &#160;             char   const  *from_end,       241 &#160;             char   const  *&from_next,       242 &#160;            uchar *to,       243 &#160;            uchar *to_end,       244 &#160;            uchar *&to_next)  const  BOOST_OVERRIDE       245 &#160;    {       246 &#160;        std::codecvt_base::result r=std::codecvt_base::ok;       247 &#160;       248 &#160;         // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())        249 &#160;         // according to standard. We use it to keep a flag 0/1 for surrogate pair writing        250 &#160;         //        251 &#160;         // if 0 no code above >0xFFFF observed, of 1 a code above 0xFFFF observerd        252 &#160;         // and first pair is written, but no input consumed        253 &#160;        boost::uint16_t &state = *reinterpret_cast<boost::uint16_t *>(&std_state);       254 &#160;         typename  CodecvtImpl::state_type cvt_state = implementation().initial_state( generic_codecvt_base::to_unicode_state );       255 &#160;         while (to < to_end && from < from_end)       256 &#160;        {       257 &#160; #ifdef DEBUG_CODECVT        258 &#160;            std::cout <<  &quot;Entering IN--------------\n&quot; ;       259 &#160;            std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       260 &#160;            std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       261 &#160; #endif        262 &#160;             char   const  *from_saved = from;       263 &#160;       264 &#160;            uint32_t ch=implementation().to_unicode(cvt_state,from,from_end);       265 &#160;       266 &#160;             if (ch== boost::locale::utf::illegal ) {       267 &#160;                from = from_saved;       268 &#160;                r=std::codecvt_base::error;       269 &#160;                 break ;       270 &#160;            }       271 &#160;             if (ch== boost::locale::utf::incomplete ) {       272 &#160;                from = from_saved;       273 &#160;                r=std::codecvt_base::partial;       274 &#160;                 break ;       275 &#160;            }       276 &#160;             // Normal codepoints go direcly to stream        277 &#160;             if (ch <= 0xFFFF) {       278 &#160;                *to++ = static_cast<uchar>(ch);       279 &#160;            }       280 &#160;             else  {       281 &#160;                 // for  other codepoints we do following        282 &#160;                 //        283 &#160;                 // 1. We can&#39;t consume our input as we may find ourselfs        284 &#160;                 //    in state where all input consumed but not all output written,i.e. only        285 &#160;                 //    1st pair is written        286 &#160;                 // 2. We only write first pair and mark this in the state, we also revert back        287 &#160;                 //    the from pointer in order to make sure this codepoint would be read        288 &#160;                 //    once again and then we would consume our input together with writing        289 &#160;                 //    second surrogate pair        290 &#160;                ch-=0x10000;       291 &#160;                boost::uint16_t w1 = static_cast<boost::uint16_t>(0xD800 | (ch >> 10));       292 &#160;                boost::uint16_t w2 = static_cast<boost::uint16_t>(0xDC00 | (ch & 0x3FF));       293 &#160;                 if (state == 0) {       294 &#160;                    from = from_saved;       295 &#160;                    *to++ = w1;       296 &#160;                    state = 1;       297 &#160;                }       298 &#160;                 else  {       299 &#160;                    *to++ = w2;       300 &#160;                    state = 0;       301 &#160;                }       302 &#160;            }       303 &#160;        }       304 &#160;        from_next=from;       305 &#160;        to_next=to;       306 &#160;         if (r == std::codecvt_base::ok && (from!=from_end || state!=0))       307 &#160;            r = std::codecvt_base::partial;       308 &#160; #ifdef DEBUG_CODECVT        309 &#160;        std::cout <<  &quot;Returning &quot; ;       310 &#160;         switch (r) {       311 &#160;         case  std::codecvt_base::ok:       312 &#160;            std::cout <<  &quot;ok\n&quot; ;       313 &#160;             break ;       314 &#160;         case  std::codecvt_base::partial:       315 &#160;            std::cout <<  &quot;partial\n&quot; ;       316 &#160;             break ;       317 &#160;         case  std::codecvt_base::error:       318 &#160;            std::cout <<  &quot;error\n&quot; ;       319 &#160;             break ;       320 &#160;         default :       321 &#160;            std::cout <<  &quot;other\n&quot; ;       322 &#160;             break ;       323 &#160;        }       324 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       325 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       326 &#160; #endif        327 &#160;         return  r;       328 &#160;    }       329 &#160;       330 &#160;    std::codecvt_base::result       331 &#160;    do_out( std::mbstate_t &std_state,       332 &#160;            uchar  const  *from,       333 &#160;            uchar  const  *from_end,       334 &#160;            uchar  const  *&from_next,       335 &#160;             char  *to,       336 &#160;             char  *to_end,       337 &#160;             char  *&to_next)  const  BOOST_OVERRIDE       338 &#160;    {       339 &#160;        std::codecvt_base::result r=std::codecvt_base::ok;       340 &#160;         // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())        341 &#160;         // according to standard. We assume that sizeof(mbstate_t) >=2 in order        342 &#160;         // to be able to store first observed surrogate pair        343 &#160;         //        344 &#160;         // State: state!=0 - a first surrogate pair was observerd (state = first pair),        345 &#160;         // we expect the second one to come and then zero the state        347 &#160;          boost::uint16_t &state = *reinterpret_cast<boost::uint16_t *>(&std_state);       348 &#160;         typename  CodecvtImpl::state_type cvt_state = implementation().initial_state( generic_codecvt_base::from_unicode_state );       349 &#160;         while (to < to_end && from < from_end)       350 &#160;        {       351 &#160; #ifdef DEBUG_CODECVT        352 &#160;        std::cout <<  &quot;Entering OUT --------------\n&quot; ;       353 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       354 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       355 &#160; #endif        356 &#160;            boost::uint32_t ch=0;       357 &#160;             if (state != 0) {       358 &#160;                 // if the state indicates that 1st surrogate pair was written        359 &#160;                 // we should make sure that the second one that comes is actually        360 &#160;                 // second surrogate        361 &#160;                boost::uint16_t w1 = state;       362 &#160;                boost::uint16_t w2 = *from;       363 &#160;                 // we don&#39;t forward from as writing may fail to incomplete or        364 &#160;                 // partial conversion        365 &#160;                 if (0xDC00 <= w2 && w2<=0xDFFF) {       366 &#160;                    boost::uint16_t vh = w1 - 0xD800;       367 &#160;                    boost::uint16_t vl = w2 - 0xDC00;       368 &#160;                    ch=((uint32_t(vh) << 10)  | vl) + 0x10000;       369 &#160;                }       370 &#160;                 else  {       371 &#160;                     // Invalid surrogate        372 &#160;                    r=std::codecvt_base::error;       373 &#160;                     break ;       374 &#160;                }       375 &#160;            }       376 &#160;             else  {       377 &#160;                ch = *from;       378 &#160;                 if (0xD800 <= ch && ch<=0xDBFF) {       379 &#160;                     // if this is a first surrogate pair we put        380 &#160;                     // it into the state and consume it, note we don&#39;t        381 &#160;                     // go forward as it should be illegal so we increase        382 &#160;                     // the from pointer manually        383 &#160;                    state = static_cast<uint16_t>(ch);       384 &#160;                    from++;       385 &#160;                     continue ;       386 &#160;                }       387 &#160;                 else   if (0xDC00 <= ch && ch<=0xDFFF) {       388 &#160;                     // if we observe second surrogate pair and        389 &#160;                     // first only may be expected we should break from the loop with error        390 &#160;                     // as it is illegal input        391 &#160;                    r=std::codecvt_base::error;       392 &#160;                     break ;       393 &#160;                }       394 &#160;            }       395 &#160;             if (! boost::locale::utf::is_valid_codepoint (ch)) {       396 &#160;                r=std::codecvt_base::error;       397 &#160;                 break ;       398 &#160;            }       399 &#160;            boost::uint32_t len = implementation().from_unicode(cvt_state,ch,to,to_end);       400 &#160;             if (len ==  boost::locale::utf::incomplete ) {       401 &#160;                r=std::codecvt_base::partial;       402 &#160;                 break ;       403 &#160;            }       404 &#160;             else   if (len ==  boost::locale::utf::illegal ) {       405 &#160;                r=std::codecvt_base::error;       406 &#160;                 break ;       407 &#160;            }       408 &#160;             else        409 &#160;                    to+= len;       410 &#160;            state = 0;       411 &#160;            from++;       412 &#160;        }       413 &#160;        from_next=from;       414 &#160;        to_next=to;       415 &#160;         if (r==std::codecvt_base::ok && from!=from_end)       416 &#160;            r = std::codecvt_base::partial;       417 &#160; #ifdef DEBUG_CODECVT        418 &#160;        std::cout <<  &quot;Returning &quot; ;       419 &#160;         switch (r) {       420 &#160;         case  std::codecvt_base::ok:       421 &#160;            std::cout <<  &quot;ok\n&quot; ;       422 &#160;             break ;       423 &#160;         case  std::codecvt_base::partial:       424 &#160;            std::cout <<  &quot;partial\n&quot; ;       425 &#160;             break ;       426 &#160;         case  std::codecvt_base::error:       427 &#160;            std::cout <<  &quot;error\n&quot; ;       428 &#160;             break ;       429 &#160;         default :       430 &#160;            std::cout <<  &quot;other\n&quot; ;       431 &#160;             break ;       432 &#160;        }       433 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       434 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       435 &#160; #endif        436 &#160;         return  r;       437 &#160;    }       438 &#160;       439 &#160;};       440 &#160;       447 &#160; template < typename  CharType, typename  CodecvtImpl>        448  &#160; class   generic_codecvt <CharType,CodecvtImpl,4> :  public  std::codecvt<CharType,char,std::mbstate_t>,  public   generic_codecvt_base        449 &#160;{       450 &#160; public :       451 &#160;     typedef  CharType uchar;       452 &#160;       453 &#160;     generic_codecvt ( size_t  refs = 0) :       454 &#160;        std::codecvt<CharType,char,std::mbstate_t>(refs)       455 &#160;    {       456 &#160;    }       457 &#160;       458 &#160;    CodecvtImpl  const  &implementation()  const        459 &#160;      {       460 &#160;         return  *static_cast<CodecvtImpl const *>( this );       461 &#160;    }       462 &#160;       463 &#160; protected :       464 &#160;       465 &#160;    std::codecvt_base::result do_unshift(std::mbstate_t & /*s*/ , char  *from, char  *  /*to*/ , char  *&next)  const  BOOST_OVERRIDE       466 &#160;    {       467 &#160;        next=from;       468 &#160;         return  std::codecvt_base::ok;       469 &#160;    }       470 &#160;     int  do_encoding()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       471 &#160;    {       472 &#160;         return  0;       473 &#160;    }       474 &#160;     int  do_max_length()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       475 &#160;    {       476 &#160;         return  implementation().max_encoding_length();       477 &#160;    }       478 &#160;     bool  do_always_noconv()  const  BOOST_NOEXCEPT_OR_NOTHROW BOOST_OVERRIDE       479 &#160;    {       480 &#160;         return   false ;       481 &#160;    }       482 &#160;       483 &#160;     int        484 &#160;    do_length(  std::mbstate_t       485 &#160;    #ifdef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST       486 &#160;             const        487 &#160;    #endif       488 &#160;            & /*state*/ ,       489 &#160;             char   const  *from,       490 &#160;             char   const  *from_end,       491 &#160;             size_t  max)  const  BOOST_OVERRIDE       492 &#160;    {       493 &#160;         #ifndef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST        494 &#160;         char   const  *start_from = from;       495 &#160;         #else        496 &#160;         size_t  save_max = max;       497 &#160;         #endif        498 &#160;         typename  CodecvtImpl::state_type cvt_state = implementation().initial_state( generic_codecvt_base::to_unicode_state );       499 &#160;         while (max > 0 && from < from_end){       500 &#160;             char   const  *save_from = from;       501 &#160;            boost::uint32_t ch=implementation().to_unicode(cvt_state,from,from_end);       502 &#160;             if (ch== boost::locale::utf::incomplete  || ch== boost::locale::utf::illegal ) {       503 &#160;                from = save_from;       504 &#160;                 break ;       505 &#160;            }       506 &#160;            max--;       507 &#160;        }       508 &#160;         #ifndef BOOST_LOCALE_DO_LENGTH_MBSTATE_CONST        509 &#160;         return  from - start_from;       510 &#160;         #else        511 &#160;         return  save_max - max;       512 &#160;         #endif        513 &#160;    }       514 &#160;       515 &#160;       516 &#160;    std::codecvt_base::result       517 &#160;    do_in(  std::mbstate_t & /*state*/ ,       518 &#160;             char   const  *from,       519 &#160;             char   const  *from_end,       520 &#160;             char   const  *&from_next,       521 &#160;            uchar *to,       522 &#160;            uchar *to_end,       523 &#160;            uchar *&to_next)  const  BOOST_OVERRIDE       524 &#160;    {       525 &#160;        std::codecvt_base::result r=std::codecvt_base::ok;       526 &#160;       527 &#160;         // mbstate_t is POD type and should be initialized to 0 (i.a. state = stateT())        528 &#160;         // according to standard. We use it to keep a flag 0/1 for surrogate pair writing        529 &#160;         //        530 &#160;         // if 0 no code above >0xFFFF observed, of 1 a code above 0xFFFF observerd        531 &#160;         // and first pair is written, but no input consumed        532 &#160;         typedef   typename  CodecvtImpl::state_type state_type;       533 &#160;        state_type cvt_state = implementation().initial_state( generic_codecvt_base::to_unicode_state );       534 &#160;         while (to < to_end && from < from_end)       535 &#160;        {       536 &#160; #ifdef DEBUG_CODECVT        537 &#160;            std::cout <<  &quot;Entering IN--------------\n&quot; ;       538 &#160;            std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       539 &#160;            std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       540 &#160; #endif        541 &#160;             char   const  *from_saved = from;       542 &#160;       543 &#160;            uint32_t ch=implementation().to_unicode(cvt_state,from,from_end);       544 &#160;       545 &#160;             if (ch== boost::locale::utf::illegal ) {       546 &#160;                r=std::codecvt_base::error;       547 &#160;                from = from_saved;       548 &#160;                 break ;       549 &#160;            }       550 &#160;             if (ch== boost::locale::utf::incomplete ) {       551 &#160;                r=std::codecvt_base::partial;       552 &#160;                from=from_saved;       553 &#160;                 break ;       554 &#160;            }       555 &#160;            *to++=ch;       556 &#160;        }       557 &#160;        from_next=from;       558 &#160;        to_next=to;       559 &#160;         if (r == std::codecvt_base::ok && from!=from_end)       560 &#160;            r = std::codecvt_base::partial;       561 &#160; #ifdef DEBUG_CODECVT        562 &#160;        std::cout <<  &quot;Returning &quot; ;       563 &#160;         switch (r) {       564 &#160;         case  std::codecvt_base::ok:       565 &#160;            std::cout <<  &quot;ok\n&quot; ;       566 &#160;             break ;       567 &#160;         case  std::codecvt_base::partial:       568 &#160;            std::cout <<  &quot;partial\n&quot; ;       569 &#160;             break ;       570 &#160;         case  std::codecvt_base::error:       571 &#160;            std::cout <<  &quot;error\n&quot; ;       572 &#160;             break ;       573 &#160;         default :       574 &#160;            std::cout <<  &quot;other\n&quot; ;       575 &#160;             break ;       576 &#160;        }       577 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       578 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       579 &#160; #endif        580 &#160;         return  r;       581 &#160;    }       582 &#160;       583 &#160;    std::codecvt_base::result       584 &#160;    do_out( std::mbstate_t & /*std_state*/ ,       585 &#160;            uchar  const  *from,       586 &#160;            uchar  const  *from_end,       587 &#160;            uchar  const  *&from_next,       588 &#160;             char  *to,       589 &#160;             char  *to_end,       590 &#160;             char  *&to_next)  const  BOOST_OVERRIDE       591 &#160;    {       592 &#160;        std::codecvt_base::result r=std::codecvt_base::ok;       593 &#160;         typedef   typename  CodecvtImpl::state_type state_type;       594 &#160;        state_type cvt_state = implementation().initial_state( generic_codecvt_base::from_unicode_state );       595 &#160;         while (to < to_end && from < from_end)       596 &#160;        {       597 &#160; #ifdef DEBUG_CODECVT        598 &#160;        std::cout <<  &quot;Entering OUT --------------\n&quot; ;       599 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       600 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       601 &#160; #endif        602 &#160;            boost::uint32_t ch=0;       603 &#160;            ch = *from;       604 &#160;             if (! boost::locale::utf::is_valid_codepoint (ch)) {       605 &#160;                r=std::codecvt_base::error;       606 &#160;                 break ;       607 &#160;            }       608 &#160;            boost::uint32_t len = implementation().from_unicode(cvt_state,ch,to,to_end);       609 &#160;             if (len ==  boost::locale::utf::incomplete ) {       610 &#160;                r=std::codecvt_base::partial;       611 &#160;                 break ;       612 &#160;            }       613 &#160;             else   if (len ==  boost::locale::utf::illegal ) {       614 &#160;                r=std::codecvt_base::error;       615 &#160;                 break ;       616 &#160;            }       617 &#160;            to+=len;       618 &#160;            from++;       619 &#160;        }       620 &#160;        from_next=from;       621 &#160;        to_next=to;       622 &#160;         if (r==std::codecvt_base::ok && from!=from_end)       623 &#160;            r = std::codecvt_base::partial;       624 &#160; #ifdef DEBUG_CODECVT        625 &#160;        std::cout <<  &quot;Returning &quot; ;       626 &#160;         switch (r) {       627 &#160;         case  std::codecvt_base::ok:       628 &#160;            std::cout <<  &quot;ok\n&quot; ;       629 &#160;             break ;       630 &#160;         case  std::codecvt_base::partial:       631 &#160;            std::cout <<  &quot;partial\n&quot; ;       632 &#160;             break ;       633 &#160;         case  std::codecvt_base::error:       634 &#160;            std::cout <<  &quot;error\n&quot; ;       635 &#160;             break ;       636 &#160;         default :       637 &#160;            std::cout <<  &quot;other\n&quot; ;       638 &#160;             break ;       639 &#160;        }       640 &#160;        std::cout <<  &quot;State &quot;  << std::hex << state << std::endl;       641 &#160;        std::cout <<  &quot;Left in &quot;  << std::dec << from_end - from <<  &quot; out &quot;  << to_end -to << std::endl;       642 &#160; #endif        643 &#160;         return  r;       644 &#160;    }       645 &#160;};       646 &#160;       647 &#160;       648 &#160; template < typename  CharType, typename  CodecvtImpl>        649  &#160; class   generic_codecvt <CharType,CodecvtImpl,1> :  public  std::codecvt<CharType,char,std::mbstate_t>,  public   generic_codecvt_base        650 &#160;{       651 &#160; public :       652 &#160;     typedef  CharType uchar;       653 &#160;       654 &#160;    CodecvtImpl  const  &implementation()  const        655 &#160;      {       656 &#160;         return  *static_cast<CodecvtImpl const *>( this );       657 &#160;    }       658 &#160;       659 &#160;     generic_codecvt ( size_t  refs = 0) :  std::codecvt<char,char,std::mbstate_t>(refs)       660 &#160;    {       661 &#160;    }       662 &#160;};       663 &#160;       664 &#160;}  // locale        665 &#160;}  // namespace boost        666 &#160;       667 &#160; #endif        668 &#160;   boost::locale::utf::is_valid_codepoint   bool is_valid_codepoint(code_point v)  the function checks if v is a valid code point   Definition:  utf.hpp:49     boost::locale::generic_codecvt_base::to_unicode_state   The state would be used by to_unicode functions.   Definition:  generic_codecvt.hpp:39     boost::locale::utf::incomplete   static const code_point incomplete  Special constant that defines incomplete code point.   Definition:  utf.hpp:44     boost::locale::generic_codecvt_base::initial_convertion_state   initial_convertion_state   Definition:  generic_codecvt.hpp:38     boost::locale::utf::illegal   static const code_point illegal  Special constant that defines illegal code point.   Definition:  utf.hpp:39     boost::locale::generic_codecvt_base   A base class that used to define constants for generic_codecvt.   Definition:  generic_codecvt.hpp:33     boost::locale::generic_codecvt   Geneneric generic codecvt facet, various stateless encodings to UTF-16 and UTF-32 using wchar_t,...   Definition:  generic_codecvt.hpp:139     boost::locale::generic_codecvt_base::from_unicode_state   The state would be used by from_unicode functions.   Definition:  generic_codecvt.hpp:40             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('boundary_8hpp_source.html','');});/* @license-end */       boundary.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/boundary/types.hpp>         11 &#160; #include <boost/locale/boundary/facets.hpp>         12 &#160; #include <boost/locale/boundary/segment.hpp>         13 &#160; #include <boost/locale/boundary/boundary_point.hpp>         14 &#160; #include <boost/locale/boundary/index.hpp>         15 &#160;        16 &#160; #endif             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('message_8hpp_source.html','');});/* @license-end */       message.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_MESSAGE_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_MESSAGE_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/formatting.hpp>         11 &#160; #include <locale>         12 &#160; #include <memory>         13 &#160; #include <set>         14 &#160; #include <string>         15 &#160;        16 &#160; #ifdef BOOST_MSVC         17 &#160; #  pragma warning(push)         18 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         19 &#160; #endif         20 &#160;        21 &#160; // glibc < 2.3.4 declares those as macros if compiled with optimization turned on         22 &#160; #ifdef gettext         23 &#160; #  undef gettext         24 &#160; #  undef ngettext         25 &#160; #  undef dgettext         26 &#160; #  undef dngettext         27 &#160; #endif         28 &#160;        29 &#160; namespace  boost {        30 &#160;     namespace  locale {        38 &#160;        40 &#160;        41 &#160;         template < typename  CharType>        42 &#160;         struct  base_message_format;        43 &#160;        45 &#160;        49 &#160;         template < typename  CharType>         50  &#160;         class  BOOST_SYMBOL_VISIBLE  message_format  :  public  base_message_format<CharType>        51 &#160;        {        52 &#160;         public :        53 &#160;         57  &#160;             typedef  CharType  char_type ;         61  &#160;             typedef  std::basic_string<CharType>  string_type ;        62 &#160;         66  &#160;             message_format ( size_t  refs = 0) : base_message_format<CharType>(refs)        67 &#160;            {        68 &#160;            }        69 &#160;        80 &#160;             virtual  char_type  const  *get( int  domain_id,char_type  const  *context,char_type  const  * id )  const  = 0;        94 &#160;             virtual  char_type  const  *get( int  domain_id,char_type  const  *context,char_type  const  *single_id, int  n)  const  = 0;        95 &#160;        99 &#160;             virtual   int   domain (std::string  const  & domain )  const  = 0;       100 &#160;       109 &#160;             virtual  char_type  const  *convert(char_type  const  *msg,string_type &buffer)  const  = 0;       110 &#160;       111 &#160; #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        112 &#160;            std::locale::id& __get_id ( void )  const  {  return  id; }       113 &#160; #endif        114 &#160;         protected :       115 &#160;             virtual  ~message_format() {}       116 &#160;        };       117 &#160;       119 &#160;       120 &#160;         namespace  details {       121 &#160;             inline   bool  is_us_ascii_char( char  c)       122 &#160;            {       123 &#160;                 // works for null terminated strings regardless char &quot;signness&quot;        124 &#160;                 return  0<c && c<0x7F;       125 &#160;            }       126 &#160;             inline   bool  is_us_ascii_string( char   const  *msg)       127 &#160;            {       128 &#160;                 while (*msg) {       129 &#160;                     if (!is_us_ascii_char(*msg++))       130 &#160;                         return   false ;       131 &#160;                }       132 &#160;                 return   true ;       133 &#160;            }       134 &#160;       135 &#160;             template < typename  CharType>       136 &#160;             struct  string_cast_traits {       137 &#160;                 static  CharType  const  *cast(CharType  const  *msg,std::basic_string<CharType> & /*unused*/ )       138 &#160;                {       139 &#160;                     return  msg;       140 &#160;                }       141 &#160;            };       142 &#160;       143 &#160;             template <>       144 &#160;             struct  string_cast_traits<char> {       145 &#160;                 static   char   const  *cast( char   const  *msg,std::string &buffer)       146 &#160;                {       147 &#160;                     if (is_us_ascii_string(msg))       148 &#160;                         return  msg;       149 &#160;                    buffer.reserve(strlen(msg));       150 &#160;                     char  c;       151 &#160;                     while ((c=*msg++)!=0) {       152 &#160;                         if (is_us_ascii_char(c))       153 &#160;                            buffer+=c;       154 &#160;                    }       155 &#160;                     return  buffer.c_str();       156 &#160;                }       157 &#160;            };       158 &#160;        }  // details        159 &#160;       161 &#160;       169 &#160;         template < typename  CharType>        170  &#160;         class   basic_message  {       171 &#160;         public :       172 &#160;        173  &#160;             typedef  CharType  char_type ;         174  &#160;             typedef  std::basic_string<char_type>  string_type ;           175  &#160;             typedef   message_format<char_type>   facet_type ;          176 &#160;        180  &#160;             basic_message () :       181 &#160;                n_(0),       182 &#160;                c_id_(0),       183 &#160;                c_context_(0),       184 &#160;                c_plural_(0)       185 &#160;            {       186 &#160;            }       187 &#160;        192  &#160;             explicit   basic_message ( char_type   const  * id ) :       193 &#160;                n_(0),       194 &#160;                c_id_(id),       195 &#160;                c_context_(0),       196 &#160;                c_plural_(0)       197 &#160;            {       198 &#160;            }       199 &#160;        206  &#160;             explicit   basic_message ( char_type   const  *single, char_type   const  *plural, int  n) :       207 &#160;                n_(n),       208 &#160;                c_id_(single),       209 &#160;                c_context_(0),       210 &#160;                c_plural_(plural)       211 &#160;            {       212 &#160;            }       213 &#160;        219  &#160;             explicit   basic_message ( char_type   const  *context, char_type   const  * id ) :       220 &#160;                n_(0),       221 &#160;                c_id_(id),       222 &#160;                c_context_(context),       223 &#160;                c_plural_(0)       224 &#160;            {       225 &#160;            }       226 &#160;        233  &#160;             explicit   basic_message ( char_type   const  *context, char_type   const  *single, char_type   const  *plural, int  n) :       234 &#160;                n_(n),       235 &#160;                c_id_(single),       236 &#160;                c_context_(context),       237 &#160;                c_plural_(plural)       238 &#160;            {       239 &#160;            }       240 &#160;       241 &#160;        245  &#160;             explicit   basic_message ( string_type   const  & id ) :       246 &#160;                n_(0),       247 &#160;                c_id_(0),       248 &#160;                c_context_(0),       249 &#160;                c_plural_(0),       250 &#160;                id_(id)       251 &#160;            {       252 &#160;            }       253 &#160;        259  &#160;             explicit   basic_message ( string_type   const  &single, string_type   const  &plural, int   number ) :       260 &#160;                n_( number ),       261 &#160;                c_id_(0),       262 &#160;                c_context_(0),       263 &#160;                c_plural_(0),       264 &#160;                id_(single),       265 &#160;                plural_(plural)       266 &#160;            {       267 &#160;            }       268 &#160;        272  &#160;             explicit   basic_message ( string_type   const  &context, string_type   const  & id ) :       273 &#160;                n_(0),       274 &#160;                c_id_(0),       275 &#160;                c_context_(0),       276 &#160;                c_plural_(0),       277 &#160;                id_(id),       278 &#160;                context_(context)       279 &#160;            {       280 &#160;            }       281 &#160;        287  &#160;             explicit   basic_message ( string_type   const  &context, string_type   const  &single, string_type   const  &plural, int   number ) :       288 &#160;                n_( number ),       289 &#160;                c_id_(0),       290 &#160;                c_context_(0),       291 &#160;                c_plural_(0),       292 &#160;                id_(single),       293 &#160;                context_(context),       294 &#160;                plural_(plural)       295 &#160;            {       296 &#160;            }       297 &#160;        301  &#160;             basic_message ( basic_message   const  &other) :       302 &#160;                n_(other.n_),       303 &#160;                c_id_(other.c_id_),       304 &#160;                c_context_(other.c_context_),       305 &#160;                c_plural_(other.c_plural_),       306 &#160;                id_(other.id_),       307 &#160;                context_(other.context_),       308 &#160;                plural_(other.plural_)       309 &#160;            {       310 &#160;            }       311 &#160;        315  &#160;             basic_message   const  & operator= ( basic_message   const  &other)       316 &#160;            {       317 &#160;                 if ( this ==&other) {       318 &#160;                     return  * this ;       319 &#160;                }       320 &#160;                 basic_message  tmp(other);       321 &#160;                 swap (tmp);       322 &#160;                 return  * this ;       323 &#160;            }       324 &#160;        328  &#160;             void   swap ( basic_message  &other)       329 &#160;            {       330 &#160;                std::swap(n_,other.n_);       331 &#160;                std::swap(c_id_,other.c_id_);       332 &#160;                std::swap(c_context_,other.c_context_);       333 &#160;                std::swap(c_plural_,other.c_plural_);       334 &#160;       335 &#160;                id_.swap(other.id_);       336 &#160;                context_.swap(other.context_);       337 &#160;                plural_.swap(other.plural_);       338 &#160;            }       339 &#160;       343 &#160;        344  &#160;             operator   string_type  ()  const        345 &#160;              {       346 &#160;                 return   str ();       347 &#160;            }       348 &#160;        352  &#160;             string_type   str ()  const        353 &#160;              {       354 &#160;                std::locale loc;       355 &#160;                 return   str (loc,0);       356 &#160;            }       357 &#160;        361  &#160;             string_type   str (std::locale  const  &locale)  const        362 &#160;              {       363 &#160;                 return   str (locale,0);       364 &#160;            }       365 &#160;        369  &#160;             string_type   str (std::locale  const  &locale,std::string  const  &domain_id)  const        370 &#160;              {       371 &#160;                 int   id =0;       372 &#160;                 if (std::has_facet<facet_type>(locale))       373 &#160;                     id =std::use_facet<facet_type>(locale).domain(domain_id);       374 &#160;                 return   str (locale, id );       375 &#160;            }       376 &#160;        380  &#160;             string_type   str (std::string  const  &domain_id)  const        381 &#160;              {       382 &#160;                 int   id =0;       383 &#160;                std::locale loc;       384 &#160;                 if (std::has_facet<facet_type>(loc))       385 &#160;                     id =std::use_facet<facet_type>(loc).domain(domain_id);       386 &#160;                 return   str (loc, id );       387 &#160;            }       388 &#160;       389 &#160;        393  &#160;             string_type   str (std::locale  const  &loc, int   id )  const        394 &#160;              {       395 &#160;                 string_type  buffer;       396 &#160;                 char_type   const  *ptr =  write (loc, id ,buffer);       397 &#160;                 if (ptr == buffer.c_str())       398 &#160;                     return  buffer;       399 &#160;                 else        400 &#160;                    buffer = ptr;       401 &#160;                 return  buffer;       402 &#160;            }       403 &#160;       404 &#160;        409  &#160;             void   write (std::basic_ostream<char_type> &out)  const        410 &#160;              {       411 &#160;                std::locale  const  &loc = out.getloc();       412 &#160;                 int   id  =  ios_info::get (out). domain_id ();       413 &#160;                 string_type  buffer;       414 &#160;                out <<  write (loc, id ,buffer);       415 &#160;            }       416 &#160;       417 &#160;         private :       418 &#160;             char_type   const  *plural()  const        419 &#160;              {       420 &#160;                 if (c_plural_)       421 &#160;                     return  c_plural_;       422 &#160;                 if (plural_.empty())       423 &#160;                     return  0;       424 &#160;                 return  plural_.c_str();       425 &#160;            }       426 &#160;             char_type   const  *context()  const        427 &#160;              {       428 &#160;                 if (c_context_)       429 &#160;                     return  c_context_;       430 &#160;                 if (context_.empty())       431 &#160;                     return  0;       432 &#160;                 return  context_.c_str();       433 &#160;            }       434 &#160;       435 &#160;             char_type   const  *id()  const        436 &#160;              {       437 &#160;                 return  c_id_ ? c_id_ : id_.c_str();       438 &#160;            }       439 &#160;       440 &#160;             char_type   const  * write (std::locale  const  &loc, int  domain_id, string_type  &buffer)  const        441 &#160;              {       442 &#160;                 char_type   const  *translated = 0;       443 &#160;                 static   const   char_type  empty_string[1] = {0};       444 &#160;       445 &#160;                 char_type   const  * id  = this->id();       446 &#160;                 char_type   const  *context = this->context();       447 &#160;                 char_type   const  *plural = this->plural();       448 &#160;       449 &#160;                 if (* id  == 0)       450 &#160;                     return  empty_string;       451 &#160;       452 &#160;                 facet_type   const  *facet = 0;       453 &#160;                 if (std::has_facet<facet_type>(loc))       454 &#160;                    facet = &std::use_facet<facet_type>(loc);       455 &#160;       456 &#160;                 if (facet) {       457 &#160;                     if (!plural) {       458 &#160;                        translated = facet->get(domain_id,context, id );       459 &#160;                    }       460 &#160;                     else  {       461 &#160;                        translated = facet->get(domain_id,context, id ,n_);       462 &#160;                    }       463 &#160;                }       464 &#160;       465 &#160;                 if (!translated) {       466 &#160;                     char_type   const  *msg = plural ? ( n_ == 1 ? id : plural) :  id ;       467 &#160;       468 &#160;                     if (facet) {       469 &#160;                        translated = facet->convert(msg,buffer);       470 &#160;                    }       471 &#160;                     else  {       472 &#160;                        translated = details::string_cast_traits<char_type>::cast(msg,buffer);       473 &#160;                    }       474 &#160;                }       475 &#160;                 return  translated;       476 &#160;            }       477 &#160;       479 &#160;       480 &#160;             int  n_;       481 &#160;             char_type   const  *c_id_;       482 &#160;             char_type   const  *c_context_;       483 &#160;             char_type   const  *c_plural_;       484 &#160;             string_type  id_;       485 &#160;             string_type  context_;       486 &#160;             string_type  plural_;       487 &#160;        };       488 &#160;       489 &#160;        493  &#160;         typedef   basic_message<char>   message ;        497  &#160;         typedef   basic_message<wchar_t>   wmessage ;       498 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        499 &#160;         typedef   basic_message<char16_t>   u16message ;       503 &#160;         #endif        504 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        505 &#160;         typedef   basic_message<char32_t>   u32message ;       509 &#160;         #endif        510 &#160;       514 &#160;         template < typename  CharType>        515  &#160;        std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out, basic_message<CharType>   const  &msg)       516 &#160;        {       517 &#160;            msg. write (out);       518 &#160;             return  out;       519 &#160;        }       520 &#160;       524 &#160;       528 &#160;         template < typename  CharType>        529  &#160;         inline   basic_message<CharType>   translate (CharType  const  *msg)       530 &#160;        {       531 &#160;             return   basic_message<CharType> (msg);       532 &#160;        }       536 &#160;         template < typename  CharType>        537  &#160;         inline   basic_message<CharType>   translate (   CharType  const  *context,       538 &#160;                                                    CharType  const  *msg)       539 &#160;        {       540 &#160;             return   basic_message<CharType> (context,msg);       541 &#160;        }       545 &#160;         template < typename  CharType>        546  &#160;         inline   basic_message<CharType>   translate (   CharType  const  *single,       547 &#160;                                                    CharType  const  *plural,       548 &#160;                                                     int  n)       549 &#160;        {       550 &#160;             return   basic_message<CharType> (single,plural,n);       551 &#160;        }       555 &#160;         template < typename  CharType>        556  &#160;         inline   basic_message<CharType>   translate (   CharType  const  *context,       557 &#160;                                                    CharType  const  *single,       558 &#160;                                                    CharType  const  *plural,       559 &#160;                                                     int  n)       560 &#160;        {       561 &#160;             return   basic_message<CharType> (context,single,plural,n);       562 &#160;        }       563 &#160;       567 &#160;         template < typename  CharType>        568  &#160;         inline   basic_message<CharType>   translate (std::basic_string<CharType>  const  &msg)       569 &#160;        {       570 &#160;             return   basic_message<CharType> (msg);       571 &#160;        }       572 &#160;       576 &#160;         template < typename  CharType>        577  &#160;         inline   basic_message<CharType>   translate (   std::basic_string<CharType>  const  &context,       578 &#160;                                                    std::basic_string<CharType>  const  &msg)       579 &#160;        {       580 &#160;             return   basic_message<CharType> (context,msg);       581 &#160;        }       585 &#160;         template < typename  CharType>        586  &#160;         inline   basic_message<CharType>   translate (   std::basic_string<CharType>  const  &context,       587 &#160;                                                    std::basic_string<CharType>  const  &single,       588 &#160;                                                    std::basic_string<CharType>  const  &plural,       589 &#160;                                                     int  n)       590 &#160;        {       591 &#160;             return   basic_message<CharType> (context,single,plural,n);       592 &#160;        }       593 &#160;       597 &#160;       598 &#160;         template < typename  CharType>        599  &#160;         inline   basic_message<CharType>   translate (   std::basic_string<CharType>  const  &single,       600 &#160;                                                    std::basic_string<CharType>  const  &plural,       601 &#160;                                                     int  n)       602 &#160;        {       603 &#160;             return   basic_message<CharType> (single,plural,n);       604 &#160;        }       605 &#160;       607 &#160;       611 &#160;       615 &#160;         template < typename  CharType>        616  &#160;        std::basic_string<CharType>  gettext (CharType  const  * id ,       617 &#160;                                            std::locale  const  &loc=std::locale())       618 &#160;        {       619 &#160;             return   basic_message<CharType> ( id ). str (loc);       620 &#160;        }       624 &#160;         template < typename  CharType>        625  &#160;        std::basic_string<CharType>  ngettext (   CharType  const  *s,       626 &#160;                                                CharType  const  *p,       627 &#160;                                                 int  n,       628 &#160;                                                std::locale  const  &loc=std::locale())       629 &#160;        {       630 &#160;             return   basic_message<CharType> (s,p,n). str (loc);       631 &#160;        }       635 &#160;         template < typename  CharType>        636  &#160;        std::basic_string<CharType>   dgettext (   char   const  * domain ,       637 &#160;                                                CharType  const  * id ,       638 &#160;                                                std::locale  const  &loc=std::locale())       639 &#160;        {       640 &#160;             return   basic_message<CharType> ( id ). str (loc, domain );       641 &#160;        }       642 &#160;       646 &#160;         template < typename  CharType>        647  &#160;        std::basic_string<CharType>   dngettext (  char   const  * domain ,       648 &#160;                                                CharType  const  *s,       649 &#160;                                                CharType  const  *p,       650 &#160;                                                 int  n,       651 &#160;                                                std::locale  const  &loc=std::locale())       652 &#160;        {       653 &#160;             return   basic_message<CharType> (s,p,n). str (loc, domain );       654 &#160;        }       658 &#160;         template < typename  CharType>        659  &#160;        std::basic_string<CharType>   pgettext (  CharType  const  *context,       660 &#160;                                                CharType  const  * id ,       661 &#160;                                                std::locale  const  &loc=std::locale())       662 &#160;        {       663 &#160;             return   basic_message<CharType> (context, id ). str (loc);       664 &#160;        }       668 &#160;         template < typename  CharType>        669  &#160;        std::basic_string<CharType>   npgettext ( CharType  const  *context,       670 &#160;                                                CharType  const  *s,       671 &#160;                                                CharType  const  *p,       672 &#160;                                                 int  n,       673 &#160;                                                std::locale  const  &loc=std::locale())       674 &#160;        {       675 &#160;             return   basic_message<CharType> (context,s,p,n). str (loc);       676 &#160;        }       680 &#160;         template < typename  CharType>        681  &#160;        std::basic_string<CharType>   dpgettext (  char   const  * domain ,       682 &#160;                                                CharType  const  *context,       683 &#160;                                                CharType  const  * id ,       684 &#160;                                                std::locale  const  &loc=std::locale())       685 &#160;        {       686 &#160;             return   basic_message<CharType> (context, id ). str (loc, domain );       687 &#160;        }       691 &#160;         template < typename  CharType>        692  &#160;        std::basic_string<CharType>   dnpgettext ( char   const  * domain ,       693 &#160;                                                CharType  const  *context,       694 &#160;                                                CharType  const  *s,       695 &#160;                                                CharType  const  *p,       696 &#160;                                                 int  n,       697 &#160;                                                std::locale  const  &loc=std::locale())       698 &#160;        {       699 &#160;             return   basic_message<CharType> (context,s,p,n). str (loc, domain );       700 &#160;        }       701 &#160;       705 &#160;       706 &#160;         template <>       707 &#160;         struct  BOOST_LOCALE_DECL base_message_format<char> :  public  std::locale::facet       708 &#160;        {       709 &#160;            base_message_format( size_t  refs = 0) : std::locale::facet(refs)       710 &#160;            {       711 &#160;            }       712 &#160;             static  std::locale::id id;       713 &#160;        };       714 &#160;       715 &#160;         template <>       716 &#160;         struct  BOOST_LOCALE_DECL base_message_format<wchar_t> :  public  std::locale::facet       717 &#160;        {       718 &#160;            base_message_format( size_t  refs = 0) : std::locale::facet(refs)       719 &#160;            {       720 &#160;            }       721 &#160;             static  std::locale::id id;       722 &#160;        };       723 &#160;       724 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        725 &#160;       726 &#160;         template <>       727 &#160;         struct  BOOST_LOCALE_DECL base_message_format<char16_t> :  public  std::locale::facet       728 &#160;        {       729 &#160;            base_message_format( size_t  refs = 0) : std::locale::facet(refs)       730 &#160;            {       731 &#160;            }       732 &#160;             static  std::locale::id id;       733 &#160;        };       734 &#160;       735 &#160;         #endif        736 &#160;       737 &#160;         #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        738 &#160;       739 &#160;         template <>       740 &#160;         struct  BOOST_LOCALE_DECL base_message_format<char32_t> :  public  std::locale::facet       741 &#160;        {       742 &#160;            base_message_format( size_t  refs = 0) : std::locale::facet(refs)       743 &#160;            {       744 &#160;            }       745 &#160;             static  std::locale::id id;       746 &#160;        };       747 &#160;       748 &#160;         #endif        749 &#160;       751 &#160;       755 &#160;       756 &#160;         namespace  as {       758 &#160;             namespace  details {       759 &#160;                 struct  set_domain {       760 &#160;                    std::string  domain_id ;       761 &#160;                };       762 &#160;                 template < typename  CharType>       763 &#160;                std::basic_ostream<CharType> & operator<< (std::basic_ostream<CharType> &out, set_domain  const  &dom)       764 &#160;                {       765 &#160;                     int   id  = std::use_facet<message_format<CharType> >(out.getloc()). domain (dom.domain_id);       766 &#160;                     ios_info::get (out). domain_id ( id );       767 &#160;                     return  out;       768 &#160;                }       769 &#160;            }  // details        771 &#160;         776 &#160;       782 &#160;             inline        783 &#160;             #ifdef BOOST_LOCALE_DOXYGEN        784 &#160;            unspecified_type       785 &#160;             #else        786 &#160;            details::set_domain       787 &#160;             #endif         788  &#160;             domain (std::string  const  & id )       789 &#160;            {       790 &#160;                details::set_domain tmp = {  id  };       791 &#160;                 return  tmp;       792 &#160;            }       794 &#160;        }  // as        795 &#160;    }  // locale        796 &#160;}  // boost        797 &#160;       798 &#160; #ifdef BOOST_MSVC        799 &#160; #pragma warning(pop)        800 &#160; #endif        801 &#160;       802 &#160;       803 &#160; #endif        804 &#160;       805 &#160;    boost::locale::ngettext   std::basic_string< CharType > ngettext(CharType const *s, CharType const *p, int n, std::locale const &loc=std::locale())   Definition:  message.hpp:625     boost::locale::message_format::message_format   message_format(size_t refs=0)   Definition:  message.hpp:66     boost::locale::basic_message::basic_message   basic_message(char_type const *context, char_type const *id)   Definition:  message.hpp:219     boost::locale::basic_message::str   string_type str(std::string const &domain_id) const   Definition:  message.hpp:380     boost::locale::basic_message::basic_message   basic_message(string_type const &id)   Definition:  message.hpp:245     boost::locale::basic_message::char_type   CharType char_type  The character this message object is used with.   Definition:  message.hpp:173     boost::locale::basic_message::basic_message   basic_message(string_type const &context, string_type const &id)   Definition:  message.hpp:272     boost::locale::basic_message::string_type   std::basic_string< char_type > string_type  The string type this object can be used with.   Definition:  message.hpp:174     boost::locale::basic_message::swap   void swap(basic_message &other)   Definition:  message.hpp:328     boost::locale::basic_message::basic_message   basic_message(char_type const *id)   Definition:  message.hpp:192     boost::locale::wmessage   basic_message< wchar_t > wmessage   Definition:  message.hpp:497     boost::locale::basic_message   This class represents a message that can be converted to a specific locale message.   Definition:  message.hpp:170     boost::locale::npgettext   std::basic_string< CharType > npgettext(CharType const *context, CharType const *s, CharType const *p, int n, std::locale const &loc=std::locale())   Definition:  message.hpp:669     boost::locale::u32message   basic_message< char32_t > u32message   Definition:  message.hpp:508     boost::locale::basic_message::str   string_type str() const   Definition:  message.hpp:352     boost::locale::basic_message::operator=   basic_message const  & operator=(basic_message const &other)   Definition:  message.hpp:315     boost::locale::message_format   This facet provides message formatting abilities.   Definition:  message.hpp:50     boost::locale::basic_message::str   string_type str(std::locale const &loc, int id) const   Definition:  message.hpp:393     boost::locale::dnpgettext   std::basic_string< CharType > dnpgettext(char const *domain, CharType const *context, CharType const *s, CharType const *p, int n, std::locale const &loc=std::locale())   Definition:  message.hpp:692     boost::locale::as::number   std::ios_base & number(std::ios_base &ios)   Definition:  formatting.hpp:292     boost::locale::message_format::char_type   CharType char_type   Definition:  message.hpp:57     boost::locale::message   basic_message< char > message   Definition:  message.hpp:493     boost::locale::basic_message::basic_message   basic_message(string_type const &single, string_type const &plural, int number)   Definition:  message.hpp:259     boost::locale::ios_info::get   static ios_info & get(std::ios_base &ios)     boost::locale::basic_message::basic_message   basic_message()   Definition:  message.hpp:180     boost::locale::dgettext   std::basic_string< CharType > dgettext(char const *domain, CharType const *id, std::locale const &loc=std::locale())   Definition:  message.hpp:636     boost::locale::translate   basic_message< CharType > translate(CharType const *msg)  Translate a message, msg is not copied.   Definition:  message.hpp:529     boost::locale::as::domain   unspecified_type domain(std::string const &id)   Definition:  message.hpp:788     boost::locale::pgettext   std::basic_string< CharType > pgettext(CharType const *context, CharType const *id, std::locale const &loc=std::locale())   Definition:  message.hpp:659     boost::locale::basic_message::basic_message   basic_message(string_type const &context, string_type const &single, string_type const &plural, int number)   Definition:  message.hpp:287     boost::locale::dpgettext   std::basic_string< CharType > dpgettext(char const *domain, CharType const *context, CharType const *id, std::locale const &loc=std::locale())   Definition:  message.hpp:681     boost::locale::basic_message::str   string_type str(std::locale const &locale, std::string const &domain_id) const   Definition:  message.hpp:369     boost::locale::basic_message::write   void write(std::basic_ostream< char_type > &out) const   Definition:  message.hpp:409     boost::locale::ios_info::domain_id   void domain_id(int)     boost::locale::u16message   basic_message< char16_t > u16message   Definition:  message.hpp:502     boost::locale::gettext   std::basic_string< CharType > gettext(CharType const *id, std::locale const &loc=std::locale())   Definition:  message.hpp:616     boost::locale::basic_message::basic_message   basic_message(char_type const *single, char_type const *plural, int n)   Definition:  message.hpp:206     boost::locale::operator<<   std::basic_ostream< CharType > & operator<<(std::basic_ostream< CharType > &out, date_time const &t)   Definition:  date_time.hpp:871     boost::locale::basic_message::basic_message   basic_message(char_type const *context, char_type const *single, char_type const *plural, int n)   Definition:  message.hpp:233     boost::locale::message_format::string_type   std::basic_string< CharType > string_type   Definition:  message.hpp:61     boost::locale::basic_message::str   string_type str(std::locale const &locale) const   Definition:  message.hpp:361     boost::locale::basic_message::facet_type   message_format< char_type > facet_type  The type of the facet the messages are fetched with.   Definition:  message.hpp:175     boost::locale::dngettext   std::basic_string< CharType > dngettext(char const *domain, CharType const *s, CharType const *p, int n, std::locale const &loc=std::locale())   Definition:  message.hpp:647     boost::locale::flags::domain_id   Domain code - for message formatting.   Definition:  formatting.hpp:86     boost::locale::basic_message::basic_message   basic_message(basic_message const &other)   Definition:  message.hpp:301             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('facets_8hpp_source.html','');});/* @license-end */       facets.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_BOUNDARY_FACETS_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_BOUNDARY_FACETS_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/boundary/types.hpp>         11 &#160; #include <locale>         12 &#160; #include <vector>         13 &#160;        14 &#160; #ifdef BOOST_MSVC         15 &#160; #  pragma warning(push)         16 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         17 &#160; #endif         18 &#160;        19 &#160; namespace  boost {        20 &#160;        21 &#160;     namespace  locale {        22 &#160;        26 &#160;         namespace  boundary {        32 &#160;        33 &#160;         38  &#160;             struct   break_info  {        39 &#160;         43  &#160;                 break_info () :        44 &#160;                     offset (0),        45 &#160;                     rule (0)        46 &#160;                {        47 &#160;                }         52  &#160;                 break_info ( size_t  v) :        53 &#160;                     offset (v),        54 &#160;                     rule (0)        55 &#160;                {        56 &#160;                }        57 &#160;         61  &#160;                 size_t   offset ;         66  &#160;                 rule_type   rule ;        67 &#160;         72  &#160;                 bool   operator< ( break_info   const  &other)  const         73 &#160;                  {        74 &#160;                     return   offset  < other. offset ;        75 &#160;                }        76 &#160;            };        77 &#160;         82  &#160;             typedef  std::vector<break_info>  index_type ;        83 &#160;        84 &#160;        85 &#160;             template < typename  CharType>         86  &#160;             class   boundary_indexing ;        87 &#160;        88 &#160;             #ifdef BOOST_LOCALE_DOXYGEN         89 &#160;             template < typename  Char>        96 &#160;             class  BOOST_LOCALE_DECL  boundary_indexing  :  public  std::locale::facet {        97 &#160;             public :        101  &#160;                 boundary_indexing ( size_t  refs=0) : std::locale::facet(refs)       102 &#160;                {       103 &#160;                }       111 &#160;                 virtual   index_type  map( boundary_type  t,Char  const  *begin,Char  const  *end)  const  = 0;        115  &#160;                 static  std::locale::id  id ;       116 &#160;       117 &#160;                 #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        118 &#160;                std::locale::id& __get_id ( void )  const  {  return  id; }       119 &#160;                 #endif        120 &#160;            };       121 &#160;       122 &#160;             #else        123 &#160;       124 &#160;             template <>       125 &#160;             class  BOOST_LOCALE_DECL boundary_indexing<char> :  public  std::locale::facet {       126 &#160;             public :       127 &#160;                boundary_indexing( size_t  refs=0) : std::locale::facet(refs)       128 &#160;                {       129 &#160;                }       130 &#160;                ~boundary_indexing();       131 &#160;                 virtual   index_type  map( boundary_type  t, char   const  *begin, char   const  *end)  const  = 0;       132 &#160;                 static  std::locale::id id;       133 &#160;                 #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        134 &#160;                std::locale::id& __get_id ( void )  const  {  return  id; }       135 &#160;                 #endif        136 &#160;            };       137 &#160;       138 &#160;             template <>       139 &#160;             class  BOOST_LOCALE_DECL boundary_indexing<wchar_t> :  public  std::locale::facet {       140 &#160;             public :       141 &#160;                boundary_indexing( size_t  refs=0) : std::locale::facet(refs)       142 &#160;                {       143 &#160;                }       144 &#160;                ~boundary_indexing();       145 &#160;                 virtual   index_type  map( boundary_type  t, wchar_t   const  *begin, wchar_t   const  *end)  const  = 0;       146 &#160;       147 &#160;                 static  std::locale::id id;       148 &#160;                 #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        149 &#160;                std::locale::id& __get_id ( void )  const  {  return  id; }       150 &#160;                 #endif        151 &#160;            };       152 &#160;       153 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR16_T        154 &#160;             template <>       155 &#160;             class  BOOST_LOCALE_DECL boundary_indexing<char16_t> :  public  std::locale::facet {       156 &#160;             public :       157 &#160;                boundary_indexing( size_t  refs=0) : std::locale::facet(refs)       158 &#160;                {       159 &#160;                }       160 &#160;                ~boundary_indexing();       161 &#160;                 virtual   index_type  map( boundary_type  t,char16_t  const  *begin,char16_t  const  *end)  const  = 0;       162 &#160;                 static  std::locale::id id;       163 &#160;                 #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        164 &#160;                std::locale::id& __get_id ( void )  const  {  return  id; }       165 &#160;                 #endif        166 &#160;            };       167 &#160;             #endif        168 &#160;       169 &#160;             #ifdef BOOST_LOCALE_ENABLE_CHAR32_T        170 &#160;             template <>       171 &#160;             class  BOOST_LOCALE_DECL boundary_indexing<char32_t> :  public  std::locale::facet {       172 &#160;             public :       173 &#160;                boundary_indexing( size_t  refs=0) : std::locale::facet(refs)       174 &#160;                {       175 &#160;                }       176 &#160;                ~boundary_indexing();       177 &#160;                 virtual   index_type  map( boundary_type  t,char32_t  const  *begin,char32_t  const  *end)  const  = 0;       178 &#160;                 static  std::locale::id id;       179 &#160;                 #if defined (__SUNPRO_CC) && defined (_RWSTD_VER)        180 &#160;                std::locale::id& __get_id ( void )  const  {  return  id; }       181 &#160;                 #endif        182 &#160;            };       183 &#160;             #endif        184 &#160;       185 &#160;             #endif        186 &#160;       190 &#160;       191 &#160;       192 &#160;        }  // boundary        193 &#160;       194 &#160;    }  // locale        195 &#160;}  // boost        196 &#160;       197 &#160;       198 &#160; #ifdef BOOST_MSVC        199 &#160; #pragma warning(pop)        200 &#160; #endif        201 &#160;       202 &#160; #endif     boost::locale::boundary::boundary_indexing   This facet generates an index for boundary analysis for a given text.   Definition:  facets.hpp:86     boost::locale::boundary::boundary_type   boundary_type   Definition:  types.hpp:38     boost::locale::boundary::break_info::break_info   break_info()   Definition:  facets.hpp:43     boost::locale::boundary::break_info::break_info   break_info(size_t v)   Definition:  facets.hpp:52     boost::locale::boundary::break_info   This structure is used for representing boundary point that follows the offset.   Definition:  facets.hpp:38     boost::locale::boundary::rule_type   uint32_t rule_type  Flags used with word boundary analysis – the type of the word, line or sentence boundary found.   Definition:  types.hpp:50     boost::locale::boundary::break_info::rule   rule_type rule   Definition:  facets.hpp:66     boost::locale::boundary::boundary_indexing::boundary_indexing   boundary_indexing(size_t refs=0)   Definition:  facets.hpp:101     boost::locale::boundary::boundary_indexing::id   static std::locale::id id   Definition:  facets.hpp:115     boost::locale::boundary::break_info::offset   size_t offset   Definition:  facets.hpp:61     boost::locale::boundary::break_info::operator<   bool operator<(break_info const &other) const   Definition:  facets.hpp:72     boost::locale::boundary::index_type   std::vector< break_info > index_type   Definition:  facets.hpp:82             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
2022-12-28 23:46:38 util.hpp:63 ERROR Not Find Key Word: file
2022-12-28 23:46:38 util.hpp:64 ERROR             /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */  $(document).ready(initResizable);/* @license-end */                         Boost.Locale                    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(function() {  initMenu('',false,false,'search.php','Search');});/* @license-end */                                      /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&dn=gpl-2.0.txt GPL-v2 */$(document).ready(function(){initNavTree('collator_8hpp_source.html','');});/* @license-end */       collator.hpp                1 &#160; //          2 &#160; // Copyright (c) 2009-2011 Artyom Beilis (Tonkikh)          3 &#160; //          4 &#160; // Distributed under the Boost Software License, Version 1.0.          5 &#160; // https://www.boost.org/LICENSE_1_0.txt          6 &#160;         7 &#160; #ifndef BOOST_LOCALE_COLLATOR_HPP_INCLUDED          8 &#160; #define BOOST_LOCALE_COLLATOR_HPP_INCLUDED          9 &#160;        10 &#160; #include <boost/locale/config.hpp>         11 &#160; #include <locale>         12 &#160;        13 &#160; #ifdef BOOST_MSVC         14 &#160; #  pragma warning(push)         15 &#160; #  pragma warning(disable : 4275 4251 4231 4660)         16 &#160; #endif         17 &#160;        18 &#160; namespace  boost {         19  &#160; namespace  locale {        20 &#160;        21 &#160;     class   info ;        22 &#160;        29 &#160;        33 &#160;         34  &#160;     class   collator_base  {        35 &#160;     public :         39  &#160;         typedef   enum  {         40  &#160;             primary      = 0,          41  &#160;             secondary    = 1,          42  &#160;             tertiary     = 2,          43  &#160;             quaternary   = 3,          44  &#160;             identical    = 4          45 &#160;        }  level_type ;        46 &#160;    };        47 &#160;        54 &#160;     template < typename  CharType>         55  &#160;     class   collator  :        56 &#160;         public  std::collate<CharType>,        57 &#160;         public   collator_base         58 &#160;    {        59 &#160;     public :         63  &#160;         typedef  CharType  char_type ;         67  &#160;         typedef  std::basic_string<CharType>  string_type ;        68 &#160;        69 &#160;         76  &#160;         int   compare ( level_type  level,        77 &#160;                     char_type   const  *b1, char_type   const  *e1,        78 &#160;                     char_type   const  *b2, char_type   const  *e2)  const         79 &#160;          {        80 &#160;             return   do_compare (level,b1,e1,b2,e2);        81 &#160;        }         93  &#160;         string_type   transform ( level_type  level, char_type   const  *b, char_type   const  *e)  const         94 &#160;          {        95 &#160;             return   do_transform (level,b,e);        96 &#160;        }        97 &#160;        105  &#160;         long   hash ( level_type  level, char_type   const  *b, char_type   const  *e)  const        106 &#160;          {       107 &#160;             return   do_hash (level,b,e);       108 &#160;        }       109 &#160;        117  &#160;         int   compare ( level_type  level, string_type   const  &l, string_type   const  &r)  const        118 &#160;          {       119 &#160;             return   do_compare (level,l.data(),l.data()+l.size(),r.data(),r.data()+r.size());       120 &#160;        }       121 &#160;       127 &#160;        128  &#160;         long   hash ( level_type  level, string_type   const  &s)  const        129 &#160;          {       130 &#160;             return   do_hash (level,s.data(),s.data()+s.size());       131 &#160;        }        141  &#160;         string_type   transform ( level_type  level, string_type   const  &s)  const        142 &#160;          {       143 &#160;             return   do_transform (level,s.data(),s.data()+s.size());       144 &#160;        }       145 &#160;       146 &#160;     protected :       147 &#160;        151  &#160;         collator ( size_t  refs = 0) : std::collate<CharType>(refs)       152 &#160;        {       153 &#160;        }       154 &#160;        159  &#160;         int   do_compare (  char_type   const  *b1, char_type   const  *e1,       160 &#160;                         char_type   const  *b2, char_type   const  *e2)  const  BOOST_OVERRIDE       161 &#160;        {       162 &#160;             return   do_compare ( identical ,b1,e1,b2,e2);       163 &#160;        }        168  &#160;         string_type   do_transform ( char_type   const  *b, char_type   const  *e)  const  BOOST_OVERRIDE       169 &#160;        {       170 &#160;             return   do_transform ( identical ,b,e);       171 &#160;        }        176  &#160;         long   do_hash ( char_type   const  *b, char_type   const  *e)  const  BOOST_OVERRIDE       177 &#160;        {       178 &#160;             return   do_hash ( identical ,b,e);       179 &#160;        }       180 &#160;       184 &#160;         virtual   int   do_compare (  level_type  level,       185 &#160;                                 char_type   const  *b1, char_type   const  *e1,       186 &#160;                                 char_type   const  *b2, char_type   const  *e2)  const  = 0;       190 &#160;         virtual   string_type   do_transform ( level_type  level, char_type   const  *b, char_type   const  *e)  const  = 0;       194 &#160;         virtual   long   do_hash ( level_type  level, char_type   const  *b, char_type   const  *e)  const  = 0;       195 &#160;       196 &#160;       197 &#160;    };       198 &#160;       211 &#160;     template < typename  CharType,collator_base::level_type default_level = collator_base:: id entical>        212  &#160;     struct   comparator        213 &#160;    {       214 &#160;     public :        220  &#160;         comparator (std::locale  const  &l=std::locale(), collator_base::level_type  level=default_level) :       221 &#160;            locale_(l),       222 &#160;            level_(level)       223 &#160;        {       224 &#160;        }       225 &#160;        229  &#160;         bool   operator() (std::basic_string<CharType>  const  &left,std::basic_string<CharType>  const  &right)  const        230 &#160;          {       231 &#160;             return  std::use_facet<collator<CharType> >(locale_).compare(level_,left,right) < 0;       232 &#160;        }       233 &#160;     private :       234 &#160;        std::locale locale_;       235 &#160;         collator_base::level_type  level_;       236 &#160;    };       237 &#160;       238 &#160;       242 &#160;       243 &#160;    }  // locale        244 &#160;}  // boost        245 &#160;       246 &#160; #ifdef BOOST_MSVC        247 &#160; #pragma warning(pop)        248 &#160; #endif        249 &#160;       250 &#160;       251 &#160; #endif        252 &#160;   boost::locale::collator::do_compare   int do_compare(char_type const *b1, char_type const *e1, char_type const *b2, char_type const *e2) const BOOST_OVERRIDE   Definition:  collator.hpp:159     boost::locale::info   a facet that holds general information about locale   Definition:  info.hpp:27     boost::locale::collator::compare   int compare(level_type level, char_type const *b1, char_type const *e1, char_type const *b2, char_type const *e2) const   Definition:  collator.hpp:76     boost::locale::collator_base::primary   1st collation level: base letters   Definition:  collator.hpp:40     boost::locale::collator_base::secondary   2nd collation level: letters and accents   Definition:  collator.hpp:41     boost::locale::collator_base::level_type   level_type   Definition:  collator.hpp:39     boost::locale::collator::char_type   CharType char_type   Definition:  collator.hpp:63     boost::locale::comparator::operator()   bool operator()(std::basic_string< CharType > const &left, std::basic_string< CharType > const &right) const   Definition:  collator.hpp:229     boost::locale::collator::hash   long hash(level_type level, char_type const *b, char_type const *e) const   Definition:  collator.hpp:105     boost::locale::collator_base::identical   identical collation level: include code-point comparison   Definition:  collator.hpp:44     boost::locale::collator::string_type   std::basic_string< CharType > string_type   Definition:  collator.hpp:67     boost::locale::collator_base   a base class that includes collation level flags   Definition:  collator.hpp:34     boost::locale::collator::do_transform   string_type do_transform(char_type const *b, char_type const *e) const BOOST_OVERRIDE   Definition:  collator.hpp:168     boost::locale::collator::transform   string_type transform(level_type level, char_type const *b, char_type const *e) const   Definition:  collator.hpp:93     boost::locale::collator::collator   collator(size_t refs=0)   Definition:  collator.hpp:151     boost::locale::collator_base::quaternary   4th collation level: letters, accents, case and punctuation   Definition:  collator.hpp:43     boost::locale::collator::compare   int compare(level_type level, string_type const &l, string_type const &r) const   Definition:  collator.hpp:117     boost::locale::collator::do_hash   long do_hash(char_type const *b, char_type const *e) const BOOST_OVERRIDE   Definition:  collator.hpp:176     boost::locale::collator   Collation facet.   Definition:  collator.hpp:55     boost::locale::collator_base::tertiary   3rd collation level: letters, accents and case   Definition:  collator.hpp:42     boost::locale::comparator::comparator   comparator(std::locale const &l=std::locale(), collator_base::level_type level=default_level)   Definition:  collator.hpp:220     boost::locale::collator::transform   string_type transform(level_type level, string_type const &s) const   Definition:  collator.hpp:141     boost::locale::comparator   This class can be used in STL algorithms and containers for comparison of strings with a level other ...   Definition:  collator.hpp:212     boost::locale::collator::hash   long hash(level_type level, string_type const &s) const   Definition:  collator.hpp:128             &copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the  Boost Software License , Version 1.0.             
[2022-12-28 23:51:17.033] [info] 用户输入的关键字 filesystem
[2022-12-28 23:51:17.033] [info] Search() called with parameters => filesystem
[2022-12-28 23:51:17.033] [info] JieBaUtil::cut start
[2022-12-28 23:51:17.033] [info] JieBaUtil::cut ret
[2022-12-28 23:51:17.033] [info] GetInvertedlist() start
[2022-12-28 23:51:17.033] [info] GetInvertedlist() ret
[2022-12-28 23:51:17.033] [info] GetInvertedlist() filesystem has list
[2022-12-28 23:52:21.472] [info] 用户输入的关键字 filesystem
[2022-12-28 23:52:21.472] [info] Search() called with parameters => filesystem
[2022-12-28 23:52:21.472] [info] JieBaUtil::cut start
[2022-12-28 23:52:21.472] [info] JieBaUtil::cut ret
[2022-12-28 23:52:21.472] [info] GetInvertedlist() start
[2022-12-28 23:52:21.472] [info] GetInvertedlist() ret
[2022-12-28 23:52:21.472] [info] GetInvertedlist() filesystem has list
[2022-12-28 23:54:34.235] [info] 用户输入的关键字 filesystem v4
[2022-12-28 23:54:34.235] [info] Search() called with parameters => filesystem v4
[2022-12-28 23:54:34.235] [info] JieBaUtil::cut start
[2022-12-28 23:54:34.235] [info] JieBaUtil::cut ret
[2022-12-28 23:54:34.235] [info] GetInvertedlist() start
[2022-12-28 23:54:34.235] [info] GetInvertedlist() ret
[2022-12-28 23:54:34.235] [info] GetInvertedlist() filesystem has list
[2022-12-28 23:54:34.236] [info] GetInvertedlist() start
[2022-12-28 23:54:34.236] [info] GetInvertedlist() ret
[2022-12-28 23:54:34.236] [info] GetInvertedlist()   has list
[2022-12-28 23:54:34.262] [info] GetInvertedlist() start
[2022-12-28 23:54:34.262] [info] GetInvertedlist() ret
[2022-12-28 23:54:34.262] [info] GetInvertedlist() v4 has list
[2022-12-28 23:54:55.237] [info] 用户输入的关键字 Special Function and Distribution Performance Report
[2022-12-28 23:54:55.237] [info] Search() called with parameters => Special Function and Distribution Performance Report
[2022-12-28 23:54:55.237] [info] JieBaUtil::cut start
[2022-12-28 23:54:55.237] [info] JieBaUtil::cut ret
[2022-12-28 23:54:55.237] [info] GetInvertedlist() start
[2022-12-28 23:54:55.237] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.237] [info] GetInvertedlist() special has list
[2022-12-28 23:54:55.239] [info] GetInvertedlist() start
[2022-12-28 23:54:55.239] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.239] [info] GetInvertedlist()   has list
[2022-12-28 23:54:55.294] [info] GetInvertedlist() start
[2022-12-28 23:54:55.294] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.294] [info] GetInvertedlist() function has list
[2022-12-28 23:54:55.308] [info] GetInvertedlist() start
[2022-12-28 23:54:55.308] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.308] [info] GetInvertedlist()   has list
[2022-12-28 23:54:55.329] [info] GetInvertedlist() start
[2022-12-28 23:54:55.329] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.329] [info] GetInvertedlist() and has list
[2022-12-28 23:54:55.334] [info] GetInvertedlist() start
[2022-12-28 23:54:55.334] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.334] [info] GetInvertedlist()   has list
[2022-12-28 23:54:55.346] [info] GetInvertedlist() start
[2022-12-28 23:54:55.346] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.346] [info] GetInvertedlist() distribution has list
[2022-12-28 23:54:55.346] [info] GetInvertedlist() start
[2022-12-28 23:54:55.346] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.346] [info] GetInvertedlist()   has list
[2022-12-28 23:54:55.358] [info] GetInvertedlist() start
[2022-12-28 23:54:55.358] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.358] [info] GetInvertedlist() performance has list
[2022-12-28 23:54:55.358] [info] GetInvertedlist() start
[2022-12-28 23:54:55.358] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.358] [info] GetInvertedlist()   has list
[2022-12-28 23:54:55.370] [info] GetInvertedlist() start
[2022-12-28 23:54:55.370] [info] GetInvertedlist() ret
[2022-12-28 23:54:55.370] [info] GetInvertedlist() report has list
